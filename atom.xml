<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>front-auxiliary</title>
  
  <subtitle>离心最近的地方行程最远!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-13T15:10:55.099Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>front-auxiliary</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>thinkjs项目目录解析</title>
    <link href="http://yoursite.com/2019/07/13/node/application/"/>
    <id>http://yoursite.com/2019/07/13/node/application/</id>
    <published>2019-07-13T09:50:46.000Z</published>
    <updated>2019-07-13T15:10:55.099Z</updated>
    
    <content type="html"><![CDATA[<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><img src="/2019/07/13/node/application/directory.png" title="目录结构"><p>注：指定不同的模式创建的项目目录机构可能有细微的差别，但总体是类似的</p><h3 id="nginx-conf"><a href="#nginx-conf" class="headerlink" title="nginx.conf"></a>nginx.conf</h3><p>nginx 的配置文件，建议线上使用 nginx 做反向代理。</p><h3 id="src"><a href="#src" class="headerlink" title="src"></a>src</h3><p>源代码目录，使用 –es6 参数创建项目才有该目录。项目启动时会自动将 src 目录下的文件编译到 app 目录下。</p><p>如果没有使用 ES6 特性创建项目，则直接有 app/ 目录。</p><h3 id="src-common"><a href="#src-common" class="headerlink" title="src/common"></a>src/common</h3><p>通用模块目录，项目目录都是按模块来划分的，common 模块下存放一些通用的处理逻辑。</p><h3 id="src-common-bootstrap"><a href="#src-common-bootstrap" class="headerlink" title="src/common/bootstrap"></a>src/common/bootstrap</h3><p>项目启动目录，该目录下的文件会自动加载，无需手动 require 。</p><p>可以在这个目录下文件里定义一些全局函数、注册中间件等常用的功能。</p><p>定义全局函数<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// src/common/bootstrap/fn.js global.formatDate = obj =&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里定义了一个全局函数 formatDate，那么项目里任何地方都可以直接使用该函数。</p><p>注册中间件<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// src/common/bootstrap/middleware.js think.middleware(&quot;replace_image&quot;, http =&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这里定义了一个中间件 replace_image，那么就可以在配置文件 hook.js 里将该中间件注册进去了。</p><p>注：bootstrap 只能放在 common 模块里。</p><h3 id="src-common-config"><a href="#src-common-config" class="headerlink" title="src/common/config"></a>src/common/config</h3><p>配置文件，这里放一些通用的配置。</p><p>其中：路由配置、hook 配置、本地化配置等必须放在这里。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;; /**</span><br><span class="line"> * config</span><br><span class="line"> */ export default &#123; //key: value &#125;;</span><br></pre></td></tr></table></figure></p><h3 id="src-common-controller"><a href="#src-common-controller" class="headerlink" title="src/common/controller"></a>src/common/controller</h3><p>控制器，放一些通用的控制器。其中 error.js 里错误处理的不同行为，项目里可以根据需要进行修改。</p><h3 id="src-common-runtime"><a href="#src-common-runtime" class="headerlink" title="src/common/runtime"></a>src/common/runtime</h3><p>项目运行时生成的一些目录，如：缓存文件目录，用户上传的文件临时存放的目录。</p><h3 id="src-home"><a href="#src-home" class="headerlink" title="src/home"></a>src/home</h3><p>home 模块，项目默认模块。可以在 src/common/config/config.js 中修改配置 default_module 来重新定义默认模块。</p><h3 id="src-home-logic"><a href="#src-home-logic" class="headerlink" title="src/home/logic"></a>src/home/logic</h3><p>逻辑处理。每个操作执行前可以先进行逻辑校验，可以包含：参数是否合法、提交的数据是否正常、当前用户是否已经登录、当前用户是否有权限等。这样可以降低 controller 里的 action 的复杂度。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;; /**</span><br><span class="line"> * logic</span><br><span class="line"> * @param  &#123;&#125; []</span><br><span class="line"> * @return &#123;&#125;     []</span><br><span class="line"> */ export default class extends think.logic.base &#123; /**</span><br><span class="line">   * index action logic</span><br><span class="line">   * @return &#123;&#125; []</span><br><span class="line">   */ indexAction()&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="src-home-controller"><a href="#src-home-controller" class="headerlink" title="src/home/controller"></a>src/home/controller</h3><p>控制器。一个 url 对应一个 controller 下的 action。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;; import Base from &quot;./base.js&quot;; export default class extends Base &#123; /**</span><br><span class="line">   * index action</span><br><span class="line">   * @return &#123;Promise&#125; []</span><br><span class="line">   */ indexAction()&#123; //auto render template file index_index.html return this.display();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="src-home-model"><a href="#src-home-model" class="headerlink" title="src/home/model"></a>src/home/model</h3><p>模型。数据库相关操作。</p><h3 id="view"><a href="#view" class="headerlink" title="view"></a>view</h3><p>视图目录，存放对应的模版文件。如果支持国际化和多主题，那么视图目录下需要有对应的子目录。</p><h3 id="www"><a href="#www" class="headerlink" title="www"></a>www</h3><p>项目的可访问根目录，nginx 里的根目录会配置到此目录下。</p><h3 id="www-development-js"><a href="#www-development-js" class="headerlink" title="www/development.js"></a>www/development.js</h3><p>开发模式下项目的入口文件，可以根据项目需要进行修改。www/production.js 为线上的入口文件。</p><p>入口文件的代码类似如下，可以根据项目需要进行修改。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var thinkjs = require(&quot;thinkjs&quot;); var path = require(&quot;path&quot;); var rootPath = path.dirname(__dirname); var instance = new thinkjs(&#123;</span><br><span class="line">  APP_PATH: rootPath + &quot;/app&quot;,</span><br><span class="line">  ROOT_PATH: rootPath,</span><br><span class="line">  RESOURCE_PATH: __dirname,</span><br><span class="line">  env: &quot;development&quot; &#125;);</span><br><span class="line"></span><br><span class="line">instance.compile(&#123;retainLines: true, log: true&#125;);</span><br><span class="line"></span><br><span class="line">instance.run();</span><br></pre></td></tr></table></figure></p><h3 id="www-static"><a href="#www-static" class="headerlink" title="www/static"></a>www/static</h3><p>存放一些静态资源文件。</p>]]></content>
    
    <summary type="html">
    
      thinkjs项目目录解析
    
    </summary>
    
      <category term="node" scheme="http://yoursite.com/categories/node/"/>
    
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
      <category term="目录结构" scheme="http://yoursite.com/tags/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
    
      <category term="thinkjs" scheme="http://yoursite.com/tags/thinkjs/"/>
    
  </entry>
  
  <entry>
    <title>webpack1  到 webpack2的变化</title>
    <link href="http://yoursite.com/2019/07/13/packaging/webpack/webpack2/"/>
    <id>http://yoursite.com/2019/07/13/packaging/webpack/webpack2/</id>
    <published>2019-07-13T09:50:46.000Z</published>
    <updated>2019-07-13T09:50:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="webpack1-到-webpack2的变化"><a href="#webpack1-到-webpack2的变化" class="headerlink" title="webpack1  到 webpack2的变化"></a>webpack1  到 webpack2的变化</h1><h2 id="resolve-root-resolve-fallback-resolve-modulesDirectories"><a href="#resolve-root-resolve-fallback-resolve-modulesDirectories" class="headerlink" title="resolve.root, resolve.fallback, resolve.modulesDirectories"></a>resolve.root, resolve.fallback, resolve.modulesDirectories</h2><p>上述配置项被一个单独的配置项 resolve.modules 取代。详见 resolving。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  resolve: &#123;</span><br><span class="line">-   root: path.join(__dirname, &quot;src&quot;)</span><br><span class="line">+   modules: [</span><br><span class="line">+     path.join(__dirname, &quot;src&quot;),</span><br><span class="line">+     &quot;node_modules&quot;</span><br><span class="line">+   ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="resolve-extensions"><a href="#resolve-extensions" class="headerlink" title="resolve.extensions"></a>resolve.extensions</h2><p>此配置项不再需要传一个空字符串。此行为被迁移到 resolve.enforceExtension。详见 resolving。</p><h2 id="resolve"><a href="#resolve" class="headerlink" title="resolve.*"></a>resolve.*</h2><p>变化较大在我的webpack中resolve模块节查看</p><h2 id="module-loaders-改成了-module-rules"><a href="#module-loaders-改成了-module-rules" class="headerlink" title="module.loaders 改成了 module.rules"></a>module.loaders 改成了 module.rules</h2><p>旧的 loader 配置被更强大的 rules 系统取代，后者允许配置 loader 以及其他更多项。为了兼容旧版，module.loaders 语法被保留，旧的属性名依然可以被解析。新的命名约定更易于理解并且是升级配置使用 module.rules 的好理由。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> module: &#123;</span><br><span class="line">-   loaders: [</span><br><span class="line">+   rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.css$/,</span><br><span class="line">-       loaders: [</span><br><span class="line">+       use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &quot;style-loader&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &quot;css-loader&quot;,</span><br><span class="line">-           query: &#123;</span><br><span class="line">+           options: &#123;</span><br><span class="line">              modules: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.jsx$/,</span><br><span class="line">        loader: &quot;babel-loader&quot;, // Do not use &quot;use&quot; here</span><br><span class="line">        options: &#123;</span><br><span class="line">          // ...</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="链式-loaders"><a href="#链式-loaders" class="headerlink" title="链式 loaders"></a>链式 loaders</h2><p>与 v1 版本相同，loaders 可以链式调用，上一个 loader 的输出被作为输入传给下一个 loader。使用 rule.use 配置项，use 可以设置为一个 loaders 的列表。在 v1 版本中，loaders 通常被用 ! 连写。这一写法在新版中只在使用旧的 module.loaders 时有效。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  module: &#123;</span><br><span class="line">-   loaders: &#123;</span><br><span class="line">+   rules: [&#123;</span><br><span class="line">      test: /\.less$/,</span><br><span class="line">-     loader: &quot;style-loader!css-loader!less-loader&quot;</span><br><span class="line">+     use: [</span><br><span class="line">+       &quot;style-loader&quot;,</span><br><span class="line">+       &quot;css-loader&quot;,</span><br><span class="line">+       &quot;less-loader&quot;</span><br><span class="line">+     ]</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h2 id="取消了在模块名中自动添加-loader-后缀"><a href="#取消了在模块名中自动添加-loader-后缀" class="headerlink" title="取消了在模块名中自动添加 -loader 后缀"></a>取消了在模块名中自动添加 -loader 后缀</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        use: [</span><br><span class="line">-         &quot;style&quot;,</span><br><span class="line">+         &quot;style-loader&quot;,</span><br><span class="line">-         &quot;css&quot;,</span><br><span class="line">+         &quot;css-loader&quot;,</span><br><span class="line">-         &quot;less&quot;,</span><br><span class="line">+         &quot;less-loader&quot;,</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="json-loader-不再需要手动添加"><a href="#json-loader-不再需要手动添加" class="headerlink" title="json-loader 不再需要手动添加"></a>json-loader 不再需要手动添加</h2><p>如果没有为 JSON 文件配置 loader，webpack 将自动尝试通过 加载 json-loader JSON 文件。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">-     &#123;</span><br><span class="line">-       test: /\.json/,</span><br><span class="line">-       loader: &quot;json-loader&quot;</span><br><span class="line">-     &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h2 id="loader-默认的-resolve-配置是相对于-context-的"><a href="#loader-默认的-resolve-配置是相对于-context-的" class="headerlink" title="loader 默认的 resolve 配置是相对于 context 的"></a>loader 默认的 resolve 配置是相对于 context 的</h2><p>在 webpack 1 中，loader 默认配置下 resolve 相对于被匹配的文件。而在 webpack 2 中默认配置的 resolve 相对于 context 配置项。</p><p>这解决了一些问题，比如使用 npm link 或引用 context 之外的模块时导致重复载入。</p><p>你可以不再需要使用一些变通方案了：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        // ...</span><br><span class="line">-       loader: require.resolve(&quot;my-loader&quot;)</span><br><span class="line">+       loader: &quot;my-loader&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  resolveLoader: &#123;</span><br><span class="line">-   root: path.resolve(__dirname, &quot;node_modules&quot;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h2 id="取消了-module-preLoaders-以及-module-postLoaders"><a href="#取消了-module-preLoaders-以及-module-postLoaders" class="headerlink" title="取消了 module.preLoaders 以及 module.postLoaders"></a>取消了 module.preLoaders 以及 module.postLoaders</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> module: &#123;</span><br><span class="line">-   preLoaders: [</span><br><span class="line">+   rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.js$/,</span><br><span class="line">+       enforce: &quot;pre&quot;,</span><br><span class="line">        loader: &quot;eslint-loader&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="UglifyJsPlugin-sourceMap"><a href="#UglifyJsPlugin-sourceMap" class="headerlink" title="UglifyJsPlugin sourceMap"></a>UglifyJsPlugin sourceMap</h2><p>UglifyJsPlugin 的 sourceMap 配置项现在默认为 false 而不是 true。 这意味着如果你在压缩代码时启用了 source map，或者想要让 uglifyjs 的警告能够对应到正确的代码行，你需要将 UglifyJsPlugin 的 sourceMap 设为 true。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">devtool: &quot;source-map&quot;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new UglifyJsPlugin(&#123;</span><br><span class="line">+     sourceMap: true</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></p><h2 id="UglifyJsPlugin-warnings"><a href="#UglifyJsPlugin-warnings" class="headerlink" title="UglifyJsPlugin warnings"></a>UglifyJsPlugin warnings</h2><p>UglifyJsPlugin 的 compress.warnings 配置项现在默认为 false 而不是 true。 这意味着如果你想要看到 uglifyjs 的警告信息，你需要将 compress.warnings 设为 true。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  devtool: &quot;source-map&quot;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new UglifyJsPlugin(&#123;</span><br><span class="line">+     compress: &#123;</span><br><span class="line">+       warnings: true</span><br><span class="line">+     &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></p><h2 id="UglifyJsPlugin-压缩-loaders"><a href="#UglifyJsPlugin-压缩-loaders" class="headerlink" title="UglifyJsPlugin 压缩 loaders"></a>UglifyJsPlugin 压缩 loaders</h2><p>UglifyJsPlugin 不再压缩 loaders。在未来很长一段时间里，需要通过设置 minimize:true 来压缩 loaders。参考 loader 文档里的相关配置项。</p><p>loaders 的压缩模式将在 webpack 3 或更高的版本中被取消。</p><p>为了兼容旧的 loaders，loaders 可以通过插件来切换到压缩模式<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  plugins: [</span><br><span class="line">+   new webpack.LoaderOptionsPlugin(&#123;</span><br><span class="line">+     minimize: true</span><br><span class="line">+   &#125;)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></p><h2 id="DedupePlugin-被移除"><a href="#DedupePlugin-被移除" class="headerlink" title="DedupePlugin 被移除"></a>DedupePlugin 被移除</h2><p>不再需要 webpack.optimize.DedupePlugin。请从配置中移除。</p><h2 id="BannerPlugin-破坏性改动"><a href="#BannerPlugin-破坏性改动" class="headerlink" title="BannerPlugin - 破坏性改动"></a>BannerPlugin - 破坏性改动</h2><p>BannerPlugin 不在接受两个参数而是只接受单独的 options 对象。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> plugins: [</span><br><span class="line">-    new webpack.BannerPlugin(&apos;Banner&apos;, &#123;raw: true, entryOnly: true&#125;);</span><br><span class="line">+    new webpack.BannerPlugin(&#123;banner: &apos;Banner&apos;, raw: true, entryOnly: true&#125;);</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></p><h2 id="OccurrenceOrderPlugin-被默认加载"><a href="#OccurrenceOrderPlugin-被默认加载" class="headerlink" title="OccurrenceOrderPlugin 被默认加载"></a>OccurrenceOrderPlugin 被默认加载</h2><p>我们不再需要在配置里指定它：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> plugins: [</span><br><span class="line">-   new webpack.optimize.OccurrenceOrderPlugin()</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></p><h2 id="ExtractTextWebpackPlugin-大改变"><a href="#ExtractTextWebpackPlugin-大改变" class="headerlink" title="ExtractTextWebpackPlugin - 大改变"></a>ExtractTextWebpackPlugin - 大改变</h2><p>ExtractTextPlugin 1.0.0 不能在 webpack v2 下工作。 你需要明确地安装 ExtractTextPlugin v2。</p><p>npm install –save-dev extract-text-webpack-plugin@beta</p><p>这一插件的配置变化主要体现在语法上。<br>ExtractTextPlugin.extract<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: /.css$/,</span><br><span class="line">-      loader: ExtractTextPlugin.extract(&quot;style-loader&quot;, &quot;css-loader&quot;, &#123; publicPath: &quot;/dist&quot; &#125;)</span><br><span class="line">+      use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">+        fallback: &quot;style-loader&quot;,</span><br><span class="line">+        use: &quot;css-loader&quot;,</span><br><span class="line">+        publicPath: &quot;/dist&quot;</span><br><span class="line">+      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>new ExtractTextPlugin({options})<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">-  new ExtractTextPlugin(&quot;bundle.css&quot;, &#123; allChunks: true, disable: false &#125;)</span><br><span class="line">+  new ExtractTextPlugin(&#123;</span><br><span class="line">+    filename: &quot;bundle.css&quot;,</span><br><span class="line">+    disable: false,</span><br><span class="line">+    allChunks: true</span><br><span class="line">+  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h2 id="全动态-requires-现在默认会失败"><a href="#全动态-requires-现在默认会失败" class="headerlink" title="全动态 requires 现在默认会失败"></a>全动态 requires 现在默认会失败</h2><p>只有一个表达式的依赖（例如 require(expr)）将创建一个空的 context 而不是一个完整目录的 context。</p><p>如果有上面那样的代码，最好把它重构了，因为在 ES2015 模块下它不可以用。如果你确定不会有 ES2015 模块，你可以使用 ContextReplacementPlugin 来提示编译器进行正确的处理。</p><h2 id="在-CLI-和配置中使用自定义参数"><a href="#在-CLI-和配置中使用自定义参数" class="headerlink" title="在 CLI 和配置中使用自定义参数"></a>在 CLI 和配置中使用自定义参数</h2><p>如果你之前滥用 CLI 来传自定义参数到配置中，比如：</p><p>webpack –custom-stuff</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// webpack.config.js</span><br><span class="line">var customStuff = process.argv.indexOf(&quot;--custom-stuff&quot;) &gt;= 0;</span><br><span class="line">/* ... */</span><br><span class="line">module.exports = config;</span><br></pre></td></tr></table></figure><p>你将会发现新版中不再允许这么做。CLI 现在更加严格了。</p><p>替代地，现在提供了一个接口来传递参数给配置。我们应该采用这种新方式，在未来许多工具将可能依赖它。</p><p>webpack –env.customStuff<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function(env) &#123;</span><br><span class="line">  var customStuff = env.customStuff;</span><br><span class="line">  /* ... */</span><br><span class="line">  return config;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="require-ensure-以及-AMD-require-的异步"><a href="#require-ensure-以及-AMD-require-的异步" class="headerlink" title="require.ensure 以及 AMD require 的异步"></a>require.ensure 以及 AMD require 的异步</h2><p>现在这些函数总是异步的，而不是当 chunk 已经加载过的时候同步调用它们的 callback。</p><p>注意 require.ensure 现在依赖于原生的 Promise。如果在不支持 Promise 的环境里使用 require.ensure，你需要添加 polyfill。</p><h2 id="通过-options-配置-loader"><a href="#通过-options-配置-loader" class="headerlink" title="通过 options 配置 loader"></a>通过 options 配置 loader</h2><p>你不能再通过 webpack.config.js 的自定义属性来配置 loader。只能通过 options 来配置。下面配置的 ts 属性在 webpack 2 下不再有效：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: /\.tsx?$/,</span><br><span class="line">      loader: &apos;ts-loader&apos;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  // does not work with webpack 2</span><br><span class="line">  ts: &#123; transpileOnly: false &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>什么是 options?</p><p>好问题。严格来说，有两种办法，都可以用来配置 webpack 的 loader。典型的 options 被称为 query，是一个可以被添加到 loader 名之后的字符串。它比较像一个 query string，但是实际上有更强大的能力：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: /\.tsx?$/,</span><br><span class="line">      loader: &apos;ts-loader?&apos; + JSON.stringify(&#123; transpileOnly: false &#125;)</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不过它也可以分开来，写成一个单独的对象，紧跟在 loader 属性后面：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: /\.tsx?$/,</span><br><span class="line">      loader: &apos;ts-loader&apos;,</span><br><span class="line">      options:  &#123; transpileOnly: false &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="LoaderOptionsPlugin-context"><a href="#LoaderOptionsPlugin-context" class="headerlink" title="LoaderOptionsPlugin context"></a>LoaderOptionsPlugin context</h2><p>有的 loader 需要从配置中读取一些 context 信息。在未来很长一段时间里，这将需要通过 loader options 传入。详见 loader 文档的相关选项。</p><p>为了保持对旧 loaders 的兼容，这些信息可以通过插件传进来：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  plugins: [</span><br><span class="line">+   new webpack.LoaderOptionsPlugin(&#123;</span><br><span class="line">+     options: &#123;</span><br><span class="line">+       context: __dirname</span><br><span class="line">+     &#125;</span><br><span class="line">+   &#125;)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></p><h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h2><p>在 webpack 1 中 debug 配置项切换 loaders 到 debug 模式。在未来很长一段时间里，这将需要通过 loader 配置项传递。详见 loader 文档的相关选项。</p><p>loaders 的 debug 模式将在 webpack 3 或后续版本中取消。</p><p>为了保持对旧 loaders 的兼容，loader 可以通过插件来切换到 debug 模式：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- debug: true,</span><br><span class="line">  plugins: [</span><br><span class="line">+   new webpack.LoaderOptionsPlugin(&#123;</span><br><span class="line">+     debug: true</span><br><span class="line">+   &#125;)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></p><h2 id="ES2015-的代码分割"><a href="#ES2015-的代码分割" class="headerlink" title="ES2015 的代码分割"></a>ES2015 的代码分割</h2><p>在 webpack v1 中，你能使用 require.ensure 作为方法来懒加载 chunks 到你的应用中：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require.ensure([], function(require) &#123;</span><br><span class="line">  var foo = require(&quot;./module&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>ES2015 模块加载规范定义了 import() 方法来运行时动态地加载 ES2015 模块。</p><p>webpack 将 import() 作为分割点并将被请求的模块放到一个单独的 chunk 中。</p><p>import() 接收模块名作为参数，并返回一个 Promise。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function onClick() &#123;</span><br><span class="line">  import(&quot;./module&quot;).then(module =&gt; &#123;</span><br><span class="line">    return module.default;</span><br><span class="line">  &#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(&quot;Chunk loading failed&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好消息是：如果加载 chunk 失败，我们可以进行处理，因为现在它基于 Promise。</p><p>警告：require.ensure 允许用可选的第三个参数为 chunk 简单命名，但是 import API 还未提供这个能力。如果你想要保留这个功能，你可以继续使用 require.ensure。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require.ensure([], function(require) &#123;</span><br><span class="line">  var foo = require(&quot;./module&quot;);</span><br><span class="line">&#125;, &quot;custom-chunk-name&quot;);</span><br></pre></td></tr></table></figure></p><p>（注意废弃的 System.import：webpack 对 System.import 的使用不符合新提出的标准，所以它在 v2.1.0-beta.28 版本中被废弃，转向支持 import()）</p><p>由于这个建议还在 Stage 3，如果你想要同时使用 import 和 Babel，你需要安装/添加 dynamic-import 语法插件来绕过解析错误。当建议被添加到规范之后，就不再需要这个语法插件了。</p><h2 id="动态表达式"><a href="#动态表达式" class="headerlink" title="动态表达式"></a>动态表达式</h2><p>可以传递部分表达式给 import()。这与 CommonJS 对表达式的处理方式一致（webpack 为所有可能匹配的文件创建 context）。</p><p>import() 为每一个可能的模块创建独立的 chunk。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function route(path, query) &#123;</span><br><span class="line">  return import(`./routes/$&#123;path&#125;/route`)</span><br><span class="line">    .then(route =&gt; new route.Route(query));</span><br><span class="line">&#125;</span><br><span class="line">// 上面代码为每个可能的路由创建独立的 chunk</span><br></pre></td></tr></table></figure></p><h2 id="混合使用-ES2015、AMD-和-CommonJS"><a href="#混合使用-ES2015、AMD-和-CommonJS" class="headerlink" title="混合使用 ES2015、AMD 和 CommonJS"></a>混合使用 ES2015、AMD 和 CommonJS</h2><p>你可以自由混合使用三种模块类型（甚至在同一个文件中）。在这个情况中 webpack 的行为和 babel 以及 node-eps 一致：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// CommonJS consuming ES2015 Module</span><br><span class="line">var book = require(&quot;./book&quot;);</span><br><span class="line"></span><br><span class="line">book.currentPage;</span><br><span class="line">book.readPage();</span><br><span class="line">book.default === &quot;This is a book&quot;;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// ES2015 Module consuming CommonJS</span><br><span class="line">import fs from &quot;fs&quot;; // module.exports map to default</span><br><span class="line">import &#123; readFileSync &#125; from &quot;fs&quot;; // named exports are read from returned object+</span><br><span class="line"></span><br><span class="line">typeof fs.readFileSync === &quot;function&quot;;</span><br><span class="line">typeof readFileSync === &quot;function&quot;;</span><br></pre></td></tr></table></figure><p>需要注意的是，您需要告诉Babel不要解析这些模块符号，这样webpack就可以使用它们。您可以通过在您的程序中设置以下内容来实现这一点。babelrc或babel-loader选项。</p><h3 id="babelrc"><a href="#babelrc" class="headerlink" title=".babelrc"></a>.babelrc</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    [&quot;es2015&quot;, &#123; &quot;modules&quot;: false &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>webpack 现在支持表达式中的模板字符串了。这意味着你可以在 webpack 构建中使用它们：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- require(&quot;./templates/&quot; + name);</span><br><span class="line">+ require(`./templates/$&#123;name&#125;`);</span><br></pre></td></tr></table></figure></p><h2 id="配置中使用-Promise"><a href="#配置中使用-Promise" class="headerlink" title="配置中使用 Promise"></a>配置中使用 Promise</h2><p>webpack 现在支持在配置文件中返回 Promise 了。这让你能在配置文件中做异步处理。</p><p>webpack.config.js<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function() &#123;</span><br><span class="line">  return fetchLangs().then(lang =&gt; (&#123;</span><br><span class="line">    entry: &quot;...&quot;,</span><br><span class="line">    // ...</span><br><span class="line">    plugins: [</span><br><span class="line">      new DefinePlugin(&#123; LANGUAGE: lang &#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="高级-loader-匹配"><a href="#高级-loader-匹配" class="headerlink" title="高级 loader 匹配"></a>高级 loader 匹配</h2><p>webpack 现在支持对 loader 进行更多方式的匹配。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      resource: /filename/, // matches &quot;/path/filename.js&quot;</span><br><span class="line">      resourceQuery: /querystring/, // matches &quot;/filename.js?querystring&quot;</span><br><span class="line">      issuer: /filename/, // matches &quot;/path/something.js&quot; if requested from &quot;/path/filename.js&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更多的-CLI-参数项"><a href="#更多的-CLI-参数项" class="headerlink" title="更多的 CLI 参数项"></a>更多的 CLI 参数项</h2><p>你可以使用一些新的 CLI 参数项：</p><p>–define process.env.NODE_ENV=”production” 见 DefinePlugin。</p><p>–display-depth 显示每个模块到入口的距离。</p><p>–display-used-exports 显示一个模块中被使用的 exports 信息。</p><p>–display-max-modules 设置输出时显示的模块数量（默认是 15）。</p><p>-p 能够定义 process.env.NODE_ENV 为 “production”。</p><h2 id="Cacheable"><a href="#Cacheable" class="headerlink" title="Cacheable"></a>Cacheable</h2><p>Loaders 现在默认可被缓存。Loaders 如果不想被缓存，需要选择不被缓存。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> // Cacheable loader</span><br><span class="line">  module.exports = function(source) &#123;</span><br><span class="line">-   this.cacheable();</span><br><span class="line">    return source;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> // Not cacheable loader</span><br><span class="line">  module.exports = function(source) &#123;</span><br><span class="line">+   this.cacheable(false);</span><br><span class="line">    return source;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="复合-options"><a href="#复合-options" class="headerlink" title="复合 options"></a>复合 options</h2><p>webpack 1 只支持能够 JSON.stringify 的对象作为配置项。webpack 2 现在支持任意 JS 对象作为 loader 配置项。</p><p>使用复合 options 只有一个附加条件。你需要在 options 对象上添加一个 ident，让它能够被其他 loader 引用。</p><p>options 对象上有了 ident ，内联的 loader 就可以引用这个 options 对象。下面是个例子：</p><p>require(“some-loader??by-ident!resource”)<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: /.../,</span><br><span class="line">  loader: &quot;...&quot;,</span><br><span class="line">  options: &#123;</span><br><span class="line">    ident: &quot;by-ident&quot;,</span><br><span class="line">    magic: () =&gt; return Math.random()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种内联风格在常规的代码里一般用不着，但是在 loader 生成的代码里比较常见。比如，style-loader 生成一个模块，通过 require 加载其余的请求（它们输出 CSS）。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// style-loader generated code (simplified)</span><br><span class="line">var addStyle = require(&quot;./add-style&quot;);</span><br><span class="line">var css = require(&quot;-!css-loader?&#123;&quot;modules&quot;:true&#125;!postcss-loader??postcss-ident&quot;);</span><br><span class="line"></span><br><span class="line">addStyle(css);</span><br></pre></td></tr></table></figure></p><p>所以如果你使用复合 options，告诉你的用户你使用的 ident。</p>]]></content>
    
    <summary type="html">
    
      webpack从一到二版本的修改变化相对较大
    
    </summary>
    
      <category term="webpack" scheme="http://yoursite.com/categories/webpack/"/>
    
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
      <category term="packaging" scheme="http://yoursite.com/tags/packaging/"/>
    
      <category term="webpack2.x的变化" scheme="http://yoursite.com/tags/webpack2-x%E7%9A%84%E5%8F%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>浏览器缓存</title>
    <link href="http://yoursite.com/2019/07/13/packaging/webpack/cache/"/>
    <id>http://yoursite.com/2019/07/13/packaging/webpack/cache/</id>
    <published>2019-07-13T09:50:46.000Z</published>
    <updated>2019-07-13T09:50:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浏览器缓存的分类"><a href="#浏览器缓存的分类" class="headerlink" title="浏览器缓存的分类"></a>浏览器缓存的分类</h2><p>浏览器缓存分为两种类型：</p><p>强缓存：也称为本地缓存，不向服务器发送请求，直接使用客户端本地缓存数据</p><p>协商缓存：也称304缓存，向服务器发送请求，由服务器判断请求文件是否发生改变。如果未发生改变，则返回304状态码，通知客户端直接使用本地缓存；如果发生改变，则直接返回请求文件。</p><p>浏览器缓存机制的过程如下：<br><img src="./flow.png" alt="缓存机制"></p><h2 id="强缓存-本地缓存"><a href="#强缓存-本地缓存" class="headerlink" title="强缓存(本地缓存)"></a>强缓存(本地缓存)</h2><p>强缓存是最彻底的缓存，无需向服务器发送请求，通常用于css、js、图片等静态资源。浏览器发送请求后会先判断本地是否有缓存。如果无缓存，则直接向服务器发送请求；如果有缓存，则判断缓存是否命中强缓存，如果命中则直接使用本地缓存，如果没命中则向服务器发送请求。判断是否命中本地缓存的方法有两种：Expires和Cache-Control。</p><h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p>Expires是http1.0的响应头，代表的含义是资源本地缓存的过期时间，由服务器设定。服务器返回给浏览器的响应头中如果包含Expires字段，浏览器发送请求时拿当前时间和Expires字段值进行比较，判断资源缓存是否失效。如下图所示：</p><p><img src="./expires.png" alt="Expires"></p><p>Date代表请求资源的时间，Expires代表资源缓存的过期时间，可以看到服务器设置资源的缓存时间为5分钟。2017-02-10 07:53:19之前，请求这个资源就是命中本地缓存。超过这个时间再去请求则不命中。</p><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>Cache-Control是http1.0中新增的字段。由于Expires设置的是资源的具体过期时间，如果服务器时间和客户端时间不一样，就会造成缓存错乱，比如认为调节了客户端的时间，所以设置资源有效期的时长更合理。http1.1添加了Cache-Control的max-age字段。max-age代表的含义是资源有效期的时长，是一个相对时长，单位为s。</p><p><img src="./cache-Control.png" alt="Cache-Control"></p><p>Cache-Control: max-age = 300设置资源的过期时间为5分钟。浏览器再次发送请求时，会把第一次请求的时间和max-age字段值相加和当前时间比较，以此判断是否命中本地缓存。max-age使用的都是客户端时间，比Expires更可靠。如果max-age和Expires同时出现，max-age的优先级更高。Cache-Control提供了更多的字段来控制缓存：</p><ul><li>no-store,不判断强缓存和协商缓存，服务器直接返回完整资源</li><li>no-cache,不判断强缓存，每次都需要向浏览器发送请求，进行协商缓存判断</li><li>public,指示响应可被任何缓存区缓存</li><li>private,通常只为单个用户缓存，不允许任何共享缓存对其进行缓存,通常用于用户个人信息</li></ul><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>协商缓存的判断在服务器端进行，判断是否命中的依据就是这次请求和上次请求之间资源是否发生改变。未发生改变命中，发生改变则未命中。判断文件是否发生改变的方法有两个：Last-Modified、If-Modified-Since和Etag、If-None-Match。</p><h3 id="Last-Modified、If-Modified-Since"><a href="#Last-Modified、If-Modified-Since" class="headerlink" title="Last-Modified、If-Modified-Since"></a>Last-Modified、If-Modified-Since</h3><p>Last-Modified是http1.0中的响应头字段，代表请求的资源最后一次的改变时间。If-Modified-Since是http1.0的请求头，If-Modified-Since的值是上次请求服务器返回的Last-Modified的值。浏览器第一次请求资源时，服务器返回Last-Modified,浏览器缓存该值。浏览器第二次请求资源时，用于缓存的Last-Modified赋值给If-Modified-Since，发送给服务器。服务器判断If-Modified-Since和服务器本地的Last-Modified是否相等。如果相等，说明资源未发生改变，命中协商缓存；如果不相等，说明资源发生改变，未命中协商缓存。</p><p><img src="./last.png" alt="Last-Modified"></p><p>可以看到该请求返回的是304状态码，说明资源的Last-Modified未改变，所以这次请求的Last-Modified和If-Modified-Since是一致的。</p><h3 id="Etag、If-None-Match"><a href="#Etag、If-None-Match" class="headerlink" title="Etag、If-None-Match"></a>Etag、If-None-Match</h3><p>Last-Modified、If-Modified-Since使用的都是服务器提供的时间，所以相对来说还是很可靠的。但是由于修改时间的精确级别或者定期生成文件这种情况，会造成一定的错误。所以http1.1添加Etag、If-None-Match字段，完善协商缓存的判断。Etag是根据资源文件内容生成的资源唯一标识符，一旦资源内容发生改变，Etag就会发生改变。基于内容的标识符比基于修改时间的更可靠。If-None-Match的值是上次请求服务器返回的Etag的值。Etag、If-None-Match的判断过程和Last-Modified、If-Modified-Since一致，Etag、If-None-Match的优先级更高。</p><h2 id="工程中遇到的问题"><a href="#工程中遇到的问题" class="headerlink" title="工程中遇到的问题"></a>工程中遇到的问题</h2><p>强缓存的优势很明显，无需向服务器发送请求，节省了大量的时间和带宽。但是有一个问题，缓存有效期内想更新资源怎么办？我在工程中还遇到另外一个问题，一个项目有四个环境，测试环境、开发环境、在线确认环境、在线环境，四个环境的域名相同，这样就会造成四个环境的缓存共用问题。比如先访问了测试环境，index.js被换成到浏览器中，再切换到在线环境，在线环境会请求index.js,此时浏览器就会使用本地缓存中测试环境的index.js,造成代码错乱。</p><p>如何使强缓存失效，是问题的关键。通常的解决方法是更新文件名，文件名不一样的话，浏览器就会重新请求资源。我们要保证新发布版本和不同环境中的文件名是不一样的。其中一种方法在文件名后加版本号：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">index.js?version=1</span><br><span class="line">index.css?version=1</span><br></pre></td></tr></table></figure><p>webpack提供了很简单的方法可以配置缓存。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &quot;main.js&quot;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: &quot;/build&quot;,</span><br><span class="line">    filename: &quot;main.[hash].js&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>通过hash占位符，在每次生成打包文件时，都会通过文件内容生成唯一的hash，并添加到输出的文件名中。如果有多个入口文件，可以使用name占位符设置输出：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">      main:&quot;main.js&quot;,</span><br><span class="line">      sub:&quot;sub.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: &quot;/dist&quot;,</span><br><span class="line">    filename: &quot;[name].[hash].js&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这时候有一个问题是，此时的hash是根据两个文件的内容来生成的，两个文件名使用的hash是一致的。如果main.js和sub.js只有一个改变，两个文件名都会改变，两个文件都会重新请求，造成资源浪费。webpack提供了chunkhash来代替hash在多入口情况下使用。chunkhash是根据每个入口文件单独生成的哈希值，避免上述情况。</p><p>webpack打包动态生成文件名，我们需要动态地把文件引用插入到html启动文件中。html-webpack-plugin可以帮我很好地解决这个问题。html-webpack-plugin可以动态地生成一个html文件，并在html文件中动态插入webpack打包生成的资源文件。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line">var webpackConfig = &#123;</span><br><span class="line">  entry: &apos;main.js&apos;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: &apos;/dist&apos;,</span><br><span class="line">    publicPath: &apos;/dist&apos;,</span><br><span class="line">    filename: &apos;main.[hash].js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [new HtmlWebpackPlugin()]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>默认在webpackConfig.output.path路径下生成index.html,生成的html文件如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Webpack App&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;script src=&quot;main.2a6c1fee4b5b0d2c9285.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>通常html启动文件都有自定义的内容，所以html-webpack-plugin提供了模板功能，template字段设置模板的路径，html-webpack-plugin以template为模板，动态添加webpack打包生成的资源路径。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line">var webpackConfig = &#123;</span><br><span class="line">  entry: &apos;main.js&apos;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: &apos;/dist&apos;,</span><br><span class="line">    publicPath: &apos;/dist&apos;,</span><br><span class="line">    filename: &apos;main.[hash].js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [new HtmlWebpackPlugin(</span><br><span class="line">      &#123;</span><br><span class="line">          template:&apos;index.html&apos;</span><br><span class="line">      &#125;</span><br><span class="line">  )]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>生成的index.html内容（\dist\index.html）:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;stat-front&lt;/title&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;//at.alicdn.com/t/font_ejl5slgdvtg74x6r.css&quot;&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot; class=&quot;app-root&quot;&gt;</span><br><span class="line">        &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;!-- built files will be auto injected --&gt;</span><br><span class="line">    &lt;script src=&quot;main.2a6c1fee4b5b0d2c9285.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>最开始的时候静态的index.html在根目录下，webpack-dev-server设置的启动路径就是根目录下的index.html,如果要启动生成的index.html，还需要设置webpackConfig.output.publicPath：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line">var webpackConfig = &#123;</span><br><span class="line">  entry: &apos;main.js&apos;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: &apos;/dist&apos;,</span><br><span class="line">    publicPath: &apos;/&apos;,</span><br><span class="line">    filename: &apos;main.[hash].js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [new HtmlWebpackPlugin(</span><br><span class="line">      &#123;</span><br><span class="line">          template:&apos;index.html&apos;</span><br><span class="line">      &#125;</span><br><span class="line">  )]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样webpack-dev-server在内存中生成的资源都存放在根目录下，生成的index.html会代替原index.html启动。</p><h3 id="进阶内容："><a href="#进阶内容：" class="headerlink" title="进阶内容："></a>进阶内容：</h3><p><a href="https://doc.webpack-china.org/guides/caching/" target="_blank" rel="noopener">webpack缓存</a></p>]]></content>
    
    <summary type="html">
    
      缓存在实际的开发中既能提高网页的加速度又能减少流量消耗，但是在项目上线的时候，总会有一些奇葩的问题是浏览器缓存造成的有时候会花费很长时间却没找的问题，最后呢却是因为浏览器缓存造成代码没有更新。今天就深入了解一下浏览器的缓存问题，并探讨缓存的合理使用
    
    </summary>
    
      <category term="webpack" scheme="http://yoursite.com/categories/webpack/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
      <category term="packaging" scheme="http://yoursite.com/tags/packaging/"/>
    
      <category term="开发经验" scheme="http://yoursite.com/tags/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="cache" scheme="http://yoursite.com/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>mac终端配置sublime和vsCode的快捷方式</title>
    <link href="http://yoursite.com/2019/07/13/IDE/mac-path/"/>
    <id>http://yoursite.com/2019/07/13/IDE/mac-path/</id>
    <published>2019-07-13T09:50:46.000Z</published>
    <updated>2019-07-13T09:50:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mac终端配置sublime和vsCode的快捷方式"><a href="#mac终端配置sublime和vsCode的快捷方式" class="headerlink" title="mac终端配置sublime和vsCode的快捷方式"></a>mac终端配置sublime和vsCode的快捷方式</h1><h2 id="vsCode的终端命令配置"><a href="#vsCode的终端命令配置" class="headerlink" title="vsCode的终端命令配置"></a>vsCode的终端命令配置</h2><h3 id="mac端配置"><a href="#mac端配置" class="headerlink" title="mac端配置"></a>mac端配置</h3><blockquote><p>vsCode的终端命令配置较为简单，运行VS code并打开命令面板（ ⇧⌘P ），然后输入 shell command 找到: Install ‘code’ command in PATH 就行了。<br>code命令还支持其他参数，具体看<img src="http://www.jianshu.com/p/3dda4756eca5" alt="这里"></p></blockquote><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//配好后的使用方法(打开当前路径)</span><br><span class="line">code .</span><br></pre></td></tr></table></figure><h2 id="sublime的终端配置"><a href="#sublime的终端配置" class="headerlink" title="sublime的终端配置"></a>sublime的终端配置</h2><h3 id="mac端配置-1"><a href="#mac端配置-1" class="headerlink" title="mac端配置"></a>mac端配置</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 1. 打开终端</span><br><span class="line">cd ~</span><br><span class="line"></span><br><span class="line">ls -la</span><br><span class="line">//找打.zshrc文件如果安装过atom 就输入 atom .zshrc 如果有 vim 就输入 vim .zshrc这里我用vim</span><br><span class="line"></span><br><span class="line">vim .zshrc</span><br><span class="line"></span><br><span class="line">//到 atom 中</span><br></pre></td></tr></table></figure><p>//把下面内容粘贴到最后</p><p>alias subl=”‘/Applications/Sublime.app/Contents/SharedSupport/bin/subl’”<br>alias nano=”subl”<br>export EDITOR=”subl”</p><p>上面的第一行里是自己sublime的在、安装路径一般只有 Sublime.app 不一样</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//配好后的使用方法(打开当前路径)记得重启终端</span><br><span class="line">subl .</span><br></pre></td></tr></table></figure><p>因为 atom 在这两款中显得较为鸡肋就不做介绍</p>]]></content>
    
    <summary type="html">
    
      mac终端配置sublime和vsCode的快捷方式
    
    </summary>
    
      <category term="辅助工具" scheme="http://yoursite.com/categories/%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="辅助工具" scheme="http://yoursite.com/tags/%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/"/>
    
      <category term="mac" scheme="http://yoursite.com/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>babel-stage-x</title>
    <link href="http://yoursite.com/2019/07/13/packaging/webpack/babel-stage/"/>
    <id>http://yoursite.com/2019/07/13/packaging/webpack/babel-stage/</id>
    <published>2019-07-13T09:50:46.000Z</published>
    <updated>2019-07-13T09:50:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="babel-stage"><a href="#babel-stage" class="headerlink" title="babel-stage"></a>babel-stage</h1><blockquote><p>关于stage-x第一次遇见是在第一次搭建react项目时，项目搭建完成后在里边写箭头函数时报错,但当时没有深究只是在网上查找了一个方案说在loader里添加一个stage-0就能解决但是但是没有总结，后来babel升级遇到几次.babelrc的代码报错一直没有找到原因，后来总算知道原来是缺少插件</p></blockquote><h2 id="如何区分Babel中的stage-0-stage-1-stage-2以及stage-3"><a href="#如何区分Babel中的stage-0-stage-1-stage-2以及stage-3" class="headerlink" title="如何区分Babel中的stage-0,stage-1,stage-2以及stage-3"></a>如何区分Babel中的stage-0,stage-1,stage-2以及stage-3</h2><h4 id="大家知道，将ES6代码编译为ES5时，我们常用到Babel这个编译工具。大家参考一些网上的文章或者官方文档，里面常会建议大家在-babelrc中输入如下代码："><a href="#大家知道，将ES6代码编译为ES5时，我们常用到Babel这个编译工具。大家参考一些网上的文章或者官方文档，里面常会建议大家在-babelrc中输入如下代码：" class="headerlink" title="大家知道，将ES6代码编译为ES5时，我们常用到Babel这个编译工具。大家参考一些网上的文章或者官方文档，里面常会建议大家在.babelrc中输入如下代码："></a>大家知道，将ES6代码编译为ES5时，我们常用到Babel这个编译工具。大家参考一些网上的文章或者官方文档，里面常会建议大家在.babelrc中输入如下代码：</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;: [</span><br><span class="line">      &quot;es2015&quot;,</span><br><span class="line">      &quot;react&quot;,</span><br><span class="line">      &quot;stage-0&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;plugins&quot;: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在来说明下这个配置文件是什么意思。首先，这个配置文件是针对babel 6的。Babel 6做了一系列模块化，不像Babel 5一样把所有的内容都加载。比如需要编译ES6，我们需要设置presets为”es2015”，也就是预先加载es6编译的相关模块，如果需要编译jsx，需要预先加载”react”这个模块。那问题来了，这个”stage-0”又代表什么呢？ 有了”react-0”，是否又有诸如”stage-1”, “stage-2”等等呢？<br>事实上， ”stage-0”是对ES7一些提案的支持，Babel通过插件的方式引入，让Babel可以编译ES7代码。当然由于ES7没有定下来，所以这些功能随时肯能被废弃掉的。现在我们来一一分析里面都有什么。</p><h2 id="法力无边的stage-0"><a href="#法力无边的stage-0" class="headerlink" title="法力无边的stage-0"></a>法力无边的stage-0</h2><p>为什么说“stage-0” 法力无边呢，因为它包含stage-1, stage-2以及stage-3的所有功能，同时还另外支持如下两个功能插件：</p><p><img src="https://babeljs.io/docs/plugins/transform-do-expressions" alt="* transform-do-expressions"><br><img src="https://babeljs.io/docs/plugins/transform-function-bind" alt="* transform-function-bind"></p><p>用过React的同学可能知道，jsx对条件表达式支持的不是太好，你不能很方便的使用if/else表达式，要么你使用三元表达，要么用函数。例如你不能写如下的代码：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var App = React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">        let &#123; color &#125; = this.props;</span><br><span class="line"></span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&quot;parents&quot;&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    if(color == &apos;blue&apos;) &#123;</span><br><span class="line">                        &lt;BlueComponent/&gt;;</span><br><span class="line">                    &#125;else if(color == &apos;red&apos;) &#123;</span><br><span class="line">                        &lt;RedComponent/&gt;;</span><br><span class="line">                    &#125;else &#123;</span><br><span class="line">                        &lt;GreenComponent/&gt;; &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在React中你只能写成这样：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var App = React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">        let &#123; color &#125; = this.props;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        const getColoredComponent = color =&gt; &#123;</span><br><span class="line">            if(color === &apos;blue&apos;) &#123; return &lt;BlueComponent/&gt;; &#125;</span><br><span class="line">            if(color === &apos;red&apos;) &#123; return &lt;RedComponent/&gt;; &#125;</span><br><span class="line">            if(color === &apos;green&apos;) &#123; return &lt;GreenComponent/&gt;; &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&quot;parents&quot;&gt;</span><br><span class="line">                &#123; getColoredComponent(color) &#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>transform-do-expressions 这个插件就是为了方便在 jsx写if/else表达式而提出的，我们可以重写下代码。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var App = React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">        let &#123; color &#125; = this.props;</span><br><span class="line"></span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&quot;parents&quot;&gt;</span><br><span class="line">                &#123;do &#123;</span><br><span class="line">                    if(color == &apos;blue&apos;) &#123;</span><br><span class="line">                        &lt;BlueComponent/&gt;;</span><br><span class="line">                    &#125;else if(color == &apos;red&apos;) &#123;</span><br><span class="line">                        &lt;RedComponent/&gt;;</span><br><span class="line">                    &#125;else &#123;</span><br><span class="line">                        &lt;GreenComponent/&gt;; &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>再说说 transform-function-bind, 这个插件其实就是提供过 :: 这个操作符来方便快速切换上下文， 如下面的代码：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">obj::func</span><br><span class="line">// is equivalent to:</span><br><span class="line">func.bind(obj)</span><br><span class="line"></span><br><span class="line">obj::func(val)</span><br><span class="line">// is equivalent to:</span><br><span class="line">func.call(obj, val)</span><br><span class="line"></span><br><span class="line">::obj.func(val)</span><br><span class="line">// is equivalent to:</span><br><span class="line">func.call(obj, val)</span><br><span class="line"></span><br><span class="line">// 再来一个复杂点的样例</span><br><span class="line"></span><br><span class="line">const box = &#123;</span><br><span class="line">  weight: 2,</span><br><span class="line">  getWeight() &#123; return this.weight; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const &#123; getWeight &#125; = box;</span><br><span class="line"></span><br><span class="line">console.log(box.getWeight()); // prints &apos;2&apos;</span><br><span class="line"></span><br><span class="line">const bigBox = &#123; weight: 10 &#125;;</span><br><span class="line">console.log(bigBox::getWeight()); // prints &apos;10&apos;</span><br><span class="line"></span><br><span class="line">// Can be chained:</span><br><span class="line">function add(val) &#123; return this + val; &#125;</span><br><span class="line"></span><br><span class="line">console.log(bigBox::getWeight()::add(5)); // prints &apos;15&apos;</span><br></pre></td></tr></table></figure><p>如果想更屌点，还可以写出更牛逼的代码：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const &#123; map, filter &#125; = Array.prototype;</span><br><span class="line"></span><br><span class="line">let sslUrls = document.querySelectorAll(&apos;a&apos;)</span><br><span class="line">                ::map(node =&gt; node.href)</span><br><span class="line">                ::filter(href =&gt; href.substring(0, 5) === &apos;https&apos;);</span><br><span class="line"></span><br><span class="line">console.log(sslUrls);</span><br></pre></td></tr></table></figure><h2 id="包罗万象的stage-1"><a href="#包罗万象的stage-1" class="headerlink" title="包罗万象的stage-1"></a>包罗万象的stage-1</h2><p>stage-1除了包含stage-2和stage-3，还包含了下面4个插件：</p><p><img src="http://babeljs.io/docs/plugins/transform-class-constructor-call" alt="* transform-class-constructor-call (Deprecated)"><br><img src="http://babeljs.io/docs/plugins/transform-class-properties" alt="* transform-class-properties"><br><img src="http://babeljs.io/docs/plugins/transform-export-extensions" alt="* transform-export-extensions"></p><h2 id="深藏不露的stage-2"><a href="#深藏不露的stage-2" class="headerlink" title="深藏不露的stage-2"></a>深藏不露的stage-2</h2><p>为什么说 stage-2深藏不露呢，因为它很低调，低调到你可以忽略它，但事实上，它很有内涵的。它除了覆盖stage-3的所有功能，还支持如下两个插件：</p><p><img src="http://babeljs.io/docs/plugins/syntax-trailing-function-commas/" alt="* syntax-trailing-function-commas"><br><img src="http://babeljs.io/docs/plugins/transform-object-rest-spread" alt="* ransform-object-reset-spread"></p><h3 id="syntax-trailing-function-commas"><a href="#syntax-trailing-function-commas" class="headerlink" title="syntax-trailing-function-commas"></a>syntax-trailing-function-commas</h3><p>这个插件让人一看觉得挺没趣的，让人甚至觉得它有点鸡肋。因它不是对ES6功能的增加，而是为了增强代码的可读性和可修改性而提出的。如下面的代码所示：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 假设有如下的一个函数，它有两个参数</span><br><span class="line">function clownPuppiesEverywhere(</span><br><span class="line">  param1,</span><br><span class="line">  param2</span><br><span class="line">) &#123; /* ... */ &#125;</span><br><span class="line"></span><br><span class="line">clownPuppiesEverywhere(</span><br><span class="line">  &apos;foo&apos;,</span><br><span class="line">  &apos;bar&apos;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 有一天，它需要变成3个参数，你需要这样修改</span><br><span class="line">function clownPuppiesEverywhere(</span><br><span class="line">  param1,</span><br><span class="line">- param2</span><br><span class="line">+ param2, // 这一行得加一个逗号</span><br><span class="line">+ param3  // 增加参数param3</span><br><span class="line">) &#123; /* ... */ &#125;</span><br><span class="line"></span><br><span class="line">clownPuppiesEverywhere(</span><br><span class="line">  &apos;foo&apos;,</span><br><span class="line">- &apos;bar&apos;</span><br><span class="line">+ &apos;bar&apos;, // 这里的修改为逗号</span><br><span class="line">+ &apos;baz&apos;  // 增加新的参数</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 看到没？ 我们修改了4行代码。。啊啊。修改了4行代码。</span><br></pre></td></tr></table></figure><p>修改了4行代码，嗯嗯嗯。。追求高效的程序猿想想了，以后如果有更多参数了，我是不是要改等多行，得想想，代码改的越少越好，于是有了下面的改动。。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 我们来重新定义一下函数</span><br><span class="line">function clownPuppiesEverywhere(</span><br><span class="line">  param1,</span><br><span class="line">  param2, // 注意这里，我们加了一个逗号哟</span><br><span class="line">) &#123; /* ... */ &#125;</span><br><span class="line"></span><br><span class="line">clownPuppiesEverywhere(</span><br><span class="line">  &apos;foo&apos;,</span><br><span class="line">  &apos;bar&apos;, // 这里我们也加了一个逗号</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 现在函数需要三个参数，我们来修改下</span><br><span class="line">function clownPuppiesEverywhere(</span><br><span class="line">  param1,</span><br><span class="line">  param2,</span><br><span class="line">+ param3, // 增加params3参数</span><br><span class="line">) &#123; /* ... */ &#125;</span><br><span class="line"></span><br><span class="line">clownPuppiesEverywhere(</span><br><span class="line">  &apos;foo&apos;,</span><br><span class="line">  &apos;bar&apos;,</span><br><span class="line">+ &apos;baz&apos;, // 增加第三个参数</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 叮叮当，我们只修改了两行代码就完成了，好开森</span><br></pre></td></tr></table></figure><p>说实话吧，这个功能让人有点很无语。不过程序猿对干净代码的追求真的很让人感动，还是值得鼓励的。这个就是stage-2中”尾逗号函数”功能。哈哈哈哈。</p><h3 id="transform-object-rest-spread"><a href="#transform-object-rest-spread" class="headerlink" title="transform-object-rest-spread"></a>transform-object-rest-spread</h3><p>再来说transform-object-rest-spread， 其实它是对 ES6中解构赋值的一个扩展，因为ES6只支持对数组的解构赋值，对对象是不支持的。如下面的代码所示：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 获取剩下的属性</span><br><span class="line"></span><br><span class="line">let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;</span><br><span class="line">console.log(x); // 1</span><br><span class="line">console.log(y); // 2</span><br><span class="line">console.log(z); // &#123; a: 3, b: 4 &#125;</span><br><span class="line"></span><br><span class="line">// 属性展开</span><br><span class="line">let n = &#123; x, y, ...z &#125;;</span><br><span class="line">console.log(n); // &#123; x: 1, y: 2, a: 3, b: 4 &#125;</span><br></pre></td></tr></table></figure><h2 id="大放异彩的stage3"><a href="#大放异彩的stage3" class="headerlink" title="大放异彩的stage3"></a>大放异彩的stage3</h2><p>为啥说stage3大放异彩呢？因为它支持大名鼎鼎的async和await, 这两个哥们可是解决(Ajax)回调函数的终极解决方法呀！管你什么异步，我都可以用同步的思维来写，ES7里面非常强悍的存在。总的来说，它包含如下两个插件:</p><p><img src="http://babeljs.io/docs/plugins/transform-async-to-generator/" alt="* transform-async-to-generator"><br><img src="http://babeljs.io/docs/plugins/transform-exponentiation-operator" alt="* transform-exponentiation-operator"></p><h3 id="transform-async-to-generator"><a href="#transform-async-to-generator" class="headerlink" title="transform-async-to-generator"></a>transform-async-to-generator</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">transform-async-to-generator主要用来支持ES7中的async和await， 我们可以写出下面的代码：</span><br><span class="line"></span><br><span class="line">const sleep = (timeout)=&gt;&#123;</span><br><span class="line">    return new Promise( (resolve, reject)=&gt;&#123;</span><br><span class="line">        setTimeout(resolve, timeout)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(async ()=&gt;&#123;</span><br><span class="line">    console.time(&quot;async&quot;);</span><br><span class="line">    await sleep(3000);</span><br><span class="line">    console.timeEnd(&quot;async&quot;);</span><br><span class="line">&#125;)()</span><br><span class="line">再来一个实际点的例子</span><br><span class="line"></span><br><span class="line">const fetchUsers = (user)=&gt;&#123;</span><br><span class="line">    return window.fetch(`https://api.douban.com/v2/user/$&#123;user&#125;`).then( res=&gt;res.json())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const getUser = async (user) =&gt;&#123;</span><br><span class="line">    let users = await fetchUsers(user);</span><br><span class="line">    console.log( users);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log( getUser(&quot;flyingzl&quot;)</span><br></pre></td></tr></table></figure><p>提示： 由于asycn和await是ES7里面的内容，现阶段不建议使用。为了顺利运行上面的代码，建议用webpack进行编译。</p><h3 id="transform-exponentiation-operator"><a href="#transform-exponentiation-operator" class="headerlink" title="transform-exponentiation-operator"></a>transform-exponentiation-operator</h3><p>transform-exponentiation-operator这个插件算是一个语法糖，可以通过**这个符号来进行幂操作，想当于Math.pow(a,b)。如下面的样例</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// x ** y</span><br><span class="line"></span><br><span class="line">let squared = 2 ** 2;</span><br><span class="line">// 相当于: 2 * 2</span><br><span class="line"></span><br><span class="line">let cubed = 2 ** 3;</span><br><span class="line">// 相当于: 2 * 2 * 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// x **= y</span><br><span class="line"></span><br><span class="line">let a = 2;</span><br><span class="line">a **= 2;</span><br><span class="line">// 相当于: a = a * a;</span><br><span class="line"></span><br><span class="line">let b = 3;</span><br><span class="line">b **= 3;</span><br><span class="line">// 相当于: b = b * b * b;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      如何区分Babel中的stage-0,stage-1,stage-2以及stage-3
    
    </summary>
    
      <category term="webpack" scheme="http://yoursite.com/categories/webpack/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
      <category term="packaging" scheme="http://yoursite.com/tags/packaging/"/>
    
      <category term="babel" scheme="http://yoursite.com/tags/babel/"/>
    
      <category term="stage" scheme="http://yoursite.com/tags/stage/"/>
    
  </entry>
  
  <entry>
    <title>webpack中resolve模块</title>
    <link href="http://yoursite.com/2019/07/13/packaging/webpack/resolve/"/>
    <id>http://yoursite.com/2019/07/13/packaging/webpack/resolve/</id>
    <published>2019-07-13T09:50:46.000Z</published>
    <updated>2019-07-13T09:50:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Resolve"><a href="#Resolve" class="headerlink" title="Resolve"></a>Resolve</h1><blockquote><p>这些选项能设置模块如何被解析。webpack 提供合理的默认值，但是还是可能会修改一些解析的细节。</p></blockquote><h3 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h3><p>object</p><blockquote><p>配置模块如何解析。例如，当在 ES2015 中调用 import “lodash”，resolve 选项能够对 webpack 查找 “lodash” 的方式去做修改（查看模块）。</p></blockquote><h3 id="resolve-alias"><a href="#resolve-alias" class="headerlink" title="resolve.alias"></a>resolve.alias</h3><p>object</p><p>创建 import 或 require 的别名，来确保模块引入变得更简单。例如，一些位于 src/ 文件夹下的常用模块：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alias: &#123;</span><br><span class="line">  Utilities: path.resolve(__dirname, &apos;src/utilities/&apos;),</span><br><span class="line">  Templates: path.resolve(__dirname, &apos;src/templates/&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在，替换「在导入时使用相对路径」这种方式，就像这样：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Utility from &apos;../../utilities/utility&apos;;</span><br></pre></td></tr></table></figure></p><p>你可以这样使用别名：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Utility from &apos;Utilities/utility&apos;;</span><br></pre></td></tr></table></figure></p><p><strong> 也可以在给定对象的键后的末尾添加 $，以表示精准匹配：</strong><br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alias: &#123;</span><br><span class="line">  xyz$: path.resolve(__dirname, &apos;path/to/file.js&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这将产生以下结果：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import Test1 from &apos;xyz&apos;; // 精确匹配，所以 path/to/file.js 被解析和导入</span><br><span class="line">import Test2 from &apos;xyz/file.js&apos;; // 精确匹配，触发普通解析</span><br></pre></td></tr></table></figure></p><p>下面的表格展示了一些其他情况：</p><table><thead><tr><th style="text-align:left">别名:</th><th style="text-align:left">import”xyz”</th><th style="text-align:left">import”xyz/file.js”</th></tr></thead><tbody><tr><td style="text-align:left">{}</td><td style="text-align:left">/abc/node_modules/xyz/index.js</td><td style="text-align:left">/abc/node_modules/xyz/file.js</td></tr><tr><td style="text-align:left">{ xyz: “/abs/path/to/file.js” }</td><td style="text-align:left">/abs/path/to/file.js</td><td style="text-align:left">error</td></tr><tr><td style="text-align:left">{ xyz$: “/abs/path/to/file.js” }</td><td style="text-align:left">/abs/path/to/file.js</td><td style="text-align:left">/abc/node_modules/xyz/file.js</td></tr><tr><td style="text-align:left">{ xyz: “./dir/file.js” }</td><td style="text-align:left">/abc/dir/file.js</td><td style="text-align:left">error</td></tr><tr><td style="text-align:left">{ xyz$: “./dir/file.js” }</td><td style="text-align:left">/abc/dir/file.js</td><td style="text-align:left">/abc/node_modules/xyz/file.js</td></tr><tr><td style="text-align:left">{ xyz: “/some/dir” }</td><td style="text-align:left">/some/dir/index.js</td><td style="text-align:left">/some/dir/file.js</td></tr><tr><td style="text-align:left">{ xyz$: “/some/dir” }</td><td style="text-align:left">/some/dir/index.js</td><td style="text-align:left">/abc/node_modules/xyz/file.js</td></tr><tr><td style="text-align:left">{ xyz: “./dir” }</td><td style="text-align:left">/abc/dir/index.js</td><td style="text-align:left">/abc/dir/file.js</td></tr><tr><td style="text-align:left">{ xyz: “modu” }</td><td style="text-align:left">/abc/node_modules/modu/index.js</td><td style="text-align:left">/abc/node_modules/modu/file.js</td></tr><tr><td style="text-align:left">{ xyz$: “modu” }</td><td style="text-align:left">/abc/node_modules/modu/index.js</td><td style="text-align:left">/abc/node_modules/xyz/file.js</td></tr><tr><td style="text-align:left">{ xyz: “modu/some/file.js” }</td><td style="text-align:left">/abc/node_modules/modu/some/file.js</td><td style="text-align:left">error</td></tr><tr><td style="text-align:left">{ xyz: “modu/dir” }</td><td style="text-align:left">/abc/node_modules/modu/dir/index.js</td><td style="text-align:left">/abc/node_modules/dir/file.js</td></tr><tr><td style="text-align:left">{ xyz: “xyz/dir” }</td><td style="text-align:left">/abc/node_modules/xyz/dir/index.js</td><td style="text-align:left">/abc/node_modules/xyz/dir/file.js</td></tr><tr><td style="text-align:left">{ xyz$: “xyz/dir” }</td><td style="text-align:left">/abc/node_modules/xyz/dir/index.js</td><td style="text-align:left">/abc/node_modules/xyz/file.js</td></tr></tbody></table><p>如果在 package.json 中定义，index.js 可能会被解析为另一个文件。</p><p><strong> /abc/node_modules 也可能在 /node_modules 中解析。</strong></p><h3 id="resolve-aliasFields"><a href="#resolve-aliasFields" class="headerlink" title="resolve.aliasFields"></a>resolve.aliasFields</h3><p>string</p><p>指定一个字段，例如 browser，根据此规范进行解析。默认：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aliasFields: [&quot;browser&quot;]</span><br></pre></td></tr></table></figure></p><h3 id="resolve-cacheWithContext"><a href="#resolve-cacheWithContext" class="headerlink" title="resolve.cacheWithContext"></a>resolve.cacheWithContext</h3><p>boolean ( webpack 3.1.0 以后版本)</p><p>如果启用了不安全的缓存，则包含request.context在缓存中。该enhanced-resolve模块考虑了该选项。因为解析缓存中的webpack 3.1.0上下文在提供解析或解析的插件时被忽略。这解决了性能回归。</p><h3 id="resolve-descriptionFiles"><a href="#resolve-descriptionFiles" class="headerlink" title="resolve.descriptionFiles"></a>resolve.descriptionFiles</h3><p>array</p><p>用于描述的 JSON 文件。默认：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">descriptionFiles: [&quot;package.json&quot;]</span><br></pre></td></tr></table></figure></p><h3 id="resolve-enforceExtension"><a href="#resolve-enforceExtension" class="headerlink" title="resolve.enforceExtension"></a>resolve.enforceExtension</h3><p>boolean</p><p>如果是 true，将不允许无扩展名(extension-less)文件。默认如果 ./foo 有 .js 扩展，require(‘./foo’) 可以正常运行。但如果启用此选项，只有 require(‘./foo.js’) 能够正常工作。默认：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enforceExtension: false</span><br></pre></td></tr></table></figure></p><h3 id="resolve-enforceModuleExtension"><a href="#resolve-enforceModuleExtension" class="headerlink" title="resolve.enforceModuleExtension"></a>resolve.enforceModuleExtension</h3><p>boolean</p><p>对模块是否需要使用的扩展（例如 loader）。默认：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enforceModuleExtension: false</span><br></pre></td></tr></table></figure></p><h3 id="resolve-extensions"><a href="#resolve-extensions" class="headerlink" title="resolve.extensions"></a>resolve.extensions</h3><p>array</p><p>自动解析确定的扩展。默认值为：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extensions: [&quot;.js&quot;, &quot;.json&quot;]</span><br></pre></td></tr></table></figure></p><p>能够使用户在引入模块时不带扩展：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import File from &apos;../path/to/file&apos;</span><br></pre></td></tr></table></figure><p>使用此选项，会覆盖默认数组，这就意味着 webpack 将不再尝试使用默认扩展来解析模块。对于使用其扩展导入的模块，例如，import SomeFile from “./somefile.ext”，要想正确的解析，一个包含“*”的字符串必须包含在数组中。</p><h3 id="resolve-mainFields"><a href="#resolve-mainFields" class="headerlink" title="resolve.mainFields"></a>resolve.mainFields</h3><p>array</p><p>当从 npm 包中导入模块时（例如，import * as D3 from “d3”），此选项将决定在 package.json 中使用哪个字段导入模块。根据 webpack 配置中指定的 target 不同，默认值也会有所不同。</p><p>当 target 属性设置为 webworker, web 或者没有指定，默认值为：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mainFields: [&quot;browser&quot;, &quot;module&quot;, &quot;main&quot;]</span><br></pre></td></tr></table></figure></p><p>对于其他任意的 target（包括 node），默认值为：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mainFields: [&quot;module&quot;, &quot;main&quot;]</span><br></pre></td></tr></table></figure></p><p>例如，D3 的 package.json 含有这些字段：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  main: &apos;build/d3.Node.js&apos;,</span><br><span class="line">  browser: &apos;build/d3.js&apos;,</span><br><span class="line">  module: &apos;index&apos;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这意味着当我们 import * as D3 from “d3”，实际从 browser 属性解析文件。在这里 browser 属性是最优先选择的，因为它是 mainFields 的第一项。同时，由 webpack 打包的 Node.js 应用程序默认会从 module 字段中解析文件。</p><h3 id="resolve-mainFiles"><a href="#resolve-mainFiles" class="headerlink" title="resolve.mainFiles"></a>resolve.mainFiles</h3><p>array</p><p>解析目录时要使用的文件名。默认：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mainFiles: [&quot;index&quot;]</span><br></pre></td></tr></table></figure></p><h3 id="resolve-modules"><a href="#resolve-modules" class="headerlink" title="resolve.modules"></a>resolve.modules</h3><p>array</p><p>告诉 webpack 解析模块时应该搜索的目录。</p><p>绝对路径和相对路径都能使用，但是要知道它们之间有一点差异。</p><p>通过查看当前目录以及祖先路径（即 ./node_modules, ../node_modules 等等），相对路径将类似于 Node 查找 ‘node_modules’ 的方式进行查找。</p><p>使用绝对路径，将只在给定目录中搜索。</p><p>resolve.modules defaults to:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modules: [&quot;node_modules&quot;]</span><br></pre></td></tr></table></figure></p><p>如果你想要添加一个目录到模块搜索目录，此目录优先于 node_modules/ 搜索：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modules: [path.resolve(__dirname, &quot;src&quot;), &quot;node_modules&quot;]</span><br></pre></td></tr></table></figure></p><h3 id="resolve-unsafeCache"><a href="#resolve-unsafeCache" class="headerlink" title="resolve.unsafeCache"></a>resolve.unsafeCache</h3><p>regex array boolean</p><p>启用，会主动缓存模块，但并不安全。传递 true 将缓存一切。默认：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsafeCache: true</span><br></pre></td></tr></table></figure></p><p>正则表达式，或正则表达式数组，可以用于匹配文件路径或只缓存某些模块。例如，只缓存 utilities 模块：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsafeCache: /src\/utilities/</span><br></pre></td></tr></table></figure></p><p>修改缓存路径可能在极少数情况下导致失败。</p><h3 id="resolve-plugins"><a href="#resolve-plugins" class="headerlink" title="resolve.plugins"></a>resolve.plugins</h3><p>应该使用的额外的解析插件列表。它允许插件，如 DirectoryNamedWebpackPlugin。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugins: [new DirectoryNamedWebpackPlugin()]</span><br></pre></td></tr></table></figure></p><h3 id="resolve-symlinks"><a href="#resolve-symlinks" class="headerlink" title="resolve.symlinks"></a>resolve.symlinks</h3><p>boolean</p><p>是否将符号链接(symlink)解析到它们的符号链接位置(symlink location)。默认：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">symlinks: true</span><br></pre></td></tr></table></figure></p><h3 id="resolve-cachePredicate"><a href="#resolve-cachePredicate" class="headerlink" title="resolve.cachePredicate"></a>resolve.cachePredicate</h3><p>function</p><p>决定请求是否应该被缓存的函数。函数传入一个带有 path 和 request 属性的对象。默认：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cachePredicate: function() &#123; return true &#125;</span><br></pre></td></tr></table></figure></p><h3 id="resolveLoader"><a href="#resolveLoader" class="headerlink" title="resolveLoader"></a>resolveLoader</h3><p>object</p><p>这组选项与上面的 resolve 对象的属性集合相同，但仅用于解析 webpack 的 loader 包。默认：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    modules: [&quot;node_modules&quot;],</span><br><span class="line">    extensions: [&quot;.js&quot;, &quot;.json&quot;],</span><br><span class="line">    mainFields: [&quot;loader&quot;, &quot;main&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意，这里你可以使用别名，并且其他特性类似于 resolve 对象。例如，{ txt: ‘raw-loader’ } 会使用 raw-loader 去 shim(填充) txt!templates/demo.txt。</p><h3 id="resolveLoader-moduleExtensions"><a href="#resolveLoader-moduleExtensions" class="headerlink" title="resolveLoader.moduleExtensions"></a>resolveLoader.moduleExtensions</h3><p>array</p><p>在解析模块（例如，loader）时尝试使用的扩展。默认是一个空数组。</p><p>如果你想要不带 -loader 后缀使用 loader，你可以使用：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moduleExtensions: [&apos;-loader&apos;]</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      这些选项能设置模块如何被解析。webpack 提供合理的默认值，但是还是可能会修改一些解析的细节。
    
    </summary>
    
      <category term="webpack" scheme="http://yoursite.com/categories/webpack/"/>
    
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
      <category term="packaging" scheme="http://yoursite.com/tags/packaging/"/>
    
      <category term="resolve" scheme="http://yoursite.com/tags/resolve/"/>
    
      <category term="webpack路径简写" scheme="http://yoursite.com/tags/webpack%E8%B7%AF%E5%BE%84%E7%AE%80%E5%86%99/"/>
    
  </entry>
  
  <entry>
    <title>React生命周期</title>
    <link href="http://yoursite.com/2019/07/13/React/lifecyce/"/>
    <id>http://yoursite.com/2019/07/13/React/lifecyce/</id>
    <published>2019-07-13T09:50:46.000Z</published>
    <updated>2019-07-13T09:50:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React生命周期"><a href="#React生命周期" class="headerlink" title="React生命周期"></a>React生命周期</h1><h3 id="用一个表格表示生命周期"><a href="#用一个表格表示生命周期" class="headerlink" title="用一个表格表示生命周期"></a>用一个表格表示生命周期</h3><table><thead><tr><th>函数</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td>getDefaultProps</td><td style="text-align:center">作用于组件类，只调用一次，返回对象用于设置默认的props，对于引用值，会在实例中共享</td></tr><tr><td>getInitialState</td><td style="text-align:center">作用于组件的实例，在实例创建时调用一次，用于初始化每个实例的state，此时可以访问this.props</td></tr><tr><td>componentWillMount</td><td style="text-align:center">在完成首次渲染之前调用，此时仍可以修改组件的state</td></tr><tr><td>render</td><td style="text-align:center">必选的方法，创建虚拟DOM，该方法具有特殊的规则： 1.只能通过this.props和this.state访问数据  2.可以返回null、false或任何React组件  3.只能出现一个顶级组件（不能返回数组） 4.不能改变组件的状态   5.不能修改DOM的输出</td></tr><tr><td>componentDidMount</td><td style="text-align:center">真实的DOM被渲染出来后调用，在该方法中可通过this.getDOMNode()访问到真实的DOM元素。此时已可以使用其他类库来操作这个DOM。在服务端中，该方法不会被调用</td></tr><tr><td>componentWillReceiveProps</td><td style="text-align:center">组件接收到新的props时调用，并将其作为参数nextProps使用，此时可以更改组件props及state</td></tr><tr><td>shouldComponentUpdate</td><td style="text-align:center">组件是否应当渲染新的props或state，返回false表示跳过后续的生命周期方法，通常不需要使用以避免出现bug。在出现应用的瓶颈时，可通过该方法进行适当的优化</td></tr><tr><td>componentWillUpdate</td><td style="text-align:center">接收到新的props或者state后，进行渲染之前调用，此时不允许更新props或state</td></tr><tr><td>componentDidUpdate</td><td style="text-align:center">完成渲染新的props或者state后调用，此时可以访问到新的DOM元素</td></tr><tr><td>componentWillUnmount</td><td style="text-align:center">组件被移除之前被调用，可以用于做一些清理工作，在componentDidMount方法中添加的所有任务都需要在该方法中撤销，比如创建的定时器或添加的事件监听器</td></tr></tbody></table><h2 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h2><h5 id="首次实例化"><a href="#首次实例化" class="headerlink" title="首次实例化"></a>首次实例化</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getDefaultProps</span><br><span class="line">getInitialState</span><br><span class="line">componentWillMount</span><br><span class="line">render</span><br><span class="line">componentDidMount</span><br></pre></td></tr></table></figure><h5 id="实例化完成后的更新"><a href="#实例化完成后的更新" class="headerlink" title="实例化完成后的更新"></a>实例化完成后的更新</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getInitialState</span><br><span class="line">componentWillMount</span><br><span class="line">render</span><br><span class="line">componentDidMount</span><br></pre></td></tr></table></figure><h5 id="存在期"><a href="#存在期" class="headerlink" title="存在期"></a>存在期</h5><p>组件已存在时的状态改变<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">componentWillReceiveProps</span><br><span class="line">shouldComponentUpdate</span><br><span class="line">componentWillUpdate</span><br><span class="line">render</span><br><span class="line">componentDidUpdate</span><br></pre></td></tr></table></figure></p><h5 id="销毁-amp-清理期"><a href="#销毁-amp-清理期" class="headerlink" title="销毁&amp;清理期"></a>销毁&amp;清理期</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">componentWillUnmount</span><br></pre></td></tr></table></figure><p>说明<br>生命周期共提供了10个不同的API。</p><h5 id="1-getDefaultProps"><a href="#1-getDefaultProps" class="headerlink" title="1.getDefaultProps"></a>1.getDefaultProps</h5><p>作用于组件类，只调用一次，返回对象用于设置默认的props，对于引用值，会在实例中共享。</p><h5 id="2-getInitialState"><a href="#2-getInitialState" class="headerlink" title="2.getInitialState"></a>2.getInitialState</h5><p>作用于组件的实例，在实例创建时调用一次，用于初始化每个实例的state，此时可以访问this.props。</p><h5 id="3-componentWillMount"><a href="#3-componentWillMount" class="headerlink" title="3.componentWillMount"></a>3.componentWillMount</h5><p>在完成首次渲染之前调用，此时仍可以修改组件的state。</p><h5 id="4-render"><a href="#4-render" class="headerlink" title="4.render"></a>4.render</h5><p>必选的方法，创建虚拟DOM，该方法具有特殊的规则：</p><p>只能通过this.props和this.state访问数据<br>可以返回null、false或任何React组件<br>只能出现一个顶级组件（不能返回数组）<br>不能改变组件的状态<br>不能修改DOM的输出</p><h5 id="5-componentDidMount"><a href="#5-componentDidMount" class="headerlink" title="5.componentDidMount"></a>5.componentDidMount</h5><p>真实的DOM被渲染出来后调用，在该方法中可通过this.getDOMNode()访问到真实的DOM元素。此时已可以使用其他类库来操作这个DOM。</p><p>在服务端中，该方法不会被调用。</p><h5 id="6-componentWillReceiveProps"><a href="#6-componentWillReceiveProps" class="headerlink" title="6.componentWillReceiveProps"></a>6.componentWillReceiveProps</h5><p>组件接收到新的props时调用，并将其作为参数nextProps使用，此时可以更改组件props及state。</p><pre><code>componentWillReceiveProps: function(nextProps) {    if (nextProps.bool) {        this.setState({            bool: true        });    }}</code></pre><h5 id="7-shouldComponentUpdate"><a href="#7-shouldComponentUpdate" class="headerlink" title="7.shouldComponentUpdate"></a>7.shouldComponentUpdate</h5><p>组件是否应当渲染新的props或state，返回false表示跳过后续的生命周期方法，通常不需要使用以避免出现bug。在出现应用的瓶颈时，可通过该方法进行适当的优化。</p><p>在首次渲染期间或者调用了forceUpdate方法后，该方法不会被调用</p><h5 id="8-componentWillUpdate"><a href="#8-componentWillUpdate" class="headerlink" title="8.componentWillUpdate"></a>8.componentWillUpdate</h5><p>接收到新的props或者state后，进行渲染之前调用，此时不允许更新props或state。</p><h5 id="9-componentDidUpdate"><a href="#9-componentDidUpdate" class="headerlink" title="9.componentDidUpdate"></a>9.componentDidUpdate</h5><p>完成渲染新的props或者state后调用，此时可以访问到新的DOM元素。</p><h5 id="10-componentWillUnmount"><a href="#10-componentWillUnmount" class="headerlink" title="10.componentWillUnmount"></a>10.componentWillUnmount</h5><p>组件被移除之前被调用，可以用于做一些清理工作，在componentDidMount方法中添加的所有任务都需要在该方法中撤销，比如创建的定时器或添加的事件监听器。</p>]]></content>
    
    <summary type="html">
    
      React生命周期
    
    </summary>
    
      <category term="react" scheme="http://yoursite.com/categories/react/"/>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
      <category term="生命周期" scheme="http://yoursite.com/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    
      <category term="框架" scheme="http://yoursite.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>react项目搭建</title>
    <link href="http://yoursite.com/2019/07/13/React/react/"/>
    <id>http://yoursite.com/2019/07/13/React/react/</id>
    <published>2019-07-13T09:50:46.000Z</published>
    <updated>2019-07-13T09:50:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="react项目搭建"><a href="#react项目搭建" class="headerlink" title="react项目搭建"></a>react项目搭建</h1><p>要想使用npm,请先安装nodejs.</p><h2 id="第一步、安装全局包"><a href="#第一步、安装全局包" class="headerlink" title="第一步、安装全局包"></a>第一步、安装全局包</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install babel -g</span><br><span class="line">$ npm install webpack -g</span><br><span class="line">$ npm install webpack-dev-server -g</span><br></pre></td></tr></table></figure><h2 id="第二步、创建根目录"><a href="#第二步、创建根目录" class="headerlink" title="第二步、创建根目录"></a>第二步、创建根目录</h2><p>创建一个根目录，目录名为：reactApp，再使用 npm init 初始化，生成 package.json 文件：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir reactApp</span><br><span class="line">$ cd reactApp/</span><br><span class="line">$ npm init</span><br></pre></td></tr></table></figure></p><h4 id="命令行显示以下内容"><a href="#命令行显示以下内容" class="headerlink" title="命令行显示以下内容"></a>命令行显示以下内容</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">name: (reactApp) runoob-react-test</span><br><span class="line">version: (1.0.0)</span><br><span class="line">description: cllgeek</span><br><span class="line">entry point: (index.js)</span><br><span class="line">test command:</span><br><span class="line">git repository:</span><br><span class="line">keywords:</span><br><span class="line">author:</span><br><span class="line">license: (ISC)</span><br><span class="line">About to write to /Users/tianqixin/www/reactApp/package.json:</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;react-runoob&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;cllgeek test&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;webpack-dev-server --hot&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">    &quot;author&quot;: &quot;&quot;,</span><br><span class="line">    &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">    &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;react&quot;: &quot;^0.14.8&quot;,</span><br><span class="line">    &quot;react-dom&quot;: &quot;^0.14.8&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Is this ok? (yes)</span><br></pre></td></tr></table></figure><h2 id="第三步、添加越来包及插件"><a href="#第三步、添加越来包及插件" class="headerlink" title="第三步、添加越来包及插件"></a>第三步、添加越来包及插件</h2><p>因为我们要使用 React, 所以我们需要先安装它，–save 命令用于将包添加至 package.json 文件。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ npm install react --save</span><br><span class="line">$ npm install react-dom --save</span><br><span class="line">同时我们也要安装一些 babel 插件</span><br><span class="line"></span><br><span class="line">$ npm install babel-core</span><br><span class="line">$ npm install babel-loader</span><br><span class="line">$ npm install babel-preset-react</span><br><span class="line">$ npm install babel-preset-es2015</span><br></pre></td></tr></table></figure></p><h2 id="第四步、创建文件"><a href="#第四步、创建文件" class="headerlink" title="第四步、创建文件"></a>第四步、创建文件</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">接下来我们创建一些必要文件：</span><br><span class="line"></span><br><span class="line">$ touch index.html</span><br><span class="line">$ touch App.jsx</span><br><span class="line">$ touch main.js</span><br><span class="line">$ touch webpack.config.js</span><br></pre></td></tr></table></figure><h2 id="第五步、设置编译器，服务器，载入器"><a href="#第五步、设置编译器，服务器，载入器" class="headerlink" title="第五步、设置编译器，服务器，载入器"></a>第五步、设置编译器，服务器，载入器</h2><p>打开 webpack.config.js 文件添加以下代码:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var config = &#123;</span><br><span class="line">  entry: &apos;./main.js&apos;,</span><br><span class="line"></span><br><span class="line">  output: &#123;</span><br><span class="line">    path:&apos;./&apos;,</span><br><span class="line">    filename: &apos;index.js&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    inline: true,</span><br><span class="line">    port: 8888</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  module: &#123;</span><br><span class="line">    loaders: [ &#123;</span><br><span class="line">      test: /.jsx?$/,</span><br><span class="line">      exclude: /node_modules/,</span><br><span class="line">      loader: &apos;babel&apos;,</span><br><span class="line"></span><br><span class="line">         query: &#123;</span><br><span class="line">            presets: [&apos;es2015&apos;, &apos;react&apos;]</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = config;</span><br></pre></td></tr></table></figure></p><p>entry: 指定打包的入口文件 main.js。<br>output：配置打包结果，path定义了输出的文件夹，filename则定义了打包结果文件的名称。<br>devServer：设置服务器端口号为 8888，端口后你可以自己设定 。<br>module：定义了对模块的处理逻辑，这里可以用loaders定义了一系列的加载器，以及一些正则。当需要加载的文件匹配test的正则时，就会调用后面的loader对文件进行处理，这正是webpack强大的原因。<br>现在打开 package.json 文件，找到 “scripts” 中的 “test” “echo \”Error: no test specified\” &amp;&amp; exit 1″ 使用以下代码替换：</p><p>“start”: “webpack-dev-server –hot”<br>替换后的 package.json 文件 内容如下：</p><p>$ cat package.json<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;runoob-react-test&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;cllgeek test&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;webpack-dev-server --hot&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;react&quot;: &quot;^0.14.7&quot;,</span><br><span class="line">    &quot;react-dom&quot;: &quot;^0.14.7&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在我们可以使用 npm start 命令来启动服务。–hot 命令会在文件变化后重新载入，这样我们就不需要在代码修改后重新刷新浏览器就能看到变化。</p><h2 id="第六步、index-html"><a href="#第六步、index-html" class="headerlink" title="第六步、index.html"></a>第六步、index.html</h2><p>设置 div id = “app” 为我们应用的根元素，并引入 index.js 脚本文件。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset = &quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;React App - cllgeek(cllgeek.com)&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id = &quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script src = &quot;index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><h2 id="第七步、App-jsx-和-main-js"><a href="#第七步、App-jsx-和-main-js" class="headerlink" title="第七步、App.jsx 和 main.js"></a>第七步、App.jsx 和 main.js</h2><p>这是第一个 react 组件。后面的章节我们会详细介绍 React 组件。这个组件将输出 Hello World!!!。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">App.jsx 文件代码</span><br><span class="line">import React from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        Hello World!!!</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure></p><p>我们需要引入组件并将其渲染到根元素 App 上，这样我们才可以在浏览器上看到它。<br>main.js 文件代码<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;;</span><br><span class="line"></span><br><span class="line">import App from &apos;./App.jsx&apos;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.getElementById(&apos;app&apos;))</span><br></pre></td></tr></table></figure></p><p>注意：<br>如果想要组件可以在任何的应用中使用，需要在创建后使用 export 将其导出，在使用组件的文件使用 import将其导入。</p><h2 id="第八步、运行服务"><a href="#第八步、运行服务" class="headerlink" title="第八步、运行服务"></a>第八步、运行服务</h2><p>完成以上配置后，我们即可运行该服务：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm start</span><br><span class="line">通过浏览器访问 http://localhost:7777/，输出结果如下:</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      react项目搭建
    
    </summary>
    
      <category term="react" scheme="http://yoursite.com/categories/react/"/>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
      <category term="项目搭建" scheme="http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>git区分大小写</title>
    <link href="http://yoursite.com/2019/07/13/git/git-capitalize/"/>
    <id>http://yoursite.com/2019/07/13/git/git-capitalize/</id>
    <published>2019-07-13T09:50:46.000Z</published>
    <updated>2019-07-13T09:50:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>其实 git 默认对于文件名大小写是不敏感的,所以上面你修改了首字母大写,但是git 并没有发现代码任何改动.</p><p>那么如何才能让 git 识别文件名大小写变化.</p><p>一  配置git 使其对文件名大小写敏感</p><p>git config core.ignorecase false</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Administrator@SC-202102021413 F:\xunlian\hexo</span><br><span class="line">&gt;git config core.ignorecase false</span><br></pre></td></tr></table></figure><p>二 从git 本地仓库删除此文件,然后添加再提交</p><p>(1) 删除<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Administrator@SC-202102021413 F:\xunlian\hexo</span><br><span class="line">&gt;git rm readme.md</span><br></pre></td></tr></table></figure></p><p>(2) 重新添加<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Administrator@SC-202102021413 F:\xunlian\hexo</span><br><span class="line">&gt;git add Readme.md</span><br></pre></td></tr></table></figure></p><p>(3)提交<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Administrator@SC-202102021413 F:\xunlian\hexo</span><br><span class="line">&gt;git commit -m &apos;Readme.md&apos;</span><br></pre></td></tr></table></figure></p><p>推荐第一种方法,配置好git 对文件名大小写敏感.</p>]]></content>
    
    <summary type="html">
    
      git区分大小写
    
    </summary>
    
      <category term="辅助工具" scheme="http://yoursite.com/categories/%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="辅助工具" scheme="http://yoursite.com/tags/%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git设置上传忽略</title>
    <link href="http://yoursite.com/2019/07/13/git/git-neglect/"/>
    <id>http://yoursite.com/2019/07/13/git/git-neglect/</id>
    <published>2019-07-13T09:50:46.000Z</published>
    <updated>2019-07-13T09:50:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git设置上传忽略"><a href="#Git设置上传忽略" class="headerlink" title="Git设置上传忽略"></a>Git设置上传忽略</h1><h2 id="忽略语法规则"><a href="#忽略语法规则" class="headerlink" title="忽略语法规则"></a>忽略语法规则</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># 忽略*.o和*.a文件</span><br><span class="line"></span><br><span class="line"> *.[oa]</span><br><span class="line"></span><br><span class="line"># 忽略*.b和*.B文件，my.b除外</span><br><span class="line"></span><br><span class="line">*.[bB]</span><br><span class="line"></span><br><span class="line">!my.b</span><br><span class="line"></span><br><span class="line"># 忽略dbg文件和dbg目录</span><br><span class="line"></span><br><span class="line">dbg</span><br><span class="line"></span><br><span class="line"># 只忽略dbg目录，不忽略dbg文件</span><br><span class="line"></span><br><span class="line">dbg/</span><br><span class="line"></span><br><span class="line"># 只忽略dbg文件，不忽略dbg目录</span><br><span class="line"></span><br><span class="line">dbg</span><br><span class="line"></span><br><span class="line">!dbg/</span><br><span class="line"></span><br><span class="line"># 只忽略当前目录下的dbg文件和目录，子目录的dbg不在忽略范围内</span><br><span class="line"></span><br><span class="line">/dbg</span><br><span class="line"></span><br><span class="line"># 忽略所有 .a 结尾的文件</span><br><span class="line">*.a</span><br><span class="line"></span><br><span class="line"># 但 lib.a 除外</span><br><span class="line">!lib.a </span><br><span class="line"></span><br><span class="line"># 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span><br><span class="line">/TODO </span><br><span class="line"></span><br><span class="line"># 忽略 build/ 目录下的所有文件</span><br><span class="line">build/ </span><br><span class="line"></span><br><span class="line"># 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br><span class="line">doc/*.txt</span><br></pre></td></tr></table></figure><p>下面介绍3种方法来设置上传忽略配置：</p><h2 id="【方法一】"><a href="#【方法一】" class="headerlink" title="【方法一】"></a>【方法一】</h2><p> 通过配置.git/info/exclude文件来忽略文件。这种方式对仓库全局有效，只能对自己本地仓库有作用，其他人没办法通过这种方式来共享忽略规则，除非他人也修改其本地仓库的该文件。</p><h2 id="【方法二】"><a href="#【方法二】" class="headerlink" title="【方法二】"></a>【方法二】</h2><p> 通过.git/config配置文件的core. Excludesfile选项，指定一个忽略规则文件（完整路径），如下图所示。忽略规则在文件e:/gitignore.txt中（当然该文件名可以任意取）。在config的[remote “origin”]上一行添加 excludesfile = e:/gitignore.text即可<br> <figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> [core]</span><br><span class="line">repositoryformatversion = 0</span><br><span class="line">filemode = false</span><br><span class="line">bare = false</span><br><span class="line">logallrefupdates = true</span><br><span class="line">symlinks = false</span><br><span class="line">ignorecase = true</span><br><span class="line">    excludesfile = e:/gitignore.text</span><br><span class="line">[remote &quot;origin&quot;]</span><br></pre></td></tr></table></figure></p><p> 该方式的作用域是也全局的。</p><h2 id="【方式三】"><a href="#【方式三】" class="headerlink" title="【方式三】"></a>【方式三】</h2><p> 在项目根目录下创建.gitignore文件如果已经创建则不用创建然后在该文件中添加忽略语法<br> .gitignore文件对其所在的目录及所在目录的全部子目录均有效。通过将.gitignore文件添加到仓库，其他开发者更新该文件到本地仓库，以共享同一套忽略规则。</p>]]></content>
    
    <summary type="html">
    
      Git设置上传忽略
    
    </summary>
    
      <category term="辅助工具" scheme="http://yoursite.com/categories/%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="辅助工具" scheme="http://yoursite.com/tags/%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
      <category term="配置" scheme="http://yoursite.com/tags/%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>babel6</title>
    <link href="http://yoursite.com/2019/07/13/packaging/webpack/babel6/"/>
    <id>http://yoursite.com/2019/07/13/packaging/webpack/babel6/</id>
    <published>2019-07-13T09:50:46.000Z</published>
    <updated>2019-07-13T09:50:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="babel-分离为多个包"><a href="#babel-分离为多个包" class="headerlink" title="babel 分离为多个包"></a>babel 分离为多个包</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">babel-cli 命令行</span><br><span class="line">babel-core node api 以及 require hook</span><br><span class="line">babel-polyfill 提供es2015的环境</span><br></pre></td></tr></table></figure><h2 id="preset-机制"><a href="#preset-机制" class="headerlink" title="preset 机制"></a>preset 机制</h2><p>babel6 默认不再默认支持 es2015 以及 react。 需要手动在 .babelrc 中添加presets。<br>所谓的 presets 其实就是一些同类plugin打包的结果，方便进行添加。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [&quot;es2015&quot;, &quot;react&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>stage 不再是配置项，以 presets 的形式添加。</p><p>博客推荐：<br><a href="https://segmentfault.com/a/1190000004301150" target="_blank" rel="noopener">babel6 升级总结</a><br><a href="http://www.ruanyifeng.com/blog/2016/01/babel.html" target="_blank" rel="noopener">软大师 Babel 入门教程</a></p>]]></content>
    
    <summary type="html">
    
      babel升级6版本产生了一些问题
    
    </summary>
    
      <category term="webpack" scheme="http://yoursite.com/categories/webpack/"/>
    
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
      <category term="packaging" scheme="http://yoursite.com/tags/packaging/"/>
    
      <category term="babel" scheme="http://yoursite.com/tags/babel/"/>
    
  </entry>
  
  <entry>
    <title>parcel使用</title>
    <link href="http://yoursite.com/2019/07/13/packaging/parcel/parcelDev/"/>
    <id>http://yoursite.com/2019/07/13/packaging/parcel/parcelDev/</id>
    <published>2019-07-13T09:50:46.000Z</published>
    <updated>2019-07-13T09:50:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是pracel"><a href="#什么是pracel" class="headerlink" title="什么是pracel"></a>什么是pracel</h3><p>parcel是一个前端项目打包器，现在我们已有的打包器与webpack和gulp。</p><h3 id="为什么要把pracel拿出来说一说"><a href="#为什么要把pracel拿出来说一说" class="headerlink" title="为什么要把pracel拿出来说一说"></a>为什么要把pracel拿出来说一说</h3><p>最近许多的网站推送pracel的相关消息，说什么零配置，打包速度快。</p><h3 id="几个问题"><a href="#几个问题" class="headerlink" title="几个问题"></a>几个问题</h3><ol><li>我们现在使用的打包工具有哪些？</li><li>我们为什么要是用这些打包工具，使用这些打包工具为我们解决了什么问题？</li><li>现在已用到的打包工具给我们造成了什么困扰？</li></ol><h3 id="用parcel建一个简单的项目"><a href="#用parcel建一个简单的项目" class="headerlink" title="用parcel建一个简单的项目"></a>用parcel建一个简单的项目</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>Yarn:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn global add parcel-bundler</span><br></pre></td></tr></table></figure></p><p>npm:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g parcel-bundler</span><br></pre></td></tr></table></figure></p><h4 id="创建package-json"><a href="#创建package-json" class="headerlink" title="创建package.json"></a>创建package.json</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn init -y</span><br></pre></td></tr></table></figure><p>or<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure></p><h4 id="创建一个-index-html-和-index-js-文件。"><a href="#创建一个-index-html-和-index-js-文件。" class="headerlink" title="创建一个 index.html 和 index.js 文件。"></a>创建一个 index.html 和 index.js 文件。</h4><p>index.html<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>index.js<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;hello world&quot;);</span><br></pre></td></tr></table></figure></p><h4 id="在package-json重配置"><a href="#在package-json重配置" class="headerlink" title="在package.json重配置"></a>在package.json重配置</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;parcel index.html -p 4000&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="Babel配置"><a href="#Babel配置" class="headerlink" title="Babel配置"></a>Babel配置</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add babel-preset-env</span><br></pre></td></tr></table></figure><p> .babelrc文件<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [&quot;env&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="PostCSS配置"><a href="#PostCSS配置" class="headerlink" title="PostCSS配置"></a>PostCSS配置</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add postcss-modules autoprefixer</span><br></pre></td></tr></table></figure><p>.postcssrc<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;modules&quot;: true,</span><br><span class="line">  &quot;plugins&quot;: &#123;</span><br><span class="line">    &quot;autoprefixer&quot;: &#123;</span><br><span class="line">      &quot;grid&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="PostHTML配置"><a href="#PostHTML配置" class="headerlink" title="PostHTML配置"></a>PostHTML配置</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add posthtml-img-autosize</span><br></pre></td></tr></table></figure><p>.posthtmlrc<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;plugins&quot;: &#123;</span><br><span class="line">    &quot;posthtml-img-autosize&quot;: &#123;</span><br><span class="line">      &quot;root&quot;: &quot;./images&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/yihaoliu/parcelReact" target="_blank" rel="noopener">parcelReact项目</a>。</p><p>虽然说parcel是零配置但是在没有配置的情况下明显项目的灵活度降低许多，下载react有create-react-app进行构建，vue有vue-cli进行构架其实在项目配置相对来说已经非常少了，但是parcel没有配置文件还是让项目的开发有点难受，比如文件起别名，还有proxyConfig进行跨域处理在项目的开发时期都是很重有的事情，只能说对于一个初学web的人员来说配置变少了尤其是没有用到三大框架的项目组pracel还是使用很方便的，对于一些h5小网页比如基于canvas的小游戏的开发用pracel来构建还是非常方便的，但对于大型网站来说。。。</p>]]></content>
    
    <summary type="html">
    
      parcel是一个前端项目打包器
    
    </summary>
    
      <category term="parcel" scheme="http://yoursite.com/categories/parcel/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="项目打包" scheme="http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85/"/>
    
      <category term="parcel" scheme="http://yoursite.com/tags/parcel/"/>
    
      <category term="packaging" scheme="http://yoursite.com/tags/packaging/"/>
    
  </entry>
  
  <entry>
    <title>web优化</title>
    <link href="http://yoursite.com/2019/07/13/other/optimize/web/"/>
    <id>http://yoursite.com/2019/07/13/other/optimize/web/</id>
    <published>2019-07-13T09:50:46.000Z</published>
    <updated>2019-07-13T09:50:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="作者：sunlei"><a href="#作者：sunlei" class="headerlink" title="作者：sunlei"></a>作者：sunlei</h3><p> <strong>script 标签的优化</strong> </p><ul><li>默认情况HTML解析，然后加载JS，此时HTML解析中断，然后执行JS，最后JS执行完成恢复HTML解析。</li><li>defer情况是HTMl和JS 并驾齐驱，等HTML加载完成再执行JS。</li><li>async 情况则HTMl和JS并驾齐驱,JS执行可能在HTML解析完成之前。 </li><li>module情况和defer情况类似，只是在提取过程中多加载了多个JS文件。</li></ul><blockquote><p>怎么区分 有以下几点 </p></blockquote><ol><li>defer翻译过来是延缓的意思，也就是拖拖拉拉了，所以比较懒，也就是说什么都不想做，也就是哪怕你把饭端在我面前，我也懒得动嘴的那种，这么一想，我们不就记住了，哪怕你客户端把JS文件下载好了，我也懒得执行，最后实在是大家都干完事了，我才不情愿的去执行JS文件。</li></ol><hr><ol start="2"><li>async翻译过来就是异步的意思，异步异步，不就是一步一步嘛，什么都想一步到位，也就是说，只要下载完我就立马执行，至于其他的想都不想。</li></ol><hr><ol start="3"><li>module翻译过来就是模块的意思，es6用过的人基本都了解这个关键字，加载也和defer差不多，只不过可以加载多个JS文件而已。</li></ol><p><strong>从上面我们可以看出，如果你的脚本依赖于DOM构建完成是否完成，则可以使用defer；如果无需DOM的构建，那就可以放心的使用async了</strong></p><h2 id="扩展导入"><a href="#扩展导入" class="headerlink" title="扩展导入"></a>扩展导入</h2><p><img src="./image.png" alt="扩展导入"><br><img src="./async.png" alt="图片详解解析步骤"></p>]]></content>
    
    <summary type="html">
    
      web优化
    
    </summary>
    
      <category term="优化" scheme="http://yoursite.com/categories/%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="优化" scheme="http://yoursite.com/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>ECMAScript 提案</title>
    <link href="http://yoursite.com/2019/07/13/javaScript/ECMAScript/"/>
    <id>http://yoursite.com/2019/07/13/javaScript/ECMAScript/</id>
    <published>2019-07-13T09:50:46.000Z</published>
    <updated>2019-07-13T09:50:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="标准的流程包括五个步骤："><a href="#标准的流程包括五个步骤：" class="headerlink" title="标准的流程包括五个步骤："></a>标准的流程包括五个步骤：</h2><h3 id="stage0-strawman"><a href="#stage0-strawman" class="headerlink" title="stage0 strawman"></a>stage0 strawman</h3><p>任何讨论、想法、改变或者还没加到提案的特性都在这个阶段。只有TC39成员可以提交。</p><h3 id="stage1-proposal"><a href="#stage1-proposal" class="headerlink" title="stage1 proposal"></a>stage1 proposal</h3><p>（1）产出一个正式的提案。<br>（2）发现潜在的问题，例如与其他特性的关系，实现难题。<br>（3）提案包括详细的API描述，使用例子，以及关于相关的语义和算法。</p><h3 id="stage2-draft"><a href="#stage2-draft" class="headerlink" title="stage2 draft"></a>stage2 draft</h3><p>（1）提供一个初始的草案规范，与最终标准中包含的特性不会有太大差别。草案之后，原则上只接受增量修改。<br>（2）开始实验如何实现，实现形式包括polyfill, 实现引擎（提供草案执行本地支持），或者编译转换（例如babel）</p><h3 id="stage3-candidate"><a href="#stage3-candidate" class="headerlink" title="stage3 candidate"></a>stage3 candidate</h3><p>（1）候选阶段，获得具体实现和用户的反馈。此后，只有在实现和使用过程中出现了重大问题才会修改。 （2）规范文档必须是完整的，评审人和ECMAScript的编辑要在规范上签字。<br>（3）至少要在一个浏览器中实现，提供polyfill或者babel插件。</p><h3 id="stage4-finished"><a href="#stage4-finished" class="headerlink" title="stage4 finished"></a>stage4 finished</h3><p>（1）已经准备就绪，该特性会出现在下个版本的ECMAScript规范之中。<br>（2）需要通过有2个独立的实现并通过验收测试，以获取使用过程中的重要实践经验。</p><h2 id="TC39什么鬼？什么成分？主要业务是什么？"><a href="#TC39什么鬼？什么成分？主要业务是什么？" class="headerlink" title="TC39什么鬼？什么成分？主要业务是什么？"></a>TC39什么鬼？什么成分？主要业务是什么？</h2><p>一个推动 JavaScript 发展的委员会，由各个主流浏览器厂商的代表构成。制定ECMAScript标准，标准生成的流程，并实现。</p><h2 id="相关-stage0-4的具体内容查看地址"><a href="#相关-stage0-4的具体内容查看地址" class="headerlink" title="相关 stage0-4的具体内容查看地址"></a>相关 stage0-4的具体内容查看地址</h2><p>stage0 的提案 <a href="https://github.com/tc39/proposals/blob/master/stage-0-proposals.md" target="_blank" rel="noopener">https://github.com/tc39/proposals/blob/master/stage-0-proposals.md</a><br>stage1 - 4 的提案 <a href="https://github.com/tc39/proposa" target="_blank" rel="noopener">https://github.com/tc39/proposa</a></p><p>推荐阅读：<br><a href="https://zhuanlan.zhihu.com/p/27762556" target="_blank" rel="noopener">精读 TC39 与 ECMAScript 提案</a></p>]]></content>
    
    <summary type="html">
    
      了解ECMAScript从提案到标准的制定落地
    
    </summary>
    
      <category term="ECMAScript" scheme="http://yoursite.com/categories/ECMAScript/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="ECMAScript提案" scheme="http://yoursite.com/tags/ECMAScript%E6%8F%90%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>关于数组的使用</title>
    <link href="http://yoursite.com/2019/07/13/javaScript/array/function/"/>
    <id>http://yoursite.com/2019/07/13/javaScript/array/function/</id>
    <published>2019-07-13T09:50:46.000Z</published>
    <updated>2019-07-13T09:50:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Array-方法"><a href="#Array-方法" class="headerlink" title="Array 方法"></a>Array 方法</h1><h2 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h2><blockquote><p>连接两个或者多个数组并返回新的数组，该方法不会影响原数组。</p></blockquote><h3 id="es6-实现concat"><a href="#es6-实现concat" class="headerlink" title="es6 实现concat"></a>es6 实现concat</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr1 = [2,3];</span><br><span class="line">let arr2 = [4,5];</span><br><span class="line">let arr3 = [...arr1,...arr2]</span><br></pre></td></tr></table></figure><h3 id="实现一个concat"><a href="#实现一个concat" class="headerlink" title="实现一个concat"></a>实现一个concat</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.myConcat = function () &#123;</span><br><span class="line">  let arr = this.slice(0);</span><br><span class="line">  arguments.length &amp;&amp; [].forEach.call(arguments,(value) =&gt; &#123;</span><br><span class="line">    if (Array.isArray(value)) &#123;</span><br><span class="line">     value.forEach(val =&gt; &#123;</span><br><span class="line">       arr.push(val);</span><br><span class="line">     &#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      arr.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  return arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">concat()</td><td style="text-align:center">连接两个或更多的数组，并返回结果。</td></tr><tr><td style="text-align:center">join()</td><td style="text-align:center">把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。</td></tr><tr><td style="text-align:center">pop()</td><td style="text-align:center">删除并返回数组的最后一个元素</td></tr><tr><td style="text-align:center">push()</td><td style="text-align:center">向数组的末尾添加一个或更多元素，并返回新的长度。</td></tr><tr><td style="text-align:center">reverse()</td><td style="text-align:center">颠倒数组中元素的顺序。</td></tr><tr><td style="text-align:center">shift()</td><td style="text-align:center">删除并返回数组的第一个元素</td></tr><tr><td style="text-align:center">slice()</td><td style="text-align:center">从某个已有的数组返回选定的元素</td></tr><tr><td style="text-align:center">sort()</td><td style="text-align:center">对数组的元素进行排序</td></tr><tr><td style="text-align:center">splice()</td><td style="text-align:center">删除元素，并向数组添加新元素。</td></tr><tr><td style="text-align:center">toSource()</td><td style="text-align:center">返回该对象的源代码。</td></tr><tr><td style="text-align:center">toString()</td><td style="text-align:center">把数组转换为字符串，并返回结果。</td></tr><tr><td style="text-align:center">toLocaleString()</td><td style="text-align:center">把数组转换为本地数组，并返回结果。</td></tr><tr><td style="text-align:center">unshift()</td><td style="text-align:center">向数组的开头添加一个或更多元素，并返回新的长度。</td></tr><tr><td style="text-align:center">valueOf()</td><td style="text-align:center">返回数组对象的原始值</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      最近面试很多的算法题，被问到优化方面的问题，今天就来总结下js中数组的方法和性能优化，主要介绍有数组的方法，数组一下方法的实现，和常见的数组算法集合
    
    </summary>
    
      <category term="array" scheme="http://yoursite.com/categories/array/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="array" scheme="http://yoursite.com/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>packagejson文件详解</title>
    <link href="http://yoursite.com/2019/07/13/node/packagejson/"/>
    <id>http://yoursite.com/2019/07/13/node/packagejson/</id>
    <published>2019-07-13T09:50:46.000Z</published>
    <updated>2019-07-13T15:10:06.882Z</updated>
    
    <content type="html"><![CDATA[<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. 概述</span><br><span class="line">2. scripts字段</span><br><span class="line">3. dependencies字段，devDependencies字段</span><br><span class="line">4. peerDependencies</span><br><span class="line">5. bin字段</span><br><span class="line">6. main字段</span><br><span class="line">7. config 字段</span><br><span class="line">8. 其他</span><br><span class="line">9. browser字段</span><br><span class="line">10. engines 字段</span><br><span class="line">11. man字段</span><br><span class="line">12. preferGlobal字段</span><br><span class="line">13. style字段</span><br></pre></td></tr></table></figure><hr><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>每个项目的根目录下面，一般都有一个package.json文件，定义了这个项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等元数据）。npm install命令根据这个配置文件，自动下载所需的模块，也就是配置项目所需的运行和开发环境。</p><p>下面是一个最简单的package.json文件，只定义两项元数据：项目名称和项目版本。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot; : &quot;xxx&quot;,</span><br><span class="line">  &quot;version&quot; : &quot;0.0.0&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>package.json文件就是一个JSON对象，该对象的每一个成员就是当前项目的一项设置。比如name就是项目名称，version是版本（遵守“大版本.次要版本.小版本”的格式）。</p><p>下面是一个更完整的package.json文件。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;name&quot;: &quot;Hello World&quot;,</span><br><span class="line">&quot;version&quot;: &quot;0.0.1&quot;,</span><br><span class="line">&quot;author&quot;: &quot;张三&quot;,</span><br><span class="line">&quot;description&quot;: &quot;第一个node.js程序&quot;,</span><br><span class="line">&quot;keywords&quot;:[&quot;node.js&quot;,&quot;javascript&quot;],</span><br><span class="line">&quot;repository&quot;: &#123;</span><br><span class="line">&quot;type&quot;: &quot;git&quot;,</span><br><span class="line">&quot;url&quot;: &quot;https://path/to/url&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;license&quot;:&quot;MIT&quot;,</span><br><span class="line">&quot;engines&quot;: &#123;&quot;node&quot;: &quot;0.10.x&quot;&#125;,</span><br><span class="line">&quot;bugs&quot;:&#123;&quot;url&quot;:&quot;http://path/to/bug&quot;,&quot;email&quot;:&quot;bug@example.com&quot;&#125;,</span><br><span class="line">&quot;contributors&quot;:[&#123;&quot;name&quot;:&quot;李四&quot;,&quot;email&quot;:&quot;lisi@example.com&quot;&#125;],</span><br><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">&quot;start&quot;: &quot;node index.js&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;dependencies&quot;: &#123;</span><br><span class="line">&quot;express&quot;: &quot;latest&quot;,</span><br><span class="line">&quot;mongoose&quot;: &quot;~3.8.3&quot;,</span><br><span class="line">&quot;handlebars-runtime&quot;: &quot;~1.0.12&quot;,</span><br><span class="line">&quot;express3-handlebars&quot;: &quot;~0.5.0&quot;,</span><br><span class="line">&quot;MD5&quot;: &quot;~1.2.0&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;devDependencies&quot;: &#123;</span><br><span class="line">&quot;bower&quot;: &quot;~1.2.8&quot;,</span><br><span class="line">&quot;grunt&quot;: &quot;~0.4.1&quot;,</span><br><span class="line">&quot;grunt-contrib-concat&quot;: &quot;~0.3.0&quot;,</span><br><span class="line">&quot;grunt-contrib-jshint&quot;: &quot;~0.7.2&quot;,</span><br><span class="line">&quot;grunt-contrib-uglify&quot;: &quot;~0.2.7&quot;,</span><br><span class="line">&quot;grunt-contrib-clean&quot;: &quot;~0.5.0&quot;,</span><br><span class="line">&quot;browserify&quot;: &quot;2.36.1&quot;,</span><br><span class="line">&quot;grunt-browserify&quot;: &quot;~1.3.0&quot;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面详细解释package.json文件的各个字段。</p><h3 id="2-scripts字段"><a href="#2-scripts字段" class="headerlink" title="2. scripts字段"></a>2. scripts字段</h3><p>scripts指定了运行脚本命令的npm命令行缩写，比如start指定了运行npm run start时，所要执行的命令。</p><p>下面的设置指定了npm run preinstall、npm run postinstall、npm run start、npm run test时，所要执行的命令。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;preinstall&quot;: &quot;echo here it comes!&quot;,</span><br><span class="line">    &quot;postinstall&quot;: &quot;echo there it goes!&quot;,</span><br><span class="line">    &quot;start&quot;: &quot;node index.js&quot;,</span><br><span class="line">    &quot;test&quot;: &quot;tap test/*.js&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-dependencies字段，devDependencies字段"><a href="#3-dependencies字段，devDependencies字段" class="headerlink" title="3. dependencies字段，devDependencies字段"></a>3. dependencies字段，devDependencies字段</h3><p>dependencies字段指定了项目运行所依赖的模块，devDependencies指定项目开发所需要的模块。</p><p>它们都指向一个对象。该对象的各个成员，分别由模块名和对应的版本要求组成，表示依赖的模块及其版本范围。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;browserify&quot;: &quot;~13.0.0&quot;,</span><br><span class="line">    &quot;karma-browserify&quot;: &quot;~5.0.1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的版本可以加上各种限定，主要有以下几种</p><blockquote><p>指定版本：比如1.2.2，遵循“大版本.次要版本.小版本”的格式规定，安装时只安装指定版本。<br>波浪号（tilde）+指定版本：比如~1.2.2，表示安装1.2.x的最新版本（不低于1.2.2），但是不安装1.3.x，也就是说安装时不改变大版本号和次要版本号。<br>插入号（caret）+指定版本：比如ˆ1.2.2，表示安装1.x.x的最新版本（不低于1.2.2），但是不安装2.x.x，也就是说安装时不改变大版本号。需要注意的是，如果大版本号为0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。<br>latest：安装最新版本。</p></blockquote><p>package.json文件可以手工编写，也可以使用npm init命令自动生成。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm init</span><br></pre></td></tr></table></figure><p>这个命令采用互动方式，要求用户回答一些问题，然后在当前目录生成一个基本的package.json文件。所有问题之中，只有项目名称（name）和项目版本（version）是必填的，其他都是选填的。</p><p>有了package.json文件，直接使用npm install命令，就会在当前目录中安装所需要的模块。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>如果一个模块不在package.json文件之中，可以单独安装这个模块，并使用相应的参数，将其写入package.json文件之中。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install express --save</span><br><span class="line">$ npm install express --save-dev</span><br></pre></td></tr></table></figure><p>上面代码表示单独安装express模块，–save参数表示将该模块写入dependencies属性，–save-dev表示将该模块写入devDependencies属性。</p><h3 id="4-peerDependencies"><a href="#4-peerDependencies" class="headerlink" title="4. peerDependencies"></a>4. peerDependencies</h3><p>有时，你的项目和所依赖的模块，都会同时依赖另一个模块，但是所依赖的版本不一样。比如，你的项目依赖A模块和B模块的1.0版，而A模块本身又依赖B模块的2.0版。</p><p>大多数情况下，这不构成问题，B模块的两个版本可以并存，同时运行。但是，有一种情况，会出现问题，就是这种依赖关系将暴露给用户。</p><p>最典型的场景就是插件，比如A模块是B模块的插件。用户安装的B模块是1.0版本，但是A插件只能和2.0版本的B模块一起使用。这时，用户要是将1.0版本的B的实例传给A，就会出现问题。因此，需要一种机制，在模板安装的时候提醒用户，如果A和B一起安装，那么B必须是2.0模块。</p><p>peerDependencies字段，就是用来供插件指定其所需要的主工具的版本。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;chai-as-promised&quot;,</span><br><span class="line">  &quot;peerDependencies&quot;: &#123;</span><br><span class="line">    &quot;chai&quot;: &quot;1.x&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码指定，安装chai-as-promised模块时，主程序chai必须一起安装，而且chai的版本必须是1.x。如果你的项目指定的依赖是chai的2.0版本，就会报错。</p><p>注意，从npm 3.0版开始，peerDependencies不再会默认安装了。</p><h3 id="5-bin字段"><a href="#5-bin字段" class="headerlink" title="5. bin字段"></a>5. bin字段</h3><p>bin项用来指定各个内部命令对应的可执行文件的位置。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;bin&quot;: &#123;</span><br><span class="line">  &quot;someTool&quot;: &quot;./bin/someTool.js&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码指定，someTool 命令对应的可执行文件为 bin 子目录下的 someTool.js。Npm会寻找这个文件，在node_modules/.bin/目录下建立符号链接。在上面的例子中，someTool.js会建立符号链接npm_modules/.bin/someTool。由于node_modules/.bin/目录会在运行时加入系统的PATH变量，因此在运行npm时，就可以不带路径，直接通过命令来调用这些脚本。</p><p>因此，像下面这样的写法可以采用简写。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scripts: &#123;  </span><br><span class="line">  start: &apos;./node_modules/someTool/someTool.js build&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 简写为</span><br><span class="line"></span><br><span class="line">scripts: &#123;  </span><br><span class="line">  start: &apos;someTool build&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有node_modules/.bin/目录下的命令，都可以用npm run [命令]的格式运行。在命令行下，键入npm run，然后按tab键，就会显示所有可以使用的命令。</p><h3 id="6-main字段"><a href="#6-main字段" class="headerlink" title="6. main字段"></a>6. main字段</h3><p>main字段指定了加载的入口文件，require(‘moduleName’)就会加载这个文件。这个字段的默认值是模块根目录下面的index.js。</p><h3 id="7-config-字段"><a href="#7-config-字段" class="headerlink" title="7. config 字段"></a>7. config 字段</h3><p>config字段用于添加命令行的环境变量。</p><p>下面是一个package.json文件。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot; : &quot;foo&quot;,</span><br><span class="line">  &quot;config&quot; : &#123; &quot;port&quot; : &quot;8080&quot; &#125;,</span><br><span class="line">  &quot;scripts&quot; : &#123; &quot;start&quot; : &quot;node server.js&quot; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在server.js脚本就可以引用config字段的值。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http</span><br><span class="line">  .createServer(...)</span><br><span class="line">  .listen(process.env.npm_package_config_port)</span><br></pre></td></tr></table></figure><p>用户执行npm run start命令时，这个脚本就可以得到值。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run start</span><br></pre></td></tr></table></figure><p>用户可以改变这个值。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm config set foo:port 80</span><br></pre></td></tr></table></figure><h3 id="8-其他"><a href="#8-其他" class="headerlink" title="8. 其他"></a>8. 其他</h3><h4 id="8-1-browser字段"><a href="#8-1-browser字段" class="headerlink" title="8.1 browser字段"></a>8.1 browser字段</h4><p>browser指定该模板供浏览器使用的版本。Browserify这样的浏览器打包工具，通过它就知道该打包那个文件。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;browser&quot;: &#123;</span><br><span class="line">  &quot;tipso&quot;: &quot;./node_modules/tipso/src/tipso.js&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><h4 id="8-1-engines-字段"><a href="#8-1-engines-字段" class="headerlink" title="8.1 engines 字段"></a>8.1 engines 字段</h4><p>engines字段指明了该模块运行的平台，比如 Node 的某个版本或者浏览器。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;engines&quot; : &#123; &quot;node&quot; : &quot;&gt;=0.10.3 &lt;0.12&quot; &#125; &#125;</span><br></pre></td></tr></table></figure><p>该字段也可以指定适用的npm版本。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;engines&quot; : &#123; &quot;npm&quot; : &quot;~1.0.20&quot; &#125; &#125;</span><br></pre></td></tr></table></figure><h4 id="8-3-man字段"><a href="#8-3-man字段" class="headerlink" title="8.3 man字段"></a>8.3 man字段</h4><p>man用来指定当前模块的man文档的位置。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;man&quot; :[ &quot;./doc/calc.1&quot; ]</span><br></pre></td></tr></table></figure><h4 id="8-4-preferGlobal字段"><a href="#8-4-preferGlobal字段" class="headerlink" title="8.4 preferGlobal字段"></a>8.4 preferGlobal字段</h4><p>preferGlobal的值是布尔值，表示当用户不将该模块安装为全局模块时（即不用–global参数），要不要显示警告，表示该模块的本意就是安装为全局模块。</p><h4 id="8-5-style字段"><a href="#8-5-style字段" class="headerlink" title="8.5 style字段"></a>8.5 style字段</h4><p>style指定供浏览器使用时，样式文件所在的位置。样式文件打包工具parcelify，通过它知道样式文件的打包位置。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;style&quot;: [</span><br><span class="line">  &quot;./node_modules/tipso/src/tipso.css&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      packagejson文件详解
    
    </summary>
    
      <category term="node" scheme="http://yoursite.com/categories/node/"/>
    
    
      <category term="配置" scheme="http://yoursite.com/tags/%E9%85%8D%E7%BD%AE/"/>
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
      <category term="package.json" scheme="http://yoursite.com/tags/package-json/"/>
    
  </entry>
  
  <entry>
    <title>React Router使用教程</title>
    <link href="http://yoursite.com/2019/07/13/React/router/"/>
    <id>http://yoursite.com/2019/07/13/React/router/</id>
    <published>2019-07-13T09:50:46.000Z</published>
    <updated>2019-07-13T15:13:59.504Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-Router使用教程"><a href="#React-Router使用教程" class="headerlink" title="React Router使用教程"></a>React Router使用教程</h1><h2 id="一、基本用法"><a href="#一、基本用法" class="headerlink" title="一、基本用法"></a>一、基本用法</h2><p>React Router 安装命令如下。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -S react-router</span><br></pre></td></tr></table></figure><p>使用时，路由器 Router 就是React的一个组件。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Router &#125; from &apos;react-router&apos;;</span><br><span class="line">render(&lt;Router/&gt;, document.getElementById(&apos;app&apos;));</span><br></pre></td></tr></table></figure><p>Router 组件本身只是一个容器，真正的路由要通过 Route 组件定义。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Router, Route, hashHistory &#125; from &apos;react-router&apos;;</span><br><span class="line"></span><br><span class="line">render((</span><br><span class="line">  &lt;Router history=&#123;hashHistory&#125;&gt;</span><br><span class="line">    &lt;Route path=&quot;/&quot; component=&#123;App&#125;/&gt;</span><br><span class="line">  &lt;/Router&gt;</span><br><span class="line">), document.getElementById(&apos;app&apos;));</span><br></pre></td></tr></table></figure><p>上面代码中，用户访问根路由 / （比如 <a href="http://www.example.com/" target="_blank" rel="noopener">http://www.example.com/</a> ），组件 APP 就会加载到 document.getElementById(‘app’) 。</p><p>你可能还注意到， Router 组件有一个参数 history ，它的值 hashHistory 表示，路由的切换由URL的hash变化决定，即URL的 # 部分发生变化。举例来说，用户访问 <a href="http://www.example.com/" target="_blank" rel="noopener">http://www.example.com/</a> ，实际会看到的是 <a href="http://www.example.com/#/" target="_blank" rel="noopener">http://www.example.com/#/</a> 。</p><p>Route 组件定义了URL路径与组件的对应关系。你可以同时使用多个 Route 组件。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router history=&#123;hashHistory&#125;&gt;</span><br><span class="line">  &lt;Route path=&quot;/&quot; component=&#123;App&#125;/&gt;</span><br><span class="line">  &lt;Route path=&quot;/repos&quot; component=&#123;Repos&#125;/&gt;</span><br><span class="line">  &lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt;</span><br><span class="line">&lt;/Router&gt;</span><br></pre></td></tr></table></figure><p>上面代码中，用户访问 /repos （比如 <a href="http://localhost:8080/#/repos" target="_blank" rel="noopener">http://localhost:8080/#/repos</a> ）时，加载 Repos 组件；访问 /about （ <a href="http://localhost:8080/#/about" target="_blank" rel="noopener">http://localhost:8080/#/about</a> ）时，加载 About 组件。</p><h2 id="二、嵌套路由"><a href="#二、嵌套路由" class="headerlink" title="二、嵌套路由"></a>二、嵌套路由</h2><p>Route 组件还可以嵌套。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router history=&#123;hashHistory&#125;&gt;</span><br><span class="line">  &lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt;</span><br><span class="line">  &lt;Route path=&quot;/repos&quot; component=&#123;Repos&#125;/&gt;</span><br><span class="line">    &lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt;</span><br><span class="line">  &lt;/Route&gt;</span><br><span class="line">&lt;/Router&gt;</span><br></pre></td></tr></table></figure><p>上面代码中，用户访问 /repos 时，会先加载 App 组件，然后在它的内部再加载 Repos 组件。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;App&gt;</span><br><span class="line">  &lt;Repos/&gt;</span><br><span class="line">&lt;/App&gt;</span><br></pre></td></tr></table></figure><p>App 组件要写成下面的样子。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export default React.createClass(&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &#123;this.props.children&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面代码中， App 组件的 this.props.children 属性就是子组件。</p><p>子路由也可以不写在 Router 组件里面，单独传入 Router 组件的 routes 属性。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let routes = &lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt;</span><br><span class="line">  &lt;Route path=&quot;/repos&quot; component=&#123;Repos&#125;/&gt;</span><br><span class="line">  &lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt;</span><br><span class="line">&lt;/Route&gt;;</span><br><span class="line"></span><br><span class="line">&lt;Router routes=&#123;routes&#125; history=&#123;browserHistory&#125;/&gt;</span><br></pre></td></tr></table></figure><h2 id="三、-path-属性"><a href="#三、-path-属性" class="headerlink" title="三、 path 属性"></a>三、 path 属性</h2><p>Route 组件的 path 属性指定路由的匹配规则。这个属性是可以省略的，这样的话，不管路径是否匹配，总是会加载指定组件。</p><p>请看下面的例子。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&quot;inbox&quot; component=&#123;Inbox&#125;&gt;</span><br><span class="line">   &lt;Route path=&quot;messages/:id&quot; component=&#123;Message&#125; /&gt;</span><br><span class="line">&lt;/Route&gt;</span><br></pre></td></tr></table></figure><p>上面代码中，当用户访问 /inbox/messages/:id 时，会加载下面的组件。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Inbox&gt;</span><br><span class="line">  &lt;Message/&gt;</span><br><span class="line">&lt;/Inbox&gt;</span><br></pre></td></tr></table></figure><p>如果省略外层 Route 的 path 参数，写成下面的样子。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route component=&#123;Inbox&#125;&gt;</span><br><span class="line">  &lt;Route path=&quot;inbox/messages/:id&quot; component=&#123;Message&#125; /&gt;</span><br><span class="line">&lt;/Route&gt;</span><br></pre></td></tr></table></figure><p>现在用户访问 /inbox/messages/:id 时，组件加载还是原来的样子。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Inbox&gt;</span><br><span class="line">  &lt;Message/&gt;</span><br><span class="line">&lt;/Inbox&gt;</span><br></pre></td></tr></table></figure><h2 id="四、通配符"><a href="#四、通配符" class="headerlink" title="四、通配符"></a>四、通配符</h2><p>path 属性可以使用通配符。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&quot;/hello/:name&quot;&gt;</span><br><span class="line">// 匹配 /hello/michael</span><br><span class="line">// 匹配 /hello/ryan</span><br><span class="line"></span><br><span class="line">&lt;Route path=&quot;/hello(/:name)&quot;&gt;</span><br><span class="line">// 匹配 /hello</span><br><span class="line">// 匹配 /hello/michael</span><br><span class="line">// 匹配 /hello/ryan</span><br><span class="line"></span><br><span class="line">&lt;Route path=&quot;/files/*.*&quot;&gt;</span><br><span class="line">// 匹配 /files/hello.jpg</span><br><span class="line">// 匹配 /files/hello.html</span><br><span class="line"></span><br><span class="line">&lt;Route path=&quot;/files/*&quot;&gt;</span><br><span class="line">// 匹配 /files/</span><br><span class="line">// 匹配 /files/a</span><br><span class="line">// 匹配 /files/a/b</span><br><span class="line"></span><br><span class="line">&lt;Route path=&quot;/**/*.jpg&quot;&gt;</span><br><span class="line">// 匹配 /files/hello.jpg</span><br><span class="line">// 匹配 /files/path/to/file.jpg</span><br></pre></td></tr></table></figure><p>通配符的规则如下。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">（1） :paramName</span><br><span class="line"></span><br><span class="line">:paramName 匹配URL的一个部分，直到遇到下一个 / 、 ? 、 # 为止。这个路径参数可以通过 this.props.params.paramName 取出。</span><br><span class="line"></span><br><span class="line">（2） ()</span><br><span class="line"></span><br><span class="line">() 表示URL的这个部分是可选的。</span><br><span class="line"></span><br><span class="line">（3） *</span><br><span class="line"></span><br><span class="line">* 匹配任意字符，直到模式里面的下一个字符为止。匹配方式是非贪婪模式。</span><br><span class="line"></span><br><span class="line">（4） **</span><br><span class="line"></span><br><span class="line">** 匹配任意字符，直到下一个 / 、 ? 、 # 为止。匹配方式是贪婪模式。</span><br></pre></td></tr></table></figure></p><p>path 属性也可以使用相对路径（不以 / 开头），匹配时就会相对于父组件的路径，可以参考上一节的例子。嵌套路由如果想摆脱这个规则，可以使用绝对路由。</p><p>路由匹配规则是从上到下执行，一旦发现匹配，就不再其余的规则了。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&quot;/comments&quot; ... /&gt;</span><br><span class="line">&lt;Route path=&quot;/comments&quot; ... /&gt;</span><br></pre></td></tr></table></figure><p>上面代码中，路径 /comments 同时匹配两个规则，第二个规则不会生效。</p><p>设置路径参数时，需要特别小心这一点。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router&gt;</span><br><span class="line">  &lt;Route path=&quot;/:userName/:id&quot; component=&#123;UserPage&#125;/&gt;</span><br><span class="line">  &lt;Route path=&quot;/about/me&quot; component=&#123;About&#125;/&gt;</span><br><span class="line">&lt;/Router&gt;</span><br></pre></td></tr></table></figure><p>上面代码中，用户访问 /about/me 时，不会触发第二个路由规则，因为它会匹配 /:userName/:id 这个规则。因此，带参数的路径一般要写在路由规则的底部。</p><p>此外，URL的查询字符串 /foo?bar=baz ，可以用 this.props.location.query.bar 获取。</p><h2 id="五、IndexRoute-组件"><a href="#五、IndexRoute-组件" class="headerlink" title="五、IndexRoute 组件"></a>五、IndexRoute 组件</h2><p>下面的例子，你会不会觉得有一点问题？</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router&gt;</span><br><span class="line">  &lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt;</span><br><span class="line">    &lt;Route path=&quot;accounts&quot; component=&#123;Accounts&#125;/&gt;</span><br><span class="line">    &lt;Route path=&quot;statements&quot; component=&#123;Statements&#125;/&gt;</span><br><span class="line">  &lt;/Route&gt;</span><br><span class="line">&lt;/Router&gt;</span><br></pre></td></tr></table></figure><p>上面代码中，访问根路径 / ，不会加载任何子组件。也就是说， App 组件的 this.props.children ，这时是 undefined 。</p><p>因此，通常会采用 {this.props.children || &lt;Home/&gt;} 这样的写法。这时， Home 明明是 Accounts 和 Statements 的同级组件，却没有写在 Route 中。</p><p>IndexRoute 就是解决这个问题，显式指定 Home 是根路由的子组件，即指定默认情况下加载的子组件。你可以把 IndexRoute 想象成某个路径的 index.html 。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router&gt;</span><br><span class="line">  &lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt;</span><br><span class="line">    &lt;IndexRoute component=&#123;Home&#125;/&gt;</span><br><span class="line">    &lt;Route path=&quot;accounts&quot; component=&#123;Accounts&#125;/&gt;</span><br><span class="line">    &lt;Route path=&quot;statements&quot; component=&#123;Statements&#125;/&gt;</span><br><span class="line">  &lt;/Route&gt;</span><br><span class="line">&lt;/Router&gt;</span><br></pre></td></tr></table></figure><p>现在，用户访问 / 的时候，加载的组件结构如下。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;App&gt;</span><br><span class="line">  &lt;Home/&gt;</span><br><span class="line">&lt;/App&gt;</span><br></pre></td></tr></table></figure><p>这种组件结构就很清晰了： App 只包含下级组件的共有元素，本身的展示内容则由 Home 组件定义。这样有利于代码分离，也有利于使用React Router提供的各种API。</p><p>注意， IndexRoute 组件没有路径参数 path 。</p><h2 id="六、Redirect-组件"><a href="#六、Redirect-组件" class="headerlink" title="六、Redirect 组件"></a>六、Redirect 组件</h2><p><redirect> 组件用于路由的跳转，即用户访问一个路由，会自动跳转到另一个路由。</redirect></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&quot;inbox&quot; component=&#123;Inbox&#125;&gt;</span><br><span class="line">   &#123;/* 从 /inbox/messages/:id 跳转到 /messages/:id */&#125;</span><br><span class="line">   &lt;Redirect from=&quot;messages/:id&quot; to=&quot;/messages/:id&quot; /&gt;</span><br><span class="line">&lt;/Route&gt;</span><br></pre></td></tr></table></figure><p>现在访问 /inbox/messages/5 ，会自动跳转到 /messages/5 。</p><h2 id="七、IndexRedirect-组件"><a href="#七、IndexRedirect-组件" class="headerlink" title="七、IndexRedirect 组件"></a>七、IndexRedirect 组件</h2><p>IndexRedirect 组件用于访问根路由的时候，将用户重定向到某个子组件。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt;</span><br><span class="line">  &lt;IndexRedirect to=&quot;/welcome&quot; /&gt;</span><br><span class="line">  &lt;Route path=&quot;welcome&quot; component=&#123;Welcome&#125; /&gt;</span><br><span class="line">  &lt;Route path=&quot;about&quot; component=&#123;About&#125; /&gt;</span><br><span class="line">&lt;/Route&gt;</span><br></pre></td></tr></table></figure><p>上面代码中，用户访问根路径时，将自动重定向到子组件 welcome 。</p><h2 id="八、Link"><a href="#八、Link" class="headerlink" title="八、Link"></a>八、Link</h2><p>Link 组件用于取代 a标签，生成一个链接，允许用户点击后跳转到另一个路由。它基本上就是 a标签的React 版本，可以接收 Router 的状态。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  return &lt;div&gt;</span><br><span class="line">    &lt;ul role=&quot;nav&quot;&gt;</span><br><span class="line">      &lt;li&gt;&lt;Link to=&quot;/about&quot;&gt;About&lt;/Link&gt;&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;&lt;Link to=&quot;/repos&quot;&gt;Repos&lt;/Link&gt;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果希望当前的路由与其他路由有不同样式，这时可以使用 Link 组件的 activeStyle 属性。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=&quot;/about&quot; activeStyle=&#123;&#123;color: &apos;red&apos;&#125;&#125;&gt;About&lt;/Link&gt;</span><br><span class="line">&lt;Link to=&quot;/repos&quot; activeStyle=&#123;&#123;color: &apos;red&apos;&#125;&#125;&gt;Repos&lt;/Link&gt;</span><br></pre></td></tr></table></figure><p>上面代码中，当前页面的链接会红色显示。</p><p>另一种做法是，使用 activeClassName 指定当前路由的 Class 。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=&quot;/about&quot; activeClassName=&quot;active&quot;&gt;About&lt;/Link&gt;</span><br><span class="line">&lt;Link to=&quot;/repos&quot; activeClassName=&quot;active&quot;&gt;Repos&lt;/Link&gt;</span><br></pre></td></tr></table></figure><p>上面代码中，当前页面的链接的 class 会包含 active 。</p><p>在 Router 组件之外，导航到路由页面，可以使用浏览器的History API，像下面这样写。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; browserHistory &#125; from &apos;react-router&apos;;</span><br><span class="line">browserHistory.push(&apos;/some/path&apos;);</span><br></pre></td></tr></table></figure><h2 id="九、IndexLink"><a href="#九、IndexLink" class="headerlink" title="九、IndexLink"></a>九、IndexLink</h2><p>如果链接到根路由 / ，不要使用 Link 组件，而要使用 IndexLink 组件。</p><p>这是因为对于根路由来说， activeStyle 和 activeClassName 会失效，或者说总是生效，因为 / 会匹配任何子路由。而 IndexLink 组件会使用路径的精确匹配。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;IndexLink to=&quot;/&quot; activeClassName=&quot;active&quot;&gt;</span><br><span class="line">  Home</span><br><span class="line">&lt;/IndexLink&gt;</span><br></pre></td></tr></table></figure></p><p>上面代码中，根路由只会在精确匹配时，才具有 activeClassName 。</p><p>另一种方法是使用 Link 组件的 onlyActiveOnIndex 属性，也能达到同样效果。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=&quot;/&quot; activeClassName=&quot;active&quot; onlyActiveOnIndex=&#123;true&#125;&gt;</span><br><span class="line">  Home</span><br><span class="line">&lt;/Link&gt;</span><br></pre></td></tr></table></figure><p>实际上， IndexLink 就是对 Link 组件的 onlyActiveOnIndex 属性的包装。</p><h2 id="十、histroy-属性"><a href="#十、histroy-属性" class="headerlink" title="十、histroy 属性"></a>十、histroy 属性</h2><p>Router 组件的 history 属性，用来监听浏览器地址栏的变化，并将URL解析成一个地址对象，供 React Router 匹配。</p><p>history 属性，一共可以设置三种值。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">browserHistory</span><br><span class="line">hashHistory</span><br><span class="line">createMemoryHistory</span><br></pre></td></tr></table></figure></p><p>如果设为 hashHistory ，路由将通过URL的hash部分（ # ）切换，URL的形式类似 example.com/#/some/path 。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; hashHistory &#125; from &apos;react-router&apos;</span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  &lt;Router history=&#123;hashHistory&#125; routes=&#123;routes&#125; /&gt;,</span><br><span class="line">  document.getElementById(&apos;app&apos;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如果设为 browserHistory ，浏览器的路由就不再通过 Hash 完成了，而显示正常的路径 example.com/some/path ，背后调用的是浏览器的History API。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; browserHistory &#125; from &apos;react-router&apos;</span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  &lt;Router history=&#123;browserHistory&#125; routes=&#123;routes&#125; /&gt;,</span><br><span class="line">  document.getElementById(&apos;app&apos;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>但是，这种情况需要对 服务器改造 。否则用户直接向服务器请求某个子路由，会显示网页找不到的404错误。</p><p>如果开发服务器使用的是 webpack-dev-server ，加上 –history-api-fallback 参数就可以了。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ webpack-dev-server --inline --content-base . --history-api-fallback</span><br><span class="line"></span><br><span class="line">createMemoryHistory 主要用于服务器渲染。它创建一个内存中的 history 对象，不与浏览器URL互动。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const history = createMemoryHistory(location)</span><br></pre></td></tr></table></figure><h2 id="十一、表单处理"><a href="#十一、表单处理" class="headerlink" title="十一、表单处理"></a>十一、表单处理</h2><p>Link 组件用于正常的用户点击跳转，但是有时还需要表单跳转、点击按钮跳转等操作。这些情况怎么跟React Router对接呢？</p><p>下面是一个表单。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; placeholder=&quot;userName&quot;/&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; placeholder=&quot;repo&quot;/&gt;</span><br><span class="line">  &lt;button type=&quot;submit&quot;&gt;Go&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>第一种方法是使用 browserHistory.push</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; browserHistory &#125; from &apos;react-router&apos;</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    event.preventDefault()</span><br><span class="line">    const userName = event.target.elements[0].value</span><br><span class="line">    const repo = event.target.elements[1].value</span><br><span class="line">    const path = `/repos/$&#123;userName&#125;/$&#123;repo&#125;`</span><br><span class="line">    browserHistory.push(path)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>第二种方法是使用 context 对象。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">export default React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">  // ask for `router` from context</span><br><span class="line">  contextTypes: &#123;</span><br><span class="line">    router: React.PropTypes.object</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    // ...</span><br><span class="line">    this.context.router.push(path)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="十二、路由的钩子"><a href="#十二、路由的钩子" class="headerlink" title="十二、路由的钩子"></a>十二、路由的钩子</h2><p>每个路由都有 Enter 和 Leave 钩子，用户进入或离开该路由时触发。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&quot;about&quot; component=&#123;About&#125; /&gt;</span><br><span class="line">&lt;Route path=&quot;inbox&quot; component=&#123;Inbox&#125;&gt;</span><br><span class="line">  &lt;Redirect from=&quot;messages/:id&quot; to=&quot;/messages/:id&quot; /&gt;</span><br><span class="line">&lt;/Route&gt;</span><br></pre></td></tr></table></figure><p>上面的代码中，如果用户离开 /messages/:id ，进入 /about 时，会依次触发以下的钩子。</p><p>/messages/:id 的 onLeave<br>/inbox 的 onLeave<br>/about 的 onEnter<br>下面是一个例子，使用 onEnter 钩子替代 <redirect> 组件。</redirect></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&quot;inbox&quot; component=&#123;Inbox&#125;&gt;</span><br><span class="line">  &lt;Route</span><br><span class="line">    path=&quot;messages/:id&quot;</span><br><span class="line">    onEnter=&#123;</span><br><span class="line">      (&#123;params&#125;, replace) =&gt; replace(`/messages/$&#123;params.id&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">  /&gt;</span><br><span class="line">&lt;/Route&gt;</span><br></pre></td></tr></table></figure><p>下面是一个高级应用，当用户离开一个路径的时候，跳出一个提示框，要求用户确认是否离开。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const Home = withRouter(</span><br><span class="line">  React.createClass(&#123;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      this.props.router.setRouteLeaveHook(</span><br><span class="line">        this.props.route,</span><br><span class="line">        this.routerWillLeave</span><br><span class="line">      )</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    routerWillLeave(nextLocation) &#123;</span><br><span class="line">      // 返回 false 会继续停留当前页面，</span><br><span class="line">      // 否则，返回一个字符串，会显示给用户，让其自己决定</span><br><span class="line">      if (!this.state.isSaved)</span><br><span class="line">        return &apos;确认要离开？&apos;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>上面代码中， setRouteLeaveHook 方法为 Leave 钩子指定 routerWillLeave 函数。该方法如果返回 false ，将阻止路由的切换，否则就返回一个字符串，提示用户决定是否要切换。</p>]]></content>
    
    <summary type="html">
    
      React Router使用教程
    
    </summary>
    
      <category term="react" scheme="http://yoursite.com/categories/react/"/>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
      <category term="router" scheme="http://yoursite.com/tags/router/"/>
    
      <category term="路由" scheme="http://yoursite.com/tags/%E8%B7%AF%E7%94%B1/"/>
    
  </entry>
  
  <entry>
    <title>webpack项目搭建</title>
    <link href="http://yoursite.com/2019/07/13/React/webpack/"/>
    <id>http://yoursite.com/2019/07/13/React/webpack/</id>
    <published>2019-07-13T09:50:46.000Z</published>
    <updated>2019-07-13T09:50:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="webpack项目搭建"><a href="#webpack项目搭建" class="headerlink" title="webpack项目搭建"></a>webpack项目搭建</h1><h3 id="什么是-webpack？"><a href="#什么是-webpack？" class="headerlink" title="什么是 webpack？"></a>什么是 webpack？</h3><p>webpack是近期最火的一款模块加载器兼打包工具，它能把各种资源，例如JS（含JSX）、coffee、样式（含less/sass）、图片等都作为模块来使用和处理。<br>我们可以直接使用 require(XXX) 的形式来引入各模块，即使它们可能需要经过编译（比如JSX和sass），但我们无须在上面花费太多心思，因为 webpack 有着各种健全的加载器（loader）在默默处理这些事情，这块我们后续会提到。<br>你可以不打算将其用在你的项目上，但没有理由不去掌握它，因为以近期 Github 上各大主流的（React相关）项目来说，它们仓库上所展示的示例已经是基于 webpack 来开发的，比如 React-Boostrap 和 Redux。<br>webpack的官网是 <a href="http://webpack.github.io/" target="_blank" rel="noopener">http://webpack.github.io/</a> ，文档地址是 <a href="http://webpack.github.io/docs/" target="_blank" rel="noopener">http://webpack.github.io/docs/</a> ，想对其进行更详细了解的可以点进去瞧一瞧。</p><h3 id="webpack-的优势"><a href="#webpack-的优势" class="headerlink" title="webpack 的优势"></a>webpack 的优势</h3><p>其优势主要可以归类为如下几个：</p><ol><li>webpack 是以 commonJS 的形式来书写脚本滴，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移。</li><li>能被模块化的不仅仅是 JS 了。</li><li>开发便捷，能替代部分 grunt/gulp 的工作，比如打包、压缩混淆、图片转base64等。</li><li>扩展性强，插件机制完善，特别是支持 React 热插拔（见 react-hot-loader ）的功能让人眼前一亮。<br>我们谈谈第一点。以 AMD/CMD 模式来说，鉴于模块是异步加载的，所以我们常规需要使用 define 函数来帮我们搞回调：<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define([&apos;package/lib&apos;], function(lib)&#123;</span><br><span class="line">    function foo()&#123;</span><br><span class="line">        lib.log(&apos;hello world!&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">        foo: foo</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><p>另外为了可以兼容 commonJS 的写法，我们也可以将 define 这么写：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">define(function (require, exports, module)&#123;</span><br><span class="line">    var someModule = require(&quot;someModule&quot;);</span><br><span class="line">    var anotherModule = require(&quot;anotherModule&quot;);    </span><br><span class="line"></span><br><span class="line">    someModule.doTehAwesome();</span><br><span class="line">    anotherModule.doMoarAwesome();</span><br><span class="line"></span><br><span class="line">    exports.asplode = function ()&#123;</span><br><span class="line">        someModule.doTehAwesome();</span><br><span class="line">        anotherModule.doMoarAwesome();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>然而对 webpack 来说，我们可以直接在上面书写 commonJS 形式的语法，无须任何 define （毕竟最终模块都打包在一起，webpack 也会最终自动加上自己的加载器）：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var someModule = require(&quot;someModule&quot;);</span><br><span class="line">    var anotherModule = require(&quot;anotherModule&quot;);    </span><br><span class="line"></span><br><span class="line">    someModule.doTehAwesome();</span><br><span class="line">    anotherModule.doMoarAwesome();</span><br><span class="line"></span><br><span class="line">    exports.asplode = function ()&#123;</span><br><span class="line">        someModule.doTehAwesome();</span><br><span class="line">        anotherModule.doMoarAwesome();</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>这样撸码自然更简单，跟回调神马的说 byebye~<br>不过即使你保留了之前 define 的写法也是可以滴，毕竟 webpack 的兼容性相当出色，方便你旧项目的模块直接迁移过来。</p><h3 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h3><h5 id="一-安装"><a href="#一-安装" class="headerlink" title="一. 安装"></a>一. 安装</h5><p>我们常规直接使用 npm 的形式来安装：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install webpack -g</span><br></pre></td></tr></table></figure></p><p>当然如果常规项目还是把依赖写入 package.json 包去更人性化：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm init</span><br><span class="line">$ npm install webpack --save-dev</span><br></pre></td></tr></table></figure></p><h5 id="二-配置"><a href="#二-配置" class="headerlink" title="二. 配置"></a>二. 配置</h5><p>每个项目下都必须配置有一个 webpack.config.js ，它的作用如同常规的 gulpfile.js/Gruntfile.js ，就是一个配置项，告诉 webpack 它需要做什么。<br>我们看看下方的示例：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">var webpack = require(&apos;webpack&apos;);</span><br><span class="line">var commonsPlugin = new webpack.optimize.CommonsChunkPlugin(&apos;common.js&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //插件项</span><br><span class="line">    plugins: [commonsPlugin],</span><br><span class="line">    //页面入口文件配置</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index : &apos;./src/js/page/index.js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    //入口文件输出配置</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: &apos;dist/js/page&apos;,</span><br><span class="line">        filename: &apos;[name].js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        //加载器配置</span><br><span class="line">        loaders: [</span><br><span class="line">            &#123; test: /\.css$/, loader: &apos;style-loader!css-loader&apos; &#125;,</span><br><span class="line">            &#123; test: /\.js$/, loader: &apos;jsx-loader?harmony&apos; &#125;,</span><br><span class="line">            &#123; test: /\.scss$/, loader: &apos;style!css!sass?sourceMap&apos;&#125;,</span><br><span class="line">            &#123; test: /\.(png|jpg)$/, loader: &apos;url-loader?limit=8192&apos;&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    //其它解决方案配置</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        root: &apos;E:/github/flux-example/src&apos;, //绝对路径</span><br><span class="line">        extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.json&apos;, &apos;.scss&apos;],</span><br><span class="line">        alias: &#123;</span><br><span class="line">            AppStore : &apos;js/stores/AppStores.js&apos;,</span><br><span class="line">            ActionType : &apos;js/actions/ActionType.js&apos;,</span><br><span class="line">            AppAction : &apos;js/actions/AppAction.js&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>⑴ plugins 是插件项，这里我们使用了一个 CommonsChunkPlugin 的插件，它用于提取多个入口文件的公共脚本部分，然后生成一个 common.js 来方便多页面之间进行复用。<br>⑵ entry 是页面入口文件配置，output 是对应输出项配置（即入口文件最终要生成什么名字的文件、存放到哪里），其语法大致为：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        page1: &quot;./page1&quot;,</span><br><span class="line">        //支持数组形式，将加载数组中的所有模块，但以最后一个模块作为输出</span><br><span class="line">        page2: [&quot;./entry1&quot;, &quot;./entry2&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: &quot;dist/js/page&quot;,</span><br><span class="line">        filename: &quot;[name].bundle.js&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该段代码最终会生成一个 page1.bundle.js 和 page2.bundle.js，并存放到 ./dist/js/page 文件夹下。<br>⑶ module.loaders 是最关键的一块配置。它告知 webpack 每一种文件都需要使用什么加载器来处理：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">        //加载器配置</span><br><span class="line">        loaders: [</span><br><span class="line">            //.css 文件使用 style-loader 和 css-loader 来处理</span><br><span class="line">            &#123; test: /\.css$/, loader: &apos;style-loader!css-loader&apos; &#125;,</span><br><span class="line">            //.js 文件使用 jsx-loader 来编译处理</span><br><span class="line">            &#123; test: /\.js$/, loader: &apos;jsx-loader?harmony&apos; &#125;,</span><br><span class="line">            //.scss 文件使用 style-loader、css-loader 和 sass-loader 来编译处理</span><br><span class="line">            &#123; test: /\.scss$/, loader: &apos;style!css!sass?sourceMap&apos;&#125;,</span><br><span class="line">            //图片文件使用 url-loader 来处理，小于8kb的直接转为base64</span><br><span class="line">            &#123; test: /\.(png|jpg)$/, loader: &apos;url-loader?limit=8192&apos;&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>如上，”-loader”其实是可以省略不写的，多个loader之间用“!”连接起来。<br>注意所有的加载器都需要通过 npm 来加载，并建议查阅它们对应的 readme 来看看如何使用。<br>拿最后一个 url-loader 来说，它会将样式中引用到的图片转为模块来处理，使用该加载器需要先进行安装：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install url-loader -save-dev</span><br></pre></td></tr></table></figure></p><p>配置信息的参数“?limit=8192”表示将所有小于8kb的图片都转为base64形式（其实应该说超过8kb的才使用 url-loader 来映射到文件，否则转为data url形式）。<br>⑷ 最后是 resolve 配置，这块很好理解，直接写注释了：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">        //查找module的话从这里开始查找</span><br><span class="line">        root: &apos;E:/github/flux-example/src&apos;, //绝对路径</span><br><span class="line">        //自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名</span><br><span class="line">        extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.json&apos;, &apos;.scss&apos;],</span><br><span class="line">        //模块别名定义，方便后续直接引用别名，无须多写长长的地址</span><br><span class="line">        alias: &#123;</span><br><span class="line">            AppStore : &apos;js/stores/AppStores.js&apos;,//后续直接 require(&apos;AppStore&apos;) 即可</span><br><span class="line">            ActionType : &apos;js/actions/ActionType.js&apos;,</span><br><span class="line">            AppAction : &apos;js/actions/AppAction.js&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>关于 webpack.config.js 更详尽的配置可以参考这里。<br>运行 webpack<br>webpack 的执行也很简单，直接执行<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ webpack --display-error-details</span><br></pre></td></tr></table></figure></p><p>即可，后面的参数“–display-error-details”是推荐加上的，方便出错时能查阅更详尽的信息（比如 webpack 寻找模块的过程），从而更好定位到问题。<br>其他主要的参数有：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ webpack --config XXX.js   //使用另一份配置文件（比如webpack.config2.js）来打包</span><br><span class="line"></span><br><span class="line">$ webpack --watch   //监听变动并自动打包</span><br><span class="line"></span><br><span class="line">$ webpack -p    //压缩混淆脚本，这个非常非常重要！</span><br><span class="line"></span><br><span class="line">$ webpack -d    //生成map映射文件，告知哪些模块被最终打包到哪里了</span><br></pre></td></tr></table></figure></p><p>其中的 -p 是很重要的参数，曾经一个未压缩的 700kb 的文件，压缩后直接降到 180kb（主要是样式这块一句就独占一行脚本，导致未压缩脚本变得很大）。</p><h3 id="模块引入"><a href="#模块引入" class="headerlink" title="模块引入"></a>模块引入</h3><p>上面唠嗑了那么多配置和执行方法，下面开始说说寻常页面和脚本怎么使用呗。</p><h5 id="一-HTML"><a href="#一-HTML" class="headerlink" title="一. HTML"></a>一. HTML</h5><p>直接在页面引入 webpack 最终生成的页面脚本即可，不用再写什么 data-main 或 seajs.use 了：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;demo&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;script src=&quot;dist/js/page/common.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script src=&quot;dist/js/page/index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>可以看到我们连样式都不用引入，毕竟脚本执行时会动态生成<style>并标签打到head里。</p><h5 id="二-JS"><a href="#二-JS" class="headerlink" title="二. JS"></a>二. JS</h5><p>各脚本模块可以直接使用 commonJS 来书写，并可以直接引入未经编译的模块，比如 JSX、sass、coffee等（只要你在 webpack.config.js 里配置好了对应的加载器）。<br>我们再看看编译前的页面入口文件（index.js）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">require(&apos;../../css/reset.scss&apos;); //加载初始化样式</span><br><span class="line">require(&apos;../../css/allComponent.scss&apos;); //加载组件样式</span><br><span class="line">var React = require(&apos;react&apos;);</span><br><span class="line">var AppWrap = require(&apos;../component/AppWrap&apos;); //加载组件</span><br><span class="line">var createRedux = require(&apos;redux&apos;).createRedux;</span><br><span class="line">var Provider = require(&apos;redux/react&apos;).Provider;</span><br><span class="line">var stores = require(&apos;AppStore&apos;);</span><br><span class="line"></span><br><span class="line">var redux = createRedux(stores);</span><br><span class="line"></span><br><span class="line">var App = React.createClass(&#123;</span><br><span class="line">    render: function() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;Provider redux=&#123;redux&#125;&gt;</span><br><span class="line">                &#123;function() &#123; return &lt;AppWrap /&gt;; &#125;&#125;</span><br><span class="line">            &lt;/Provider&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">React.render(</span><br><span class="line">    &lt;App /&gt;, document.body</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>一切就是这么简单么么哒~ 后续各种有的没的，webpack 都会帮你进行处理。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>至此我们已经基本上手了 webpack 的使用，下面是补充一些有用的技巧。</p><h5 id="一-shimming"><a href="#一-shimming" class="headerlink" title="一. shimming"></a>一. shimming</h5><p>在 AMD/CMD 中，我们需要对不符合规范的模块（比如一些直接返回全局变量的插件）进行 shim 处理，这时候我们需要使用 exports-loader 来帮忙：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; test: require.resolve(&quot;./src/js/tool/swipe.js&quot;),  loader: &quot;exports?swipe&quot;&#125;</span><br></pre></td></tr></table></figure></p><p>之后在脚本中需要引用该模块的时候，这么简单地来使用就可以了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">require(&apos;./tool/swipe.js&apos;);</span><br><span class="line">swipe();</span><br></pre></td></tr></table></figure></p><h5 id="二-自定义公共模块提取"><a href="#二-自定义公共模块提取" class="headerlink" title="二. 自定义公共模块提取"></a>二. 自定义公共模块提取</h5><p>在文章开始我们使用了 CommonsChunkPlugin 插件来提取多个页面之间的公共模块，并将该模块打包为 common.js 。<br>但有时候我们希望能更加个性化一些，我们可以这样配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var CommonsChunkPlugin = require(&quot;webpack/lib/optimize/CommonsChunkPlugin&quot;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        p1: &quot;./page1&quot;,</span><br><span class="line">        p2: &quot;./page2&quot;,</span><br><span class="line">        p3: &quot;./page3&quot;,</span><br><span class="line">        ap1: &quot;./admin/page1&quot;,</span><br><span class="line">        ap2: &quot;./admin/page2&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &quot;[name].js&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new CommonsChunkPlugin(&quot;admin-commons.js&quot;, [&quot;ap1&quot;, &quot;ap2&quot;]),</span><br><span class="line">        new CommonsChunkPlugin(&quot;commons.js&quot;, [&quot;p1&quot;, &quot;p2&quot;, &quot;admin-commons.js&quot;])</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line">// &lt;script&gt;s required:</span><br><span class="line">// page1.html: commons.js, p1.js</span><br><span class="line">// page2.html: commons.js, p2.js</span><br><span class="line">// page3.html: p3.js</span><br><span class="line">// admin-page1.html: commons.js, admin-commons.js, ap1.js</span><br><span class="line">// admin-page2.html: commons.js, admin-commons.js, ap2.js</span><br></pre></td></tr></table></figure></p><h5 id="三-独立打包样式文件"><a href="#三-独立打包样式文件" class="headerlink" title="三. 独立打包样式文件"></a>三. 独立打包样式文件</h5><p>有时候可能希望项目的样式能不要被打包到脚本中，而是独立出来作为.css，然后在页面中以<link>标签引入。这时候我们需要 extract-text-webpack-plugin 来帮忙：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var webpack = require(&apos;webpack&apos;);</span><br><span class="line">    var commonsPlugin = new webpack.optimize.CommonsChunkPlugin(&apos;common.js&apos;);</span><br><span class="line">    var ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);</span><br><span class="line"></span><br><span class="line">    module.exports = &#123;</span><br><span class="line">        plugins: [commonsPlugin, new ExtractTextPlugin(&quot;[name].css&quot;)],</span><br><span class="line">        entry: &#123;</span><br><span class="line">        //...省略其它配置</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>最终 webpack 执行后会乖乖地把样式文件提取出来：</p><h5 id="四-使用CDN-远程文件"><a href="#四-使用CDN-远程文件" class="headerlink" title="四. 使用CDN/远程文件"></a>四. 使用CDN/远程文件</h5><p>有时候我们希望某些模块走CDN并以<script>的形式挂载到页面上来加载，但又希望能在 webpack 的模块中使用上。<br>这时候我们可以在配置文件里使用 externals 属性来帮忙：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    externals: &#123;</span><br><span class="line">        // require(&quot;jquery&quot;) 是引用自外部模块的</span><br><span class="line">        // 对应全局变量 jQuery</span><br><span class="line">        &quot;jquery&quot;: &quot;jQuery&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要留意的是，得确保 CDN 文件必须在 webpack 打包文件引入之前先引入。<br>我们倒也可以使用 script.js 在脚本中来加载我们的模块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var $script = require(&quot;scriptjs&quot;);</span><br><span class="line">$script(&quot;//ajax.googleapis.com/ajax/libs/jquery/2.0.0/jquery.min.js&quot;, function() &#123;</span><br><span class="line">  $(&apos;body&apos;).html(&apos;It works!&apos;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h5 id="五-与-grunt-gulp-配合"><a href="#五-与-grunt-gulp-配合" class="headerlink" title="五. 与 grunt/gulp 配合"></a>五. 与 grunt/gulp 配合</h5><p>以 gulp 为示例，我们可以这样混搭：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(&quot;webpack&quot;, function(callback) &#123;</span><br><span class="line">    // run webpack</span><br><span class="line">    webpack(&#123;</span><br><span class="line">        // configuration</span><br><span class="line">    &#125;, function(err, stats) &#123;</span><br><span class="line">        if(err) throw new gutil.PluginError(&quot;webpack&quot;, err);</span><br><span class="line">        gutil.log(&quot;[webpack]&quot;, stats.toString(&#123;</span><br><span class="line">            // output options</span><br><span class="line">        &#125;));</span><br><span class="line">        callback();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>当然我们只需要把配置写到 webpack({ … }) 中去即可，无须再写 webpack.config.js 了。<br>更多参照信息请参阅：grunt配置 / gulp配置 。</p><h5 id="六-React-相关"><a href="#六-React-相关" class="headerlink" title="六. React 相关"></a>六. React 相关</h5><p>⑴ 推荐使用 npm install react 的形式来安装并引用 React 模块，而不是直接使用编译后的 react.js，这样最终编译出来的 React 部分的脚本会减少 10-20 kb左右的大小。<br>⑵ react-hot-loader 是一款非常好用的 React 热插拔的加载插件，通过它可以实现修改-运行同步的效果，配合 webpack-dev-server 使用更佳！</p></style></p>]]></content>
    
    <summary type="html">
    
      ebpack是近期最火的一款模块加载器兼打包工具，它能把各种资源，例如JS（含JSX）、coffee、样式（含less/sass）、图片等都作为模块来使用和处理。
    
    </summary>
    
      <category term="webpack" scheme="http://yoursite.com/categories/webpack/"/>
    
    
      <category term="项目搭建" scheme="http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"/>
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Redux使用入门</title>
    <link href="http://yoursite.com/2019/07/13/React/redux/"/>
    <id>http://yoursite.com/2019/07/13/React/redux/</id>
    <published>2019-07-13T09:50:46.000Z</published>
    <updated>2019-07-13T09:50:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redux使用入门"><a href="#Redux使用入门" class="headerlink" title="Redux使用入门"></a>Redux使用入门</h1><p><a href="http://cn.redux.js.org/" target="_blank" rel="noopener">参考网站</a></p><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>随着WEB应用变得越来越复杂，再加上node前后端分离越来越流行，那么对数据流动的控制就显得越发重要。redux是在flux的基础上产生的，基本思想是保证数据的单向流动，同时便于控制、使用、测试。</p><p>redux不依赖于任意框架(库)，只要subscribe相应框架(库)的内部方法，就可以使用该应用框架保证数据流动的一致性。</p><p>那么如何使用redux呢？下面一步步进行解析，并带有源码说明，不仅做到 知其然 ，还要做到 知其所以然 。</p><h3 id="2-主干逻辑介绍-createStore"><a href="#2-主干逻辑介绍-createStore" class="headerlink" title="2. 主干逻辑介绍(createStore)"></a>2. 主干逻辑介绍(createStore)</h3><h4 id="2-1-简单demo入门"><a href="#2-1-简单demo入门" class="headerlink" title="2.1 简单demo入门"></a>2.1 简单demo入门</h4><p>先来一个直观的认识：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 首先定义一个改变数据的plain函数，成为reducer</span><br><span class="line">function count (state, action) &#123;</span><br><span class="line">  var defaultState = &#123;</span><br><span class="line">    year: 2015,</span><br><span class="line">  &#125;;</span><br><span class="line">  state = state || defaultState;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case &apos;add&apos;:</span><br><span class="line">      return &#123;</span><br><span class="line">        year: state.year + 1</span><br><span class="line">      &#125;;</span><br><span class="line">    case &apos;sub&apos;:</span><br><span class="line">      return &#123;</span><br><span class="line">        year: state.year - 1</span><br><span class="line">      &#125;</span><br><span class="line">    default :</span><br><span class="line">      return state;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">// store的创建</span><br><span class="line">var createStore = require(&apos;redux&apos;).createStore;</span><br><span class="line">var store = createStore(count);</span><br><span class="line"></span><br><span class="line">// store里面的数据发生改变时，触发的回调函数</span><br><span class="line">store.subscribe(function () &#123;</span><br><span class="line">  console.log(&apos;the year is: &apos;, store.getState().year);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// action: 触发state改变的唯一方法(按照redux的设计思路)</span><br><span class="line">var action1 = &#123; type: &apos;add&apos; &#125;;</span><br><span class="line">var action2 = &#123; type: &apos;add&apos; &#125;;</span><br><span class="line">var action3 = &#123; type: &apos;sub&apos; &#125;;</span><br><span class="line"></span><br><span class="line">// 改变store里面的方法</span><br><span class="line">store.dispatch(action1); // &apos;the year is: 2016</span><br><span class="line">store.dispatch(action2); // &apos;the year is: 2017</span><br><span class="line">store.dispatch(action3); // &apos;the year is: 2016</span><br></pre></td></tr></table></figure></p><h4 id="2-2-挖掘createStore实现"><a href="#2-2-挖掘createStore实现" class="headerlink" title="2.2 挖掘createStore实现"></a>2.2 挖掘createStore实现</h4><p>为了说明主要问题，仅列出其中的关键代码，全部代码，可以点击 这里 阅读。</p><p>a首先看createStore到底都返回的内容:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export default function createStore(reducer, initialState) &#123;</span><br><span class="line">  ...</span><br><span class="line">  return &#123;</span><br><span class="line">    dispatch,</span><br><span class="line">    subscribe,</span><br><span class="line">    getState,</span><br><span class="line">    replaceReducer</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每个属性的含义是: - dispatch: 用于action的分发，改变store里面的state - subscribe: 注册listener，store里面state发生改变后，执行该listener - getState: 读取store里面的state - replaceReducer: 替换reducer，改变state修改的逻辑</p><p>b关键代码解析<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">export default function createStore(reducer, initialState) &#123;</span><br><span class="line">  // 这些都是闭包变量</span><br><span class="line">  var currentReducer = reducer</span><br><span class="line">  var currentState = initialState</span><br><span class="line">  var listeners = []</span><br><span class="line">  var isDispatching = false;</span><br><span class="line"></span><br><span class="line">  // 返回当前的state</span><br><span class="line">  function getState() &#123;</span><br><span class="line">    return currentState</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 注册listener，同时返回一个取消事件注册的方法</span><br><span class="line">  function subscribe(listener) &#123;</span><br><span class="line">    listeners.push(listener)</span><br><span class="line">    var isSubscribed = true</span><br><span class="line"></span><br><span class="line">    return function unsubscribe() &#123;</span><br><span class="line">    if (!isSubscribed) &#123;</span><br><span class="line">   return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isSubscribed = false</span><br><span class="line">    var index = listeners.indexOf(listener)</span><br><span class="line">      listeners.splice(index, 1)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 通过action该改变state，然后执行subscribe注册的方法</span><br><span class="line">  function dispatch(action) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      isDispatching = true</span><br><span class="line">      currentState = currentReducer(currentState, action)</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      isDispatching = false</span><br><span class="line">    &#125;</span><br><span class="line">    listeners.slice().forEach(listener =&gt; listener())</span><br><span class="line">    return action</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 替换reducer，修改state变化的逻辑</span><br><span class="line">  function replaceReducer(nextReducer) &#123;</span><br><span class="line">    currentReducer = nextReducer</span><br><span class="line">    dispatch(&#123; type: ActionTypes.INIT &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  // 初始化时，执行内部一个dispatch，得到初始state</span><br><span class="line">  dispatch(&#123; type: ActionTypes.INIT &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果还按照2.1的方式进行开发，那跟flux没有什么大的区别，需要手动解决很多问题，那redux如何将整个流程模板化(Boilerplate)呢?</p><h3 id="3-保证store的唯一性"><a href="#3-保证store的唯一性" class="headerlink" title="3. 保证store的唯一性"></a>3. 保证store的唯一性</h3><p>随着应用越来越大，一方面，不能把所有的数据都放到一个reducer里面，另一方面，为每个reducer创建一个store，后续store的维护就显得比较麻烦。如何将二者统一起来呢？</p><h4 id="3-1-demo入手"><a href="#3-1-demo入手" class="headerlink" title="3.1 demo入手"></a>3.1 demo入手</h4><p>通过combineReducers将多个reducer合并成一个rootReducer: // 创建两个reducer: count year function count (state, action) { state = state || {count: 1} switch (action.type) { default: return state; } } function year (state, action) { state = state || {year: 2015} switch (action.type) { default: return state; } }<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 将多个reducer合并成一个</span><br><span class="line">var combineReducers = require(&apos;./&apos;).combineReducers;</span><br><span class="line">var rootReducer = combineReducers(&#123;</span><br><span class="line">  count: count,</span><br><span class="line">  year: year,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 创建store，跟2.1没有任何区别</span><br><span class="line">var createStore = require(&apos;./&apos;).createStore;</span><br><span class="line">var store = createStore(rootReducer);</span><br><span class="line"></span><br><span class="line">var util = require(&apos;util&apos;);</span><br><span class="line">console.log(util.inspect(store));</span><br><span class="line">//输出的结果，跟2.1的store在结构上不存在区别</span><br><span class="line">// &#123; dispatch: [Function: dispatch],</span><br><span class="line">//   subscribe: [Function: subscribe],</span><br><span class="line">//   getState: [Function: getState],</span><br><span class="line">//   replaceReducer: [Function: replaceReducer]</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-2-源码解析combineReducers"><a href="#3-2-源码解析combineReducers" class="headerlink" title="3.2 源码解析combineReducers"></a>3.2 源码解析combineReducers</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 高阶函数，最后返回一个reducer</span><br><span class="line">export default function combineReducers(reducers) &#123;</span><br><span class="line">  // 提出不合法的reducers, finalReducers就是一个闭包变量</span><br><span class="line">  var finalReducers = pick(reducers, (val) =&gt; typeof val === &apos;function&apos;)</span><br><span class="line">  // 将各个reducer的初始state均设置为undefined</span><br><span class="line">  var defaultState = mapValues(finalReducers, () =&gt; undefined)</span><br><span class="line"></span><br><span class="line">  // 一个总reducer，内部包含子reducer</span><br><span class="line">  return function combination(state = defaultState, action) &#123;</span><br><span class="line">    var finalState = mapValues(finalReducers, (reducer, key) =&gt; &#123;</span><br><span class="line">      var previousStateForKey = state[key]</span><br><span class="line">      var nextStateForKey = reducer(previousStateForKey, action)</span><br><span class="line">      hasChanged = hasChanged || nextStateForKey !== previousStateForKey</span><br><span class="line">      return nextStateForKey</span><br><span class="line">    );</span><br><span class="line">    return hasChanged ? finalState : state</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-自动实现dispatch"><a href="#4-自动实现dispatch" class="headerlink" title="4. 自动实现dispatch"></a>4. 自动实现dispatch</h3><h4 id="4-1-demo介绍"><a href="#4-1-demo介绍" class="headerlink" title="4.1 demo介绍"></a>4.1 demo介绍</h4><p>在2.1中，要执行state的改变，需要手动dispatch:</p><p>var action = { type: ‘<strong><em>‘, payload: ‘</em></strong>‘};<br>dispatch(action);<br>手动dispatch就显得啰嗦了，那么如何自动完成呢?<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var bindActionCreators = require(&apos;redux&apos;).bindActionCreators;</span><br><span class="line">// 可以在具体的应用框架隐式进行该过程(例如react-redux的connect组件中)</span><br><span class="line">bindActionCreators(action)</span><br></pre></td></tr></table></figure></p><h4 id="4-2-源码解析"><a href="#4-2-源码解析" class="headerlink" title="4.2 源码解析"></a>4.2 源码解析</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 隐式实现dispatch</span><br><span class="line">function bindActionCreator(actionCreator, dispatch) &#123;</span><br><span class="line">  return (...args) =&gt; dispatch(actionCreator(...args))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default function bindActionCreators(actionCreators, dispatch) &#123;</span><br><span class="line">  if (typeof actionCreators === &apos;function&apos;) &#123;</span><br><span class="line">    return bindActionCreator(actionCreators, dispatch)</span><br><span class="line">  &#125;</span><br><span class="line">  return mapValues(actionCreators, actionCreator =&gt;</span><br><span class="line">    bindAQctionCreator(actionCreator, dispatch)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-支持插件-对dispatch的改造"><a href="#5-支持插件-对dispatch的改造" class="headerlink" title="5. 支持插件 - 对dispatch的改造"></a>5. 支持插件 - 对dispatch的改造</h3><h4 id="5-1-插件使用demo"><a href="#5-1-插件使用demo" class="headerlink" title="5.1 插件使用demo"></a>5.1 插件使用demo</h4><p>一个action可以是同步的，也可能是异步的，这是两种不同的情况， dispatch执行的时机是不一样的:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 同步的action creator, store可以默认实现dispatch</span><br><span class="line">function add() &#123;</span><br><span class="line">  return &#123; tyle: &apos;add&apos; &#125;</span><br><span class="line">&#125;</span><br><span class="line">dispatch(add());</span><br><span class="line"></span><br><span class="line">// 异步的action creator，因为异步完成的时间不确定，只能手工dispatch</span><br><span class="line">function fetchDataAsync() &#123;</span><br><span class="line">  return function (dispatch) &#123;</span><br><span class="line">    requst(url).end(function (err, res) &#123;</span><br><span class="line">      if (err) return dispatch(&#123; type: &apos;SET_ERR&apos;, payload: err&#125;);</span><br><span class="line">      if (res.status === &apos;success&apos;) &#123;</span><br><span class="line">        dispatch(&#123; type: &apos;FETCH_SUCCESS&apos;, payload: res.data &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面的问题就变成了，如何根据实际情况实现不同的dispatch方法，也即是根据需要实现不同的moddleware:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 普通的dispatch创建方法</span><br><span class="line">var store = createStore(reducer, initialState);</span><br><span class="line">console.log(store.dispatch);</span><br><span class="line"></span><br><span class="line">// 定制化的dispatch</span><br><span class="line">var applyMiddleware = require(&apos;redux&apos;).applyMiddleware;</span><br><span class="line">// 实现action异步的middleware</span><br><span class="line">var thunk = requre(&apos;redux-thunk&apos;);</span><br><span class="line">var store = applyMiddleware([thunk])(createStore);</span><br><span class="line">// 经过处理的dispatch方法</span><br><span class="line">console.log(store.dispatch);</span><br></pre></td></tr></table></figure></p><h4 id="5-2-源码解析"><a href="#5-2-源码解析" class="headerlink" title="5.2 源码解析"></a>5.2 源码解析</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// next: 其实就是createStore</span><br><span class="line">export default function applyMiddleware(...middlewares) &#123;</span><br><span class="line">  return (next) =&gt; (reducer, initialState) =&gt; &#123;</span><br><span class="line">    var store = next(reducer, initialState)</span><br><span class="line">    var dispatch = store.dispatch</span><br><span class="line">    var chain = []</span><br><span class="line"></span><br><span class="line">    var middlewareAPI = &#123;</span><br><span class="line">      getState: store.getState,</span><br><span class="line">      dispatch: (action) =&gt; dispatch(action)</span><br><span class="line">    &#125;</span><br><span class="line">    chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))</span><br><span class="line">    dispatch = compose(...chain)(store.dispatch)</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      ...store,</span><br><span class="line">      dispatch // 实现新的dispatch方法</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 再看看redux-thunk的实现, next就是store里面的上一个dispatch</span><br><span class="line">function thunkMiddleware(&#123; dispatch, getState &#125;) &#123;</span><br><span class="line">  return function(next) &#123;</span><br><span class="line">    return function(action) &#123;</span><br><span class="line">      typeof action === &apos;function&apos; ? action(dispatch, getState) : next(action);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return next =&gt; action =&gt;</span><br><span class="line">    typeof action === &apos;function&apos; ?</span><br><span class="line">      action(dispatch, getState) :</span><br><span class="line">      next(action);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="6-与react框架的结合"><a href="#6-与react框架的结合" class="headerlink" title="6. 与react框架的结合"></a>6. 与react框架的结合</h3><p>####6.1 基本使用</p><p>目前已经有现成的工具 react-redux 来实现二者的结合:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var rootReducers = combineReducers(reducers);</span><br><span class="line">var store = createStore(rootReducers);</span><br><span class="line">var Provider = require(&apos;react-redux&apos;).Provider;</span><br><span class="line">// App 为上层的Component</span><br><span class="line">class App extend React.Component&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;Provier store=&#123;store&#125;&gt;</span><br><span class="line">        &lt;Container /&gt;</span><br><span class="line">      &lt;/Provider&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Container作用: 1. 获取store中的数据; 2.将dispatch与actionCreator结合起来</span><br><span class="line">var connect = require(&apos;react-redux&apos;).connect;</span><br><span class="line">var actionCreators = require(&apos;...&apos;);</span><br><span class="line">// MyComponent是与redux无关的组件</span><br><span class="line">var MyComponent = require(&apos;...&apos;);</span><br><span class="line"></span><br><span class="line">function select(state) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    count: state.count</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default connect(select, actionCreators)(MyComponent)</span><br></pre></td></tr></table></figure></p><h4 id="6-2-Provider-–-提供store"><a href="#6-2-Provider-–-提供store" class="headerlink" title="6.2 Provider – 提供store"></a>6.2 Provider – 提供store</h4><p>React通过Context属性，可以将属性(props)直接给子孙component，无须通过props层层传递, Provider仅仅起到获得store，然后将其传递给子孙元素而已:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">export default class Provider extends Component &#123;</span><br><span class="line">  getChildContext() &#123; // getChildContext: 将store传递给子孙component</span><br><span class="line">    return &#123; store: this.store &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  constructor(props, context) &#123;</span><br><span class="line">    super(props, context)</span><br><span class="line">    this.store = props.store</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">    const &#123; store &#125; = this</span><br><span class="line">    const &#123; store: nextStore &#125; = nextProps</span><br><span class="line"></span><br><span class="line">    if (store !== nextStore) &#123;</span><br><span class="line">      warnAboutReceivingStore()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    let &#123; children &#125; = this.props</span><br><span class="line">    return Children.only(children)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="6-3-connect-–-获得store及dispatch-actionCreator"><a href="#6-3-connect-–-获得store及dispatch-actionCreator" class="headerlink" title="6.3 connect – 获得store及dispatch(actionCreator)"></a>6.3 connect – 获得store及dispatch(actionCreator)</h4><p>connect是一个高阶函数，首先传入mapStateToProps、mapDispatchToProps，然后返回一个生产 Component 的函数(wrapWithConnect)，然后再将真正的Component作为参数传入wrapWithConnect(MyComponent)，这样就生产出一个经过包裹的Connect组件，该组件具有如下特点:</p><p>通过this.context获取祖先Component的store<br>props包括stateProps、dispatchProps、parentProps,合并在一起得到 nextState ，作为props传给真正的Component<br>componentDidMount时，添加事件this.store.subscribe(this.handleChange)，实现页面交互<br>shouldComponentUpdate时判断是否有避免进行渲染，提升页面性能，并得到nextState<br>componentWillUnmount时移除注册的事件this.handleChange<br>在非生产环境下，带有热重载功能<br>主要的代码逻辑:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">export default function connect(mapStateToProps, mapDispatchToProps, mergeProps, options = &#123;&#125;) &#123;</span><br><span class="line">  return function wrapWithConnect(WrappedComponent) &#123;</span><br><span class="line">    class Connect extends Component &#123;</span><br><span class="line">      constructor(props, context) &#123;</span><br><span class="line">        // 从祖先Component处获得store</span><br><span class="line">        this.store = props.store || context.store</span><br><span class="line">        this.stateProps = computeStateProps(this.store, props)</span><br><span class="line">        this.dispatchProps = computeDispatchProps(this.store, props)</span><br><span class="line">        this.state = &#123; storeState: null &#125;</span><br><span class="line">        // 对stateProps、dispatchProps、parentProps进行合并</span><br><span class="line">        this.updateState()</span><br><span class="line">      &#125;</span><br><span class="line">      shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">        // 进行判断，当数据发生改变时，Component重新渲染</span><br><span class="line">        if (propsChanged || mapStateProducedChange || dispatchPropsChanged) &#123;</span><br><span class="line">          this.updateState(nextProps)</span><br><span class="line">            return true</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        componentDidMount() &#123;</span><br><span class="line">          // 改变Component的state</span><br><span class="line">          this.store.subscribe(() = &#123;</span><br><span class="line">            this.setState(&#123;</span><br><span class="line">              storeState: this.store.getState()</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        render() &#123;</span><br><span class="line">          // 生成包裹组件Connect</span><br><span class="line">          return (</span><br><span class="line">            &lt;WrappedComponent &#123;...this.nextState&#125; /&gt;</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      Connect.contextTypes = &#123;</span><br><span class="line">        store: storeShape</span><br><span class="line">      &#125;</span><br><span class="line">      return Connect;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="7-redux与react-redux关系图"><a href="#7-redux与react-redux关系图" class="headerlink" title="7. redux与react-redux关系图"></a>7. redux与react-redux关系图</h3><p><img src="images/redux.png!web"></p>]]></content>
    
    <summary type="html">
    
      Redux使用入门
    
    </summary>
    
      <category term="react" scheme="http://yoursite.com/categories/react/"/>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
      <category term="数据层" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%B1%82/"/>
    
      <category term="redux" scheme="http://yoursite.com/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>MobX入坑</title>
    <link href="http://yoursite.com/2019/07/13/React/mobx/"/>
    <id>http://yoursite.com/2019/07/13/React/mobx/</id>
    <published>2019-07-13T09:50:46.000Z</published>
    <updated>2019-07-13T09:50:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MobX入坑"><a href="#MobX入坑" class="headerlink" title="MobX入坑"></a>MobX入坑</h1><p>MobX 是一个简单、方便扩展、久经考验的状态管理解决方案。这个教程旨在十分钟内向你介绍 MobX 的一些重要概念。MobX 是一个独立的苦，不过大多数人都把它和 React 一起使用，所以本教程也就着眼于这个组合展开。</p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p>State 是每一个应用程序的核心部分，而使用一个不合规范的 State 则是让你的应用充满 bug 和失控的不二法门，或者就是局部变量环绕，让你的 state 失去了同步。有很多框架试图解决这个问题，比如使用不可变的 state，但是这样以来又带来了新的问题，比如数据必须规格化，完整性约束失效等等。</p><p>MobX 让整个事情又变简单了：它不允许产生失控的 state。它的理念也很简单：所有可以从 state 中派生的事物，都会自动的派生。</p><p>把 MobX 想象成 Excel 表格。</p><p>首先，有一个 state，它可以是一个object，array，primitives等等任何组成你程序的部分。你可以把这个想象成你应用程序的“单元格”。<br>然后就是 derivations，一般它是指可以从 state 中直接计算的来的结果。比如未完成的任务的数量，这个比较简单，也可以稍复杂一些比如渲染你的任务显示的html。它类似于你的应用程序中的“公式和图表”。<br>Reactions 和 derivations 很像，主要的区别在于 reactions 并不产生数据结果，而是自动完成一些任务，一般是和 I/O 相关的。他们保证了 DOM 和 网络请求会自动适时地出发。<br>最后是 actions。Actions 指的是所有会改变 state 的事情，MobX 保证所有 actions 都会有对应的 derivations 和 reactions 相伴，保证同步。<br>一个简单的 todo 的 state</p><p>理论说的够多的了，看一个例子也许会更明白一些。我们从一个简单的 todo 程序开始。</p><p>下面是一个简单直接的 TodoStore，没有鱼丸，没有粗面，没有 MobX ……</p><p>JavaScript<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class TodoStore &#123;</span><br><span class="line">todos = [];</span><br><span class="line"></span><br><span class="line">get completedTodosCount() &#123;</span><br><span class="line">    return this.todos.filter(</span><br><span class="line">todo =&gt; todo.completed === true</span><br><span class="line">).length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">report() &#123;</span><br><span class="line">if (this.todos.length === 0)</span><br><span class="line">return &quot;&lt;none&gt;&quot;;</span><br><span class="line">return `Next todo: &quot;$&#123;this.todos[0].task&#125;&quot;. ` +</span><br><span class="line">`Progress: $&#123;this.completedTodosCount&#125;/$&#123;this.todos.length&#125;`;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    addTodo(task) &#123;</span><br><span class="line">this.todos.push(&#123;</span><br><span class="line">task: task,</span><br><span class="line">completed: false,</span><br><span class="line">            assignee: null</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const todoStore = new TodoStore();</span><br></pre></td></tr></table></figure></p><p>我们创建了一个 todoStore，它拥有一个 todos 集合。现在我们往这个 todoStore 里添加一些东西，为了明显起见，我们每修改一个地方，就调用todoStore.report。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">todoStore.addTodo(&quot;read MobX tutorial&quot;);</span><br><span class="line">console.log(todoStore.report());</span><br><span class="line">​</span><br><span class="line">todoStore.addTodo(&quot;try MobX&quot;);</span><br><span class="line">console.log(todoStore.report());</span><br><span class="line">​</span><br><span class="line">todoStore.todos[0].completed = true;</span><br><span class="line">console.log(todoStore.report());</span><br><span class="line">​</span><br><span class="line">todoStore.todos[1].task = &quot;try MobX in own project&quot;;</span><br><span class="line">console.log(todoStore.report());</span><br><span class="line">​</span><br><span class="line">todoStore.todos[0].task = &quot;grok MobX tutorial&quot;;</span><br><span class="line">console.log(todoStore.report());</span><br></pre></td></tr></table></figure><p>到现在为止，没有什么特别的。不过如果我们可以不再手动调用 report 方法，事情会不会更美好一些？我们只需要在想要的地方修改这个 state，所有的汇报都自动来做。</p><p>太巧了，这就是 MobX 能为你做的事情。自动执行只在 state 改变的时候触发，就好像 Excel 中的图表只在单元格数据改变时更新一样。为了达到这个目标，TodoStore 必须成为可观测的（observable）才行，让我们来改一些代码。</p><p>同时，completedTodosCount 属性应该被自动派生，使用 @observable 和 @computed 装饰器来做这些事情：</p><p>JavaScript<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">class ObservableTodoStore &#123;</span><br><span class="line">    @observable todos = [];</span><br><span class="line">    @observable pendingRequests = 0;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        mobx.autorun(() =&gt; console.log(this.report));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @computed get completedTodosCount() &#123;</span><br><span class="line">    return this.todos.filter(</span><br><span class="line">todo =&gt; todo.completed === true</span><br><span class="line">).length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @computed get report() &#123;</span><br><span class="line">        if (this.todos.length === 0)</span><br><span class="line">            return &quot;&lt;none&gt;&quot;;</span><br><span class="line">return `Next todo: &quot;$&#123;this.todos[0].task&#125;&quot;. ` +</span><br><span class="line">    `Progress: $&#123;this.completedTodosCount&#125;/$&#123;this.todos.length&#125;`;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    addTodo(task) &#123;</span><br><span class="line">this.todos.push(&#123;</span><br><span class="line">    task: task,</span><br><span class="line">    completed: false,</span><br><span class="line">    assignee: null</span><br><span class="line">&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const observableTodoStore = new ObservableTodoStore();</span><br><span class="line"></span><br><span class="line">class ObservableTodoStore &#123;</span><br><span class="line">    @observable todos = [];</span><br><span class="line">    @observable pendingRequests = 0;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        mobx.autorun(() =&gt; console.log(this.report));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @computed get completedTodosCount() &#123;</span><br><span class="line">    return this.todos.filter(</span><br><span class="line">todo =&gt; todo.completed === true</span><br><span class="line">).length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @computed get report() &#123;</span><br><span class="line">        if (this.todos.length === 0)</span><br><span class="line">            return &quot;&lt;none&gt;&quot;;</span><br><span class="line">return `Next todo: &quot;$&#123;this.todos[0].task&#125;&quot;. ` +</span><br><span class="line">    `Progress: $&#123;this.completedTodosCount&#125;/$&#123;this.todos.length&#125;`;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    addTodo(task) &#123;</span><br><span class="line">this.todos.push(&#123;</span><br><span class="line">    task: task,</span><br><span class="line">    completed: false,</span><br><span class="line">    assignee: null</span><br><span class="line">&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const observableTodoStore = new ObservableTodoStore();</span><br></pre></td></tr></table></figure></p><p>运行它，太棒了，我们每次赋值都能获得输出结果了。</p><p>有个 pendingRequests 暂时没用到，我们后面会用。另外这个教程都用了 ES6 的写法，不过 MobX 也支持 ES5 的写法。</p><p>在这个构造器中，我们使用autorun包裹了一个打出report的小函数。Autorun里的东西首先会运行一次，然后当其中的函数有observable的数据发生变化时，会再次运行。 这里我们使用了todos属性，每次todos变化了我们就打印出新的东西。</p><p>JavaScript<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">observableTodoStore.addTodo(&quot;read MobX tutorial&quot;);</span><br><span class="line">observableTodoStore.addTodo(&quot;try MobX&quot;);</span><br><span class="line">observableTodoStore.todos[0].completed = true;</span><br><span class="line">observableTodoStore.todos[1].task = &quot;try MobX in own project&quot;;</span><br><span class="line">observableTodoStore.todos[0].task = &quot;grok MobX tutorial&quot;;</span><br></pre></td></tr></table></figure></p><p>（可以自己试试结果）</p><p>非常有趣是吧，report确实自己执行了，而且同步又精准。如果你仔细查看运行结果的话，你挥发性我们的第四句语句没有产生输出，因为我们修改了todos[1]的数据，而我们在report中指明的数据，并没有todos[1]的变化而发生变化。而第五句话修改了todos[0]的数据则输出了。这个例子很好的说明了，autorun不是简单的监视了todos，而是精确到了具体的一项。</p><p>让React更美好</p><p>好了，到目前未知，我们使report自动化了，是实话把react拉出来遛遛了。为了是的react 的组件可以识别mobx，我们需要使用mobx-react包来完成，使用autorun，自动的让组件和state同步，这个简直就和上面的让report自动输出一样简单。</p><p>下面是一个react 组件，唯一MobX出场的地方就是一个@observer修饰符，这已经足够了，你再也不用使用setState了，你也不需要指明这个组件需要关注state的哪个部分，也不许手动写什么高阶组件。一般来说，所有的部件都变成人工智能了，即使他被定义成一个木偶（纯展示）组件。</p><p>JavaScript<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">@observer</span><br><span class="line">class TodoList extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const store = this.props.store;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123; store.report &#125;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">          &#123; store.todos.map(</span><br><span class="line">            (todo, idx) =&gt; &lt;TodoView todo=&#123; todo &#125; key=&#123; idx &#125; /&gt;</span><br><span class="line">          ) &#125;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">        &#123; store.pendingRequests &gt; 0 ? &lt;marquee&gt;Loading...&lt;/marquee&gt; : null &#125;</span><br><span class="line">        &lt;button onClick=&#123; this.onNewTodo &#125;&gt;New Todo&lt;/button&gt;</span><br><span class="line">        &lt;small&gt; (double-click a todo to edit)&lt;/small&gt;</span><br><span class="line">      &lt;RenderCounter /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">​</span><br><span class="line">  onNewTodo = () =&gt; &#123;</span><br><span class="line">    this.props.store.addTodo(prompt(&apos;Enter a new todo:&apos;,&apos;coffee plz&apos;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">@observer</span><br><span class="line">class TodoView extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const todo = this.props.todo;</span><br><span class="line">    return (</span><br><span class="line">      &lt;li onDoubleClick=&#123; this.onRename &#125;&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=&apos;checkbox&apos;</span><br><span class="line">          checked=&#123; todo.completed &#125;</span><br><span class="line">          onChange=&#123; this.onToggleCompleted &#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &#123; todo.task &#125;</span><br><span class="line">        &#123; todo.assignee</span><br><span class="line">          ? &lt;small&gt;&#123; todo.assignee.name &#125;&lt;/small&gt;</span><br><span class="line">          : null</span><br><span class="line">        &#125;</span><br><span class="line">      &lt;RenderCounter /&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">​</span><br><span class="line">  onToggleCompleted = () =&gt; &#123;</span><br><span class="line">    const todo = this.props.todo;</span><br><span class="line">    todo.completed = !todo.completed;</span><br><span class="line">  &#125;</span><br><span class="line">​</span><br><span class="line">  onRename = () =&gt; &#123;</span><br><span class="line">    const todo = this.props.todo;</span><br><span class="line">    todo.task = prompt(&apos;Task name&apos;, todo.task) || todo.task;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;TodoList store=&#123; observableTodoStore &#125; /&gt;,</span><br><span class="line">  document.getElementById(&apos;reactjs-app&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>执行下面的语句，我们会发现MobX帮我们把数据的更改反应到界面上去了。</p><p>JavaScript<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">store.todos[0].completed = !store.todos[0].completed;</span><br><span class="line">store.todos[1].task = &quot;Random todo &quot; + Math.random();</span><br><span class="line">store.todos.push(&#123; task: &quot;Find a fine cheese&quot;, completed: true &#125;);</span><br><span class="line">// etc etc.. add your own statements here...</span><br></pre></td></tr></table></figure></p><p>使用引用（References)</p><p>到现在位置，我们已经使用 observable 创建了个数据类型了。也许你会想，MobX 能不能应付引用呢？在之前的例子里，你可能主意到了又一个 assignee 的属性，我们就在这里放另外的一个 store，然后把它赋值给 tasks。</p><p>JavaScript<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var peopleStore = mobx.observable([</span><br><span class="line">  &#123; name: &quot;Michel&quot; &#125;,</span><br><span class="line">  &#123; name: &quot;Me&quot; &#125;</span><br><span class="line">]);</span><br><span class="line">observableTodoStore.todos[0].assignee = peopleStore[0];</span><br><span class="line">observableTodoStore.todos[1].assignee = peopleStore[1];</span><br><span class="line">peopleStore[0].name = &quot;Michel Weststrate&quot;;</span><br></pre></td></tr></table></figure></p><p>毫无疑问的，MobX 把着一切打理的井井有条。使用 MobX ，不需要规格话数据，不需要指明控件，事实上你的数据在哪里都无所谓。只要 observale 了，什么都好了。</p><p>总结</p><p>好了，仅仅依靠一些简单的修饰器，我们就让 react 程序如此生动有趣。最后总结一些：</p><p>@observale 修饰器或者 observable 函数让对象可以被追踪；<br>@computed 修饰器创造了自动运算的表达式；<br>autorun 函数让依靠 observable 的函数自动执行，这个用来写 log，发请求很不错；<br>@observer 修饰器让 React 组建自动起来，它会自动更新，即便是在一个很大的程序里也会工作的很好；</p><p>最后，MobX 不是一个状态容器</p><p>很多人把 MobX 当作另外一个 Redux，但是它仅仅是一个库，不是一个什么架构。上面的例子还是需要程序员自己去组织逻辑和store或者控制器什么的。</p>]]></content>
    
    <summary type="html">
    
      MobX 是一个简单、方便扩展、久经考验的状态管理解决方案。这个教程旨在十分钟内向你介绍 MobX 的一些重要概念。MobX 是一个独立的苦，不过大多数人都把它和 React 一起使用，所以本教程也就着眼于这个组合展开。
    
    </summary>
    
      <category term="react" scheme="http://yoursite.com/categories/react/"/>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
      <category term="mobx" scheme="http://yoursite.com/tags/mobx/"/>
    
      <category term="数据层" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%B1%82/"/>
    
  </entry>
  
</feed>
