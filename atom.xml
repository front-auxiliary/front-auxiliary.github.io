<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>front-auxiliary</title>
  
  <subtitle>离心最近的地方行程最远!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-13T09:50:46.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>front-auxiliary</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue生命周期</title>
    <link href="http://yoursite.com/2019/07/13/vue/lifecyce/"/>
    <id>http://yoursite.com/2019/07/13/vue/lifecyce/</id>
    <published>2019-07-13T09:50:46.000Z</published>
    <updated>2019-07-13T09:50:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h1><h3 id="下面的表格是1-0-版本与2-0-版本的对比"><a href="#下面的表格是1-0-版本与2-0-版本的对比" class="headerlink" title="下面的表格是1.0+版本与2.0+版本的对比"></a>下面的表格是1.0+版本与2.0+版本的对比</h3><table><thead><tr><th>vue1.0+</th><th>vue2.0</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td>init</td><td>beforeCreate</td><td style="text-align:center">组件实例刚被创建，组件属性计算之前，如data属性</td></tr><tr><td>created</td><td>created</td><td style="text-align:center">组件实例创建完成，属性已绑定，但DOM还没生成,$el属性还不存在</td></tr><tr><td>beforeCompile</td><td>beforeMount</td><td style="text-align:center">模板编译/挂载之前</td></tr><tr><td>compiled</td><td>mounted</td><td style="text-align:center">模板编译/挂载之后</td></tr><tr><td>ready</td><td>mounted</td><td style="text-align:center">模板编译/挂载之后</td></tr><tr><td>-</td><td>beforeUpdate</td><td style="text-align:center">组件更新之前</td></tr><tr><td>-</td><td>updated</td><td style="text-align:center">组件更新之后</td></tr><tr><td>-</td><td>activated</td><td style="text-align:center">for keep-alive，组件被激活时调用</td></tr><tr><td>-</td><td>deactivated</td><td style="text-align:center">for keep-alive，组件被移除时调用</td></tr><tr><td>activated</td><td>-</td><td style="text-align:center">不做解释</td></tr><tr><td>detached</td><td>-</td><td style="text-align:center">不做解释</td></tr><tr><td>beforeDestroy</td><td>beforeDestroy</td><td style="text-align:center">组件销毁前调用</td></tr><tr><td>destroyed</td><td>destroyed</td><td style="text-align:center">组件销毁后调用</td></tr></tbody></table><h3 id="用代码说清这些"><a href="#用代码说清这些" class="headerlink" title="用代码说清这些"></a>用代码说清这些</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.jsdelivr.net/vue/2.1.3/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">     &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">  var app = new Vue(&#123;</span><br><span class="line">      el: &apos;#app&apos;,</span><br><span class="line">      data: &#123;</span><br><span class="line">          message : &quot;xuxiao is boy&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">       beforeCreate: function () &#123;</span><br><span class="line">                console.group(&apos;beforeCreate 创建前状态===============》&apos;);</span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot; , &quot;el     : &quot; + this.$el); //undefined</span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data); //undefined</span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message)  </span><br><span class="line">        &#125;,</span><br><span class="line">        created: function () &#123;</span><br><span class="line">            console.group(&apos;created 创建完毕状态===============》&apos;);</span><br><span class="line">            console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el     : &quot; + this.$el); //undefined</span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data); //已被初始化</span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); //已被初始化</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeMount: function () &#123;</span><br><span class="line">            console.group(&apos;beforeMount 挂载前状态===============》&apos;);</span><br><span class="line">            console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el     : &quot; + (this.$el)); //已被初始化</span><br><span class="line">            console.log(this.$el);</span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data); //已被初始化  </span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); //已被初始化  </span><br><span class="line">        &#125;,</span><br><span class="line">        mounted: function () &#123;</span><br><span class="line">            console.group(&apos;mounted 挂载结束状态===============》&apos;);</span><br><span class="line">            console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el     : &quot; + this.$el); //已被初始化</span><br><span class="line">            console.log(this.$el);    </span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data); //已被初始化</span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); //已被初始化</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeUpdate: function () &#123;</span><br><span class="line">            console.group(&apos;beforeUpdate 更新前状态===============》&apos;);</span><br><span class="line">            console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el     : &quot; + this.$el);</span><br><span class="line">            console.log(this.$el);   </span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data);</span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message);</span><br><span class="line">        &#125;,</span><br><span class="line">        updated: function () &#123;</span><br><span class="line">            console.group(&apos;updated 更新完成状态===============》&apos;);</span><br><span class="line">            console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el     : &quot; + this.$el);</span><br><span class="line">            console.log(this.$el);</span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data);</span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message);</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeDestroy: function () &#123;</span><br><span class="line">            console.group(&apos;beforeDestroy 销毁前状态===============》&apos;);</span><br><span class="line">            console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el     : &quot; + this.$el);</span><br><span class="line">            console.log(this.$el);    </span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data);</span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message);</span><br><span class="line">        &#125;,</span><br><span class="line">        destroyed: function () &#123;</span><br><span class="line">            console.group(&apos;destroyed 销毁完成状态===============》&apos;);</span><br><span class="line">            console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el     : &quot; + this.$el);</span><br><span class="line">            console.log(this.$el);  </span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data);</span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="附一张图后面慢慢理解"><a href="#附一张图后面慢慢理解" class="headerlink" title="附一张图后面慢慢理解"></a>附一张图后面慢慢理解</h3><p><img src="./images/lifecyce/lifecyce.png" alt="生命周期"></p>]]></content>
    
    <summary type="html">
    
      vue生命周期
    
    </summary>
    
      <category term="vue" scheme="http://yoursite.com/categories/vue/"/>
    
    
      <category term="生命周期" scheme="http://yoursite.com/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>webpack1  到 webpack2的变化</title>
    <link href="http://yoursite.com/2019/07/13/packaging/webpack/webpack2/"/>
    <id>http://yoursite.com/2019/07/13/packaging/webpack/webpack2/</id>
    <published>2019-07-13T09:50:46.000Z</published>
    <updated>2019-07-13T09:50:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="webpack1-到-webpack2的变化"><a href="#webpack1-到-webpack2的变化" class="headerlink" title="webpack1  到 webpack2的变化"></a>webpack1  到 webpack2的变化</h1><h2 id="resolve-root-resolve-fallback-resolve-modulesDirectories"><a href="#resolve-root-resolve-fallback-resolve-modulesDirectories" class="headerlink" title="resolve.root, resolve.fallback, resolve.modulesDirectories"></a>resolve.root, resolve.fallback, resolve.modulesDirectories</h2><p>上述配置项被一个单独的配置项 resolve.modules 取代。详见 resolving。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  resolve: &#123;</span><br><span class="line">-   root: path.join(__dirname, &quot;src&quot;)</span><br><span class="line">+   modules: [</span><br><span class="line">+     path.join(__dirname, &quot;src&quot;),</span><br><span class="line">+     &quot;node_modules&quot;</span><br><span class="line">+   ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="resolve-extensions"><a href="#resolve-extensions" class="headerlink" title="resolve.extensions"></a>resolve.extensions</h2><p>此配置项不再需要传一个空字符串。此行为被迁移到 resolve.enforceExtension。详见 resolving。</p><h2 id="resolve"><a href="#resolve" class="headerlink" title="resolve.*"></a>resolve.*</h2><p>变化较大在我的webpack中resolve模块节查看</p><h2 id="module-loaders-改成了-module-rules"><a href="#module-loaders-改成了-module-rules" class="headerlink" title="module.loaders 改成了 module.rules"></a>module.loaders 改成了 module.rules</h2><p>旧的 loader 配置被更强大的 rules 系统取代，后者允许配置 loader 以及其他更多项。为了兼容旧版，module.loaders 语法被保留，旧的属性名依然可以被解析。新的命名约定更易于理解并且是升级配置使用 module.rules 的好理由。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> module: &#123;</span><br><span class="line">-   loaders: [</span><br><span class="line">+   rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.css$/,</span><br><span class="line">-       loaders: [</span><br><span class="line">+       use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &quot;style-loader&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &quot;css-loader&quot;,</span><br><span class="line">-           query: &#123;</span><br><span class="line">+           options: &#123;</span><br><span class="line">              modules: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.jsx$/,</span><br><span class="line">        loader: &quot;babel-loader&quot;, // Do not use &quot;use&quot; here</span><br><span class="line">        options: &#123;</span><br><span class="line">          // ...</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="链式-loaders"><a href="#链式-loaders" class="headerlink" title="链式 loaders"></a>链式 loaders</h2><p>与 v1 版本相同，loaders 可以链式调用，上一个 loader 的输出被作为输入传给下一个 loader。使用 rule.use 配置项，use 可以设置为一个 loaders 的列表。在 v1 版本中，loaders 通常被用 ! 连写。这一写法在新版中只在使用旧的 module.loaders 时有效。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  module: &#123;</span><br><span class="line">-   loaders: &#123;</span><br><span class="line">+   rules: [&#123;</span><br><span class="line">      test: /\.less$/,</span><br><span class="line">-     loader: &quot;style-loader!css-loader!less-loader&quot;</span><br><span class="line">+     use: [</span><br><span class="line">+       &quot;style-loader&quot;,</span><br><span class="line">+       &quot;css-loader&quot;,</span><br><span class="line">+       &quot;less-loader&quot;</span><br><span class="line">+     ]</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h2 id="取消了在模块名中自动添加-loader-后缀"><a href="#取消了在模块名中自动添加-loader-后缀" class="headerlink" title="取消了在模块名中自动添加 -loader 后缀"></a>取消了在模块名中自动添加 -loader 后缀</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        use: [</span><br><span class="line">-         &quot;style&quot;,</span><br><span class="line">+         &quot;style-loader&quot;,</span><br><span class="line">-         &quot;css&quot;,</span><br><span class="line">+         &quot;css-loader&quot;,</span><br><span class="line">-         &quot;less&quot;,</span><br><span class="line">+         &quot;less-loader&quot;,</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="json-loader-不再需要手动添加"><a href="#json-loader-不再需要手动添加" class="headerlink" title="json-loader 不再需要手动添加"></a>json-loader 不再需要手动添加</h2><p>如果没有为 JSON 文件配置 loader，webpack 将自动尝试通过 加载 json-loader JSON 文件。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">-     &#123;</span><br><span class="line">-       test: /\.json/,</span><br><span class="line">-       loader: &quot;json-loader&quot;</span><br><span class="line">-     &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h2 id="loader-默认的-resolve-配置是相对于-context-的"><a href="#loader-默认的-resolve-配置是相对于-context-的" class="headerlink" title="loader 默认的 resolve 配置是相对于 context 的"></a>loader 默认的 resolve 配置是相对于 context 的</h2><p>在 webpack 1 中，loader 默认配置下 resolve 相对于被匹配的文件。而在 webpack 2 中默认配置的 resolve 相对于 context 配置项。</p><p>这解决了一些问题，比如使用 npm link 或引用 context 之外的模块时导致重复载入。</p><p>你可以不再需要使用一些变通方案了：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        // ...</span><br><span class="line">-       loader: require.resolve(&quot;my-loader&quot;)</span><br><span class="line">+       loader: &quot;my-loader&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  resolveLoader: &#123;</span><br><span class="line">-   root: path.resolve(__dirname, &quot;node_modules&quot;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h2 id="取消了-module-preLoaders-以及-module-postLoaders"><a href="#取消了-module-preLoaders-以及-module-postLoaders" class="headerlink" title="取消了 module.preLoaders 以及 module.postLoaders"></a>取消了 module.preLoaders 以及 module.postLoaders</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> module: &#123;</span><br><span class="line">-   preLoaders: [</span><br><span class="line">+   rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.js$/,</span><br><span class="line">+       enforce: &quot;pre&quot;,</span><br><span class="line">        loader: &quot;eslint-loader&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="UglifyJsPlugin-sourceMap"><a href="#UglifyJsPlugin-sourceMap" class="headerlink" title="UglifyJsPlugin sourceMap"></a>UglifyJsPlugin sourceMap</h2><p>UglifyJsPlugin 的 sourceMap 配置项现在默认为 false 而不是 true。 这意味着如果你在压缩代码时启用了 source map，或者想要让 uglifyjs 的警告能够对应到正确的代码行，你需要将 UglifyJsPlugin 的 sourceMap 设为 true。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">devtool: &quot;source-map&quot;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new UglifyJsPlugin(&#123;</span><br><span class="line">+     sourceMap: true</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></p><h2 id="UglifyJsPlugin-warnings"><a href="#UglifyJsPlugin-warnings" class="headerlink" title="UglifyJsPlugin warnings"></a>UglifyJsPlugin warnings</h2><p>UglifyJsPlugin 的 compress.warnings 配置项现在默认为 false 而不是 true。 这意味着如果你想要看到 uglifyjs 的警告信息，你需要将 compress.warnings 设为 true。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  devtool: &quot;source-map&quot;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new UglifyJsPlugin(&#123;</span><br><span class="line">+     compress: &#123;</span><br><span class="line">+       warnings: true</span><br><span class="line">+     &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></p><h2 id="UglifyJsPlugin-压缩-loaders"><a href="#UglifyJsPlugin-压缩-loaders" class="headerlink" title="UglifyJsPlugin 压缩 loaders"></a>UglifyJsPlugin 压缩 loaders</h2><p>UglifyJsPlugin 不再压缩 loaders。在未来很长一段时间里，需要通过设置 minimize:true 来压缩 loaders。参考 loader 文档里的相关配置项。</p><p>loaders 的压缩模式将在 webpack 3 或更高的版本中被取消。</p><p>为了兼容旧的 loaders，loaders 可以通过插件来切换到压缩模式<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  plugins: [</span><br><span class="line">+   new webpack.LoaderOptionsPlugin(&#123;</span><br><span class="line">+     minimize: true</span><br><span class="line">+   &#125;)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></p><h2 id="DedupePlugin-被移除"><a href="#DedupePlugin-被移除" class="headerlink" title="DedupePlugin 被移除"></a>DedupePlugin 被移除</h2><p>不再需要 webpack.optimize.DedupePlugin。请从配置中移除。</p><h2 id="BannerPlugin-破坏性改动"><a href="#BannerPlugin-破坏性改动" class="headerlink" title="BannerPlugin - 破坏性改动"></a>BannerPlugin - 破坏性改动</h2><p>BannerPlugin 不在接受两个参数而是只接受单独的 options 对象。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> plugins: [</span><br><span class="line">-    new webpack.BannerPlugin(&apos;Banner&apos;, &#123;raw: true, entryOnly: true&#125;);</span><br><span class="line">+    new webpack.BannerPlugin(&#123;banner: &apos;Banner&apos;, raw: true, entryOnly: true&#125;);</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></p><h2 id="OccurrenceOrderPlugin-被默认加载"><a href="#OccurrenceOrderPlugin-被默认加载" class="headerlink" title="OccurrenceOrderPlugin 被默认加载"></a>OccurrenceOrderPlugin 被默认加载</h2><p>我们不再需要在配置里指定它：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> plugins: [</span><br><span class="line">-   new webpack.optimize.OccurrenceOrderPlugin()</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></p><h2 id="ExtractTextWebpackPlugin-大改变"><a href="#ExtractTextWebpackPlugin-大改变" class="headerlink" title="ExtractTextWebpackPlugin - 大改变"></a>ExtractTextWebpackPlugin - 大改变</h2><p>ExtractTextPlugin 1.0.0 不能在 webpack v2 下工作。 你需要明确地安装 ExtractTextPlugin v2。</p><p>npm install –save-dev extract-text-webpack-plugin@beta</p><p>这一插件的配置变化主要体现在语法上。<br>ExtractTextPlugin.extract<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: /.css$/,</span><br><span class="line">-      loader: ExtractTextPlugin.extract(&quot;style-loader&quot;, &quot;css-loader&quot;, &#123; publicPath: &quot;/dist&quot; &#125;)</span><br><span class="line">+      use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">+        fallback: &quot;style-loader&quot;,</span><br><span class="line">+        use: &quot;css-loader&quot;,</span><br><span class="line">+        publicPath: &quot;/dist&quot;</span><br><span class="line">+      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>new ExtractTextPlugin({options})<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">-  new ExtractTextPlugin(&quot;bundle.css&quot;, &#123; allChunks: true, disable: false &#125;)</span><br><span class="line">+  new ExtractTextPlugin(&#123;</span><br><span class="line">+    filename: &quot;bundle.css&quot;,</span><br><span class="line">+    disable: false,</span><br><span class="line">+    allChunks: true</span><br><span class="line">+  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h2 id="全动态-requires-现在默认会失败"><a href="#全动态-requires-现在默认会失败" class="headerlink" title="全动态 requires 现在默认会失败"></a>全动态 requires 现在默认会失败</h2><p>只有一个表达式的依赖（例如 require(expr)）将创建一个空的 context 而不是一个完整目录的 context。</p><p>如果有上面那样的代码，最好把它重构了，因为在 ES2015 模块下它不可以用。如果你确定不会有 ES2015 模块，你可以使用 ContextReplacementPlugin 来提示编译器进行正确的处理。</p><h2 id="在-CLI-和配置中使用自定义参数"><a href="#在-CLI-和配置中使用自定义参数" class="headerlink" title="在 CLI 和配置中使用自定义参数"></a>在 CLI 和配置中使用自定义参数</h2><p>如果你之前滥用 CLI 来传自定义参数到配置中，比如：</p><p>webpack –custom-stuff</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// webpack.config.js</span><br><span class="line">var customStuff = process.argv.indexOf(&quot;--custom-stuff&quot;) &gt;= 0;</span><br><span class="line">/* ... */</span><br><span class="line">module.exports = config;</span><br></pre></td></tr></table></figure><p>你将会发现新版中不再允许这么做。CLI 现在更加严格了。</p><p>替代地，现在提供了一个接口来传递参数给配置。我们应该采用这种新方式，在未来许多工具将可能依赖它。</p><p>webpack –env.customStuff<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function(env) &#123;</span><br><span class="line">  var customStuff = env.customStuff;</span><br><span class="line">  /* ... */</span><br><span class="line">  return config;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="require-ensure-以及-AMD-require-的异步"><a href="#require-ensure-以及-AMD-require-的异步" class="headerlink" title="require.ensure 以及 AMD require 的异步"></a>require.ensure 以及 AMD require 的异步</h2><p>现在这些函数总是异步的，而不是当 chunk 已经加载过的时候同步调用它们的 callback。</p><p>注意 require.ensure 现在依赖于原生的 Promise。如果在不支持 Promise 的环境里使用 require.ensure，你需要添加 polyfill。</p><h2 id="通过-options-配置-loader"><a href="#通过-options-配置-loader" class="headerlink" title="通过 options 配置 loader"></a>通过 options 配置 loader</h2><p>你不能再通过 webpack.config.js 的自定义属性来配置 loader。只能通过 options 来配置。下面配置的 ts 属性在 webpack 2 下不再有效：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: /\.tsx?$/,</span><br><span class="line">      loader: &apos;ts-loader&apos;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  // does not work with webpack 2</span><br><span class="line">  ts: &#123; transpileOnly: false &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>什么是 options?</p><p>好问题。严格来说，有两种办法，都可以用来配置 webpack 的 loader。典型的 options 被称为 query，是一个可以被添加到 loader 名之后的字符串。它比较像一个 query string，但是实际上有更强大的能力：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: /\.tsx?$/,</span><br><span class="line">      loader: &apos;ts-loader?&apos; + JSON.stringify(&#123; transpileOnly: false &#125;)</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不过它也可以分开来，写成一个单独的对象，紧跟在 loader 属性后面：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: /\.tsx?$/,</span><br><span class="line">      loader: &apos;ts-loader&apos;,</span><br><span class="line">      options:  &#123; transpileOnly: false &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="LoaderOptionsPlugin-context"><a href="#LoaderOptionsPlugin-context" class="headerlink" title="LoaderOptionsPlugin context"></a>LoaderOptionsPlugin context</h2><p>有的 loader 需要从配置中读取一些 context 信息。在未来很长一段时间里，这将需要通过 loader options 传入。详见 loader 文档的相关选项。</p><p>为了保持对旧 loaders 的兼容，这些信息可以通过插件传进来：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  plugins: [</span><br><span class="line">+   new webpack.LoaderOptionsPlugin(&#123;</span><br><span class="line">+     options: &#123;</span><br><span class="line">+       context: __dirname</span><br><span class="line">+     &#125;</span><br><span class="line">+   &#125;)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></p><h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h2><p>在 webpack 1 中 debug 配置项切换 loaders 到 debug 模式。在未来很长一段时间里，这将需要通过 loader 配置项传递。详见 loader 文档的相关选项。</p><p>loaders 的 debug 模式将在 webpack 3 或后续版本中取消。</p><p>为了保持对旧 loaders 的兼容，loader 可以通过插件来切换到 debug 模式：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- debug: true,</span><br><span class="line">  plugins: [</span><br><span class="line">+   new webpack.LoaderOptionsPlugin(&#123;</span><br><span class="line">+     debug: true</span><br><span class="line">+   &#125;)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></p><h2 id="ES2015-的代码分割"><a href="#ES2015-的代码分割" class="headerlink" title="ES2015 的代码分割"></a>ES2015 的代码分割</h2><p>在 webpack v1 中，你能使用 require.ensure 作为方法来懒加载 chunks 到你的应用中：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require.ensure([], function(require) &#123;</span><br><span class="line">  var foo = require(&quot;./module&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>ES2015 模块加载规范定义了 import() 方法来运行时动态地加载 ES2015 模块。</p><p>webpack 将 import() 作为分割点并将被请求的模块放到一个单独的 chunk 中。</p><p>import() 接收模块名作为参数，并返回一个 Promise。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function onClick() &#123;</span><br><span class="line">  import(&quot;./module&quot;).then(module =&gt; &#123;</span><br><span class="line">    return module.default;</span><br><span class="line">  &#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(&quot;Chunk loading failed&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好消息是：如果加载 chunk 失败，我们可以进行处理，因为现在它基于 Promise。</p><p>警告：require.ensure 允许用可选的第三个参数为 chunk 简单命名，但是 import API 还未提供这个能力。如果你想要保留这个功能，你可以继续使用 require.ensure。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require.ensure([], function(require) &#123;</span><br><span class="line">  var foo = require(&quot;./module&quot;);</span><br><span class="line">&#125;, &quot;custom-chunk-name&quot;);</span><br></pre></td></tr></table></figure></p><p>（注意废弃的 System.import：webpack 对 System.import 的使用不符合新提出的标准，所以它在 v2.1.0-beta.28 版本中被废弃，转向支持 import()）</p><p>由于这个建议还在 Stage 3，如果你想要同时使用 import 和 Babel，你需要安装/添加 dynamic-import 语法插件来绕过解析错误。当建议被添加到规范之后，就不再需要这个语法插件了。</p><h2 id="动态表达式"><a href="#动态表达式" class="headerlink" title="动态表达式"></a>动态表达式</h2><p>可以传递部分表达式给 import()。这与 CommonJS 对表达式的处理方式一致（webpack 为所有可能匹配的文件创建 context）。</p><p>import() 为每一个可能的模块创建独立的 chunk。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function route(path, query) &#123;</span><br><span class="line">  return import(`./routes/$&#123;path&#125;/route`)</span><br><span class="line">    .then(route =&gt; new route.Route(query));</span><br><span class="line">&#125;</span><br><span class="line">// 上面代码为每个可能的路由创建独立的 chunk</span><br></pre></td></tr></table></figure></p><h2 id="混合使用-ES2015、AMD-和-CommonJS"><a href="#混合使用-ES2015、AMD-和-CommonJS" class="headerlink" title="混合使用 ES2015、AMD 和 CommonJS"></a>混合使用 ES2015、AMD 和 CommonJS</h2><p>你可以自由混合使用三种模块类型（甚至在同一个文件中）。在这个情况中 webpack 的行为和 babel 以及 node-eps 一致：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// CommonJS consuming ES2015 Module</span><br><span class="line">var book = require(&quot;./book&quot;);</span><br><span class="line"></span><br><span class="line">book.currentPage;</span><br><span class="line">book.readPage();</span><br><span class="line">book.default === &quot;This is a book&quot;;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// ES2015 Module consuming CommonJS</span><br><span class="line">import fs from &quot;fs&quot;; // module.exports map to default</span><br><span class="line">import &#123; readFileSync &#125; from &quot;fs&quot;; // named exports are read from returned object+</span><br><span class="line"></span><br><span class="line">typeof fs.readFileSync === &quot;function&quot;;</span><br><span class="line">typeof readFileSync === &quot;function&quot;;</span><br></pre></td></tr></table></figure><p>需要注意的是，您需要告诉Babel不要解析这些模块符号，这样webpack就可以使用它们。您可以通过在您的程序中设置以下内容来实现这一点。babelrc或babel-loader选项。</p><h3 id="babelrc"><a href="#babelrc" class="headerlink" title=".babelrc"></a>.babelrc</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    [&quot;es2015&quot;, &#123; &quot;modules&quot;: false &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>webpack 现在支持表达式中的模板字符串了。这意味着你可以在 webpack 构建中使用它们：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- require(&quot;./templates/&quot; + name);</span><br><span class="line">+ require(`./templates/$&#123;name&#125;`);</span><br></pre></td></tr></table></figure></p><h2 id="配置中使用-Promise"><a href="#配置中使用-Promise" class="headerlink" title="配置中使用 Promise"></a>配置中使用 Promise</h2><p>webpack 现在支持在配置文件中返回 Promise 了。这让你能在配置文件中做异步处理。</p><p>webpack.config.js<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function() &#123;</span><br><span class="line">  return fetchLangs().then(lang =&gt; (&#123;</span><br><span class="line">    entry: &quot;...&quot;,</span><br><span class="line">    // ...</span><br><span class="line">    plugins: [</span><br><span class="line">      new DefinePlugin(&#123; LANGUAGE: lang &#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="高级-loader-匹配"><a href="#高级-loader-匹配" class="headerlink" title="高级 loader 匹配"></a>高级 loader 匹配</h2><p>webpack 现在支持对 loader 进行更多方式的匹配。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      resource: /filename/, // matches &quot;/path/filename.js&quot;</span><br><span class="line">      resourceQuery: /querystring/, // matches &quot;/filename.js?querystring&quot;</span><br><span class="line">      issuer: /filename/, // matches &quot;/path/something.js&quot; if requested from &quot;/path/filename.js&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更多的-CLI-参数项"><a href="#更多的-CLI-参数项" class="headerlink" title="更多的 CLI 参数项"></a>更多的 CLI 参数项</h2><p>你可以使用一些新的 CLI 参数项：</p><p>–define process.env.NODE_ENV=”production” 见 DefinePlugin。</p><p>–display-depth 显示每个模块到入口的距离。</p><p>–display-used-exports 显示一个模块中被使用的 exports 信息。</p><p>–display-max-modules 设置输出时显示的模块数量（默认是 15）。</p><p>-p 能够定义 process.env.NODE_ENV 为 “production”。</p><h2 id="Cacheable"><a href="#Cacheable" class="headerlink" title="Cacheable"></a>Cacheable</h2><p>Loaders 现在默认可被缓存。Loaders 如果不想被缓存，需要选择不被缓存。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> // Cacheable loader</span><br><span class="line">  module.exports = function(source) &#123;</span><br><span class="line">-   this.cacheable();</span><br><span class="line">    return source;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> // Not cacheable loader</span><br><span class="line">  module.exports = function(source) &#123;</span><br><span class="line">+   this.cacheable(false);</span><br><span class="line">    return source;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="复合-options"><a href="#复合-options" class="headerlink" title="复合 options"></a>复合 options</h2><p>webpack 1 只支持能够 JSON.stringify 的对象作为配置项。webpack 2 现在支持任意 JS 对象作为 loader 配置项。</p><p>使用复合 options 只有一个附加条件。你需要在 options 对象上添加一个 ident，让它能够被其他 loader 引用。</p><p>options 对象上有了 ident ，内联的 loader 就可以引用这个 options 对象。下面是个例子：</p><p>require(“some-loader??by-ident!resource”)<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: /.../,</span><br><span class="line">  loader: &quot;...&quot;,</span><br><span class="line">  options: &#123;</span><br><span class="line">    ident: &quot;by-ident&quot;,</span><br><span class="line">    magic: () =&gt; return Math.random()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种内联风格在常规的代码里一般用不着，但是在 loader 生成的代码里比较常见。比如，style-loader 生成一个模块，通过 require 加载其余的请求（它们输出 CSS）。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// style-loader generated code (simplified)</span><br><span class="line">var addStyle = require(&quot;./add-style&quot;);</span><br><span class="line">var css = require(&quot;-!css-loader?&#123;&quot;modules&quot;:true&#125;!postcss-loader??postcss-ident&quot;);</span><br><span class="line"></span><br><span class="line">addStyle(css);</span><br></pre></td></tr></table></figure></p><p>所以如果你使用复合 options，告诉你的用户你使用的 ident。</p>]]></content>
    
    <summary type="html">
    
      webpack从一到二版本的修改变化相对较大
    
    </summary>
    
      <category term="webpack" scheme="http://yoursite.com/categories/webpack/"/>
    
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
      <category term="packaging" scheme="http://yoursite.com/tags/packaging/"/>
    
      <category term="webpack2.x的变化" scheme="http://yoursite.com/tags/webpack2-x%E7%9A%84%E5%8F%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>React生命周期</title>
    <link href="http://yoursite.com/2019/07/13/React/lifecyce/"/>
    <id>http://yoursite.com/2019/07/13/React/lifecyce/</id>
    <published>2019-07-13T09:50:46.000Z</published>
    <updated>2019-07-13T09:50:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React生命周期"><a href="#React生命周期" class="headerlink" title="React生命周期"></a>React生命周期</h1><h3 id="用一个表格表示生命周期"><a href="#用一个表格表示生命周期" class="headerlink" title="用一个表格表示生命周期"></a>用一个表格表示生命周期</h3><table><thead><tr><th>函数</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td>getDefaultProps</td><td style="text-align:center">作用于组件类，只调用一次，返回对象用于设置默认的props，对于引用值，会在实例中共享</td></tr><tr><td>getInitialState</td><td style="text-align:center">作用于组件的实例，在实例创建时调用一次，用于初始化每个实例的state，此时可以访问this.props</td></tr><tr><td>componentWillMount</td><td style="text-align:center">在完成首次渲染之前调用，此时仍可以修改组件的state</td></tr><tr><td>render</td><td style="text-align:center">必选的方法，创建虚拟DOM，该方法具有特殊的规则： 1.只能通过this.props和this.state访问数据  2.可以返回null、false或任何React组件  3.只能出现一个顶级组件（不能返回数组） 4.不能改变组件的状态   5.不能修改DOM的输出</td></tr><tr><td>componentDidMount</td><td style="text-align:center">真实的DOM被渲染出来后调用，在该方法中可通过this.getDOMNode()访问到真实的DOM元素。此时已可以使用其他类库来操作这个DOM。在服务端中，该方法不会被调用</td></tr><tr><td>componentWillReceiveProps</td><td style="text-align:center">组件接收到新的props时调用，并将其作为参数nextProps使用，此时可以更改组件props及state</td></tr><tr><td>shouldComponentUpdate</td><td style="text-align:center">组件是否应当渲染新的props或state，返回false表示跳过后续的生命周期方法，通常不需要使用以避免出现bug。在出现应用的瓶颈时，可通过该方法进行适当的优化</td></tr><tr><td>componentWillUpdate</td><td style="text-align:center">接收到新的props或者state后，进行渲染之前调用，此时不允许更新props或state</td></tr><tr><td>componentDidUpdate</td><td style="text-align:center">完成渲染新的props或者state后调用，此时可以访问到新的DOM元素</td></tr><tr><td>componentWillUnmount</td><td style="text-align:center">组件被移除之前被调用，可以用于做一些清理工作，在componentDidMount方法中添加的所有任务都需要在该方法中撤销，比如创建的定时器或添加的事件监听器</td></tr></tbody></table><h2 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h2><h5 id="首次实例化"><a href="#首次实例化" class="headerlink" title="首次实例化"></a>首次实例化</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getDefaultProps</span><br><span class="line">getInitialState</span><br><span class="line">componentWillMount</span><br><span class="line">render</span><br><span class="line">componentDidMount</span><br></pre></td></tr></table></figure><h5 id="实例化完成后的更新"><a href="#实例化完成后的更新" class="headerlink" title="实例化完成后的更新"></a>实例化完成后的更新</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getInitialState</span><br><span class="line">componentWillMount</span><br><span class="line">render</span><br><span class="line">componentDidMount</span><br></pre></td></tr></table></figure><h5 id="存在期"><a href="#存在期" class="headerlink" title="存在期"></a>存在期</h5><p>组件已存在时的状态改变<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">componentWillReceiveProps</span><br><span class="line">shouldComponentUpdate</span><br><span class="line">componentWillUpdate</span><br><span class="line">render</span><br><span class="line">componentDidUpdate</span><br></pre></td></tr></table></figure></p><h5 id="销毁-amp-清理期"><a href="#销毁-amp-清理期" class="headerlink" title="销毁&amp;清理期"></a>销毁&amp;清理期</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">componentWillUnmount</span><br></pre></td></tr></table></figure><p>说明<br>生命周期共提供了10个不同的API。</p><h5 id="1-getDefaultProps"><a href="#1-getDefaultProps" class="headerlink" title="1.getDefaultProps"></a>1.getDefaultProps</h5><p>作用于组件类，只调用一次，返回对象用于设置默认的props，对于引用值，会在实例中共享。</p><h5 id="2-getInitialState"><a href="#2-getInitialState" class="headerlink" title="2.getInitialState"></a>2.getInitialState</h5><p>作用于组件的实例，在实例创建时调用一次，用于初始化每个实例的state，此时可以访问this.props。</p><h5 id="3-componentWillMount"><a href="#3-componentWillMount" class="headerlink" title="3.componentWillMount"></a>3.componentWillMount</h5><p>在完成首次渲染之前调用，此时仍可以修改组件的state。</p><h5 id="4-render"><a href="#4-render" class="headerlink" title="4.render"></a>4.render</h5><p>必选的方法，创建虚拟DOM，该方法具有特殊的规则：</p><p>只能通过this.props和this.state访问数据<br>可以返回null、false或任何React组件<br>只能出现一个顶级组件（不能返回数组）<br>不能改变组件的状态<br>不能修改DOM的输出</p><h5 id="5-componentDidMount"><a href="#5-componentDidMount" class="headerlink" title="5.componentDidMount"></a>5.componentDidMount</h5><p>真实的DOM被渲染出来后调用，在该方法中可通过this.getDOMNode()访问到真实的DOM元素。此时已可以使用其他类库来操作这个DOM。</p><p>在服务端中，该方法不会被调用。</p><h5 id="6-componentWillReceiveProps"><a href="#6-componentWillReceiveProps" class="headerlink" title="6.componentWillReceiveProps"></a>6.componentWillReceiveProps</h5><p>组件接收到新的props时调用，并将其作为参数nextProps使用，此时可以更改组件props及state。</p><pre><code>componentWillReceiveProps: function(nextProps) {    if (nextProps.bool) {        this.setState({            bool: true        });    }}</code></pre><h5 id="7-shouldComponentUpdate"><a href="#7-shouldComponentUpdate" class="headerlink" title="7.shouldComponentUpdate"></a>7.shouldComponentUpdate</h5><p>组件是否应当渲染新的props或state，返回false表示跳过后续的生命周期方法，通常不需要使用以避免出现bug。在出现应用的瓶颈时，可通过该方法进行适当的优化。</p><p>在首次渲染期间或者调用了forceUpdate方法后，该方法不会被调用</p><h5 id="8-componentWillUpdate"><a href="#8-componentWillUpdate" class="headerlink" title="8.componentWillUpdate"></a>8.componentWillUpdate</h5><p>接收到新的props或者state后，进行渲染之前调用，此时不允许更新props或state。</p><h5 id="9-componentDidUpdate"><a href="#9-componentDidUpdate" class="headerlink" title="9.componentDidUpdate"></a>9.componentDidUpdate</h5><p>完成渲染新的props或者state后调用，此时可以访问到新的DOM元素。</p><h5 id="10-componentWillUnmount"><a href="#10-componentWillUnmount" class="headerlink" title="10.componentWillUnmount"></a>10.componentWillUnmount</h5><p>组件被移除之前被调用，可以用于做一些清理工作，在componentDidMount方法中添加的所有任务都需要在该方法中撤销，比如创建的定时器或添加的事件监听器。</p>]]></content>
    
    <summary type="html">
    
      React生命周期
    
    </summary>
    
      <category term="react" scheme="http://yoursite.com/categories/react/"/>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
      <category term="生命周期" scheme="http://yoursite.com/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    
      <category term="框架" scheme="http://yoursite.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>react项目搭建</title>
    <link href="http://yoursite.com/2019/07/13/React/react/"/>
    <id>http://yoursite.com/2019/07/13/React/react/</id>
    <published>2019-07-13T09:50:46.000Z</published>
    <updated>2019-07-13T09:50:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="react项目搭建"><a href="#react项目搭建" class="headerlink" title="react项目搭建"></a>react项目搭建</h1><p>要想使用npm,请先安装nodejs.</p><h2 id="第一步、安装全局包"><a href="#第一步、安装全局包" class="headerlink" title="第一步、安装全局包"></a>第一步、安装全局包</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install babel -g</span><br><span class="line">$ npm install webpack -g</span><br><span class="line">$ npm install webpack-dev-server -g</span><br></pre></td></tr></table></figure><h2 id="第二步、创建根目录"><a href="#第二步、创建根目录" class="headerlink" title="第二步、创建根目录"></a>第二步、创建根目录</h2><p>创建一个根目录，目录名为：reactApp，再使用 npm init 初始化，生成 package.json 文件：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir reactApp</span><br><span class="line">$ cd reactApp/</span><br><span class="line">$ npm init</span><br></pre></td></tr></table></figure></p><h4 id="命令行显示以下内容"><a href="#命令行显示以下内容" class="headerlink" title="命令行显示以下内容"></a>命令行显示以下内容</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">name: (reactApp) runoob-react-test</span><br><span class="line">version: (1.0.0)</span><br><span class="line">description: cllgeek</span><br><span class="line">entry point: (index.js)</span><br><span class="line">test command:</span><br><span class="line">git repository:</span><br><span class="line">keywords:</span><br><span class="line">author:</span><br><span class="line">license: (ISC)</span><br><span class="line">About to write to /Users/tianqixin/www/reactApp/package.json:</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;react-runoob&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;cllgeek test&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;webpack-dev-server --hot&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">    &quot;author&quot;: &quot;&quot;,</span><br><span class="line">    &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">    &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;react&quot;: &quot;^0.14.8&quot;,</span><br><span class="line">    &quot;react-dom&quot;: &quot;^0.14.8&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Is this ok? (yes)</span><br></pre></td></tr></table></figure><h2 id="第三步、添加越来包及插件"><a href="#第三步、添加越来包及插件" class="headerlink" title="第三步、添加越来包及插件"></a>第三步、添加越来包及插件</h2><p>因为我们要使用 React, 所以我们需要先安装它，–save 命令用于将包添加至 package.json 文件。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ npm install react --save</span><br><span class="line">$ npm install react-dom --save</span><br><span class="line">同时我们也要安装一些 babel 插件</span><br><span class="line"></span><br><span class="line">$ npm install babel-core</span><br><span class="line">$ npm install babel-loader</span><br><span class="line">$ npm install babel-preset-react</span><br><span class="line">$ npm install babel-preset-es2015</span><br></pre></td></tr></table></figure></p><h2 id="第四步、创建文件"><a href="#第四步、创建文件" class="headerlink" title="第四步、创建文件"></a>第四步、创建文件</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">接下来我们创建一些必要文件：</span><br><span class="line"></span><br><span class="line">$ touch index.html</span><br><span class="line">$ touch App.jsx</span><br><span class="line">$ touch main.js</span><br><span class="line">$ touch webpack.config.js</span><br></pre></td></tr></table></figure><h2 id="第五步、设置编译器，服务器，载入器"><a href="#第五步、设置编译器，服务器，载入器" class="headerlink" title="第五步、设置编译器，服务器，载入器"></a>第五步、设置编译器，服务器，载入器</h2><p>打开 webpack.config.js 文件添加以下代码:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var config = &#123;</span><br><span class="line">  entry: &apos;./main.js&apos;,</span><br><span class="line"></span><br><span class="line">  output: &#123;</span><br><span class="line">    path:&apos;./&apos;,</span><br><span class="line">    filename: &apos;index.js&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    inline: true,</span><br><span class="line">    port: 8888</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  module: &#123;</span><br><span class="line">    loaders: [ &#123;</span><br><span class="line">      test: /.jsx?$/,</span><br><span class="line">      exclude: /node_modules/,</span><br><span class="line">      loader: &apos;babel&apos;,</span><br><span class="line"></span><br><span class="line">         query: &#123;</span><br><span class="line">            presets: [&apos;es2015&apos;, &apos;react&apos;]</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = config;</span><br></pre></td></tr></table></figure></p><p>entry: 指定打包的入口文件 main.js。<br>output：配置打包结果，path定义了输出的文件夹，filename则定义了打包结果文件的名称。<br>devServer：设置服务器端口号为 8888，端口后你可以自己设定 。<br>module：定义了对模块的处理逻辑，这里可以用loaders定义了一系列的加载器，以及一些正则。当需要加载的文件匹配test的正则时，就会调用后面的loader对文件进行处理，这正是webpack强大的原因。<br>现在打开 package.json 文件，找到 “scripts” 中的 “test” “echo \”Error: no test specified\” &amp;&amp; exit 1″ 使用以下代码替换：</p><p>“start”: “webpack-dev-server –hot”<br>替换后的 package.json 文件 内容如下：</p><p>$ cat package.json<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;runoob-react-test&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;cllgeek test&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;webpack-dev-server --hot&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;react&quot;: &quot;^0.14.7&quot;,</span><br><span class="line">    &quot;react-dom&quot;: &quot;^0.14.7&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在我们可以使用 npm start 命令来启动服务。–hot 命令会在文件变化后重新载入，这样我们就不需要在代码修改后重新刷新浏览器就能看到变化。</p><h2 id="第六步、index-html"><a href="#第六步、index-html" class="headerlink" title="第六步、index.html"></a>第六步、index.html</h2><p>设置 div id = “app” 为我们应用的根元素，并引入 index.js 脚本文件。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset = &quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;React App - cllgeek(cllgeek.com)&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id = &quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script src = &quot;index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><h2 id="第七步、App-jsx-和-main-js"><a href="#第七步、App-jsx-和-main-js" class="headerlink" title="第七步、App.jsx 和 main.js"></a>第七步、App.jsx 和 main.js</h2><p>这是第一个 react 组件。后面的章节我们会详细介绍 React 组件。这个组件将输出 Hello World!!!。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">App.jsx 文件代码</span><br><span class="line">import React from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        Hello World!!!</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure></p><p>我们需要引入组件并将其渲染到根元素 App 上，这样我们才可以在浏览器上看到它。<br>main.js 文件代码<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;;</span><br><span class="line"></span><br><span class="line">import App from &apos;./App.jsx&apos;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.getElementById(&apos;app&apos;))</span><br></pre></td></tr></table></figure></p><p>注意：<br>如果想要组件可以在任何的应用中使用，需要在创建后使用 export 将其导出，在使用组件的文件使用 import将其导入。</p><h2 id="第八步、运行服务"><a href="#第八步、运行服务" class="headerlink" title="第八步、运行服务"></a>第八步、运行服务</h2><p>完成以上配置后，我们即可运行该服务：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm start</span><br><span class="line">通过浏览器访问 http://localhost:7777/，输出结果如下:</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      react项目搭建
    
    </summary>
    
      <category term="react" scheme="http://yoursite.com/categories/react/"/>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
      <category term="项目搭建" scheme="http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>git区分大小写</title>
    <link href="http://yoursite.com/2019/07/13/git/git-capitalize/"/>
    <id>http://yoursite.com/2019/07/13/git/git-capitalize/</id>
    <published>2019-07-13T09:50:46.000Z</published>
    <updated>2019-07-13T09:50:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>其实 git 默认对于文件名大小写是不敏感的,所以上面你修改了首字母大写,但是git 并没有发现代码任何改动.</p><p>那么如何才能让 git 识别文件名大小写变化.</p><p>一  配置git 使其对文件名大小写敏感</p><p>git config core.ignorecase false</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Administrator@SC-202102021413 F:\xunlian\hexo</span><br><span class="line">&gt;git config core.ignorecase false</span><br></pre></td></tr></table></figure><p>二 从git 本地仓库删除此文件,然后添加再提交</p><p>(1) 删除<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Administrator@SC-202102021413 F:\xunlian\hexo</span><br><span class="line">&gt;git rm readme.md</span><br></pre></td></tr></table></figure></p><p>(2) 重新添加<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Administrator@SC-202102021413 F:\xunlian\hexo</span><br><span class="line">&gt;git add Readme.md</span><br></pre></td></tr></table></figure></p><p>(3)提交<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Administrator@SC-202102021413 F:\xunlian\hexo</span><br><span class="line">&gt;git commit -m &apos;Readme.md&apos;</span><br></pre></td></tr></table></figure></p><p>推荐第一种方法,配置好git 对文件名大小写敏感.</p>]]></content>
    
    <summary type="html">
    
      git区分大小写
    
    </summary>
    
      <category term="辅助工具" scheme="http://yoursite.com/categories/%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="辅助工具" scheme="http://yoursite.com/tags/%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git设置上传忽略</title>
    <link href="http://yoursite.com/2019/07/13/git/git-neglect/"/>
    <id>http://yoursite.com/2019/07/13/git/git-neglect/</id>
    <published>2019-07-13T09:50:46.000Z</published>
    <updated>2019-07-13T09:50:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git设置上传忽略"><a href="#Git设置上传忽略" class="headerlink" title="Git设置上传忽略"></a>Git设置上传忽略</h1><h2 id="忽略语法规则"><a href="#忽略语法规则" class="headerlink" title="忽略语法规则"></a>忽略语法规则</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># 忽略*.o和*.a文件</span><br><span class="line"></span><br><span class="line"> *.[oa]</span><br><span class="line"></span><br><span class="line"># 忽略*.b和*.B文件，my.b除外</span><br><span class="line"></span><br><span class="line">*.[bB]</span><br><span class="line"></span><br><span class="line">!my.b</span><br><span class="line"></span><br><span class="line"># 忽略dbg文件和dbg目录</span><br><span class="line"></span><br><span class="line">dbg</span><br><span class="line"></span><br><span class="line"># 只忽略dbg目录，不忽略dbg文件</span><br><span class="line"></span><br><span class="line">dbg/</span><br><span class="line"></span><br><span class="line"># 只忽略dbg文件，不忽略dbg目录</span><br><span class="line"></span><br><span class="line">dbg</span><br><span class="line"></span><br><span class="line">!dbg/</span><br><span class="line"></span><br><span class="line"># 只忽略当前目录下的dbg文件和目录，子目录的dbg不在忽略范围内</span><br><span class="line"></span><br><span class="line">/dbg</span><br><span class="line"></span><br><span class="line"># 忽略所有 .a 结尾的文件</span><br><span class="line">*.a</span><br><span class="line"></span><br><span class="line"># 但 lib.a 除外</span><br><span class="line">!lib.a </span><br><span class="line"></span><br><span class="line"># 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span><br><span class="line">/TODO </span><br><span class="line"></span><br><span class="line"># 忽略 build/ 目录下的所有文件</span><br><span class="line">build/ </span><br><span class="line"></span><br><span class="line"># 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br><span class="line">doc/*.txt</span><br></pre></td></tr></table></figure><p>下面介绍3种方法来设置上传忽略配置：</p><h2 id="【方法一】"><a href="#【方法一】" class="headerlink" title="【方法一】"></a>【方法一】</h2><p> 通过配置.git/info/exclude文件来忽略文件。这种方式对仓库全局有效，只能对自己本地仓库有作用，其他人没办法通过这种方式来共享忽略规则，除非他人也修改其本地仓库的该文件。</p><h2 id="【方法二】"><a href="#【方法二】" class="headerlink" title="【方法二】"></a>【方法二】</h2><p> 通过.git/config配置文件的core. Excludesfile选项，指定一个忽略规则文件（完整路径），如下图所示。忽略规则在文件e:/gitignore.txt中（当然该文件名可以任意取）。在config的[remote “origin”]上一行添加 excludesfile = e:/gitignore.text即可<br> <figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> [core]</span><br><span class="line">repositoryformatversion = 0</span><br><span class="line">filemode = false</span><br><span class="line">bare = false</span><br><span class="line">logallrefupdates = true</span><br><span class="line">symlinks = false</span><br><span class="line">ignorecase = true</span><br><span class="line">    excludesfile = e:/gitignore.text</span><br><span class="line">[remote &quot;origin&quot;]</span><br></pre></td></tr></table></figure></p><p> 该方式的作用域是也全局的。</p><h2 id="【方式三】"><a href="#【方式三】" class="headerlink" title="【方式三】"></a>【方式三】</h2><p> 在项目根目录下创建.gitignore文件如果已经创建则不用创建然后在该文件中添加忽略语法<br> .gitignore文件对其所在的目录及所在目录的全部子目录均有效。通过将.gitignore文件添加到仓库，其他开发者更新该文件到本地仓库，以共享同一套忽略规则。</p>]]></content>
    
    <summary type="html">
    
      Git设置上传忽略
    
    </summary>
    
      <category term="辅助工具" scheme="http://yoursite.com/categories/%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="辅助工具" scheme="http://yoursite.com/tags/%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
      <category term="配置" scheme="http://yoursite.com/tags/%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>ECMAScript 提案</title>
    <link href="http://yoursite.com/2019/07/13/javaScript/ECMAScript/"/>
    <id>http://yoursite.com/2019/07/13/javaScript/ECMAScript/</id>
    <published>2019-07-13T09:50:46.000Z</published>
    <updated>2019-07-13T09:50:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="标准的流程包括五个步骤："><a href="#标准的流程包括五个步骤：" class="headerlink" title="标准的流程包括五个步骤："></a>标准的流程包括五个步骤：</h2><h3 id="stage0-strawman"><a href="#stage0-strawman" class="headerlink" title="stage0 strawman"></a>stage0 strawman</h3><p>任何讨论、想法、改变或者还没加到提案的特性都在这个阶段。只有TC39成员可以提交。</p><h3 id="stage1-proposal"><a href="#stage1-proposal" class="headerlink" title="stage1 proposal"></a>stage1 proposal</h3><p>（1）产出一个正式的提案。<br>（2）发现潜在的问题，例如与其他特性的关系，实现难题。<br>（3）提案包括详细的API描述，使用例子，以及关于相关的语义和算法。</p><h3 id="stage2-draft"><a href="#stage2-draft" class="headerlink" title="stage2 draft"></a>stage2 draft</h3><p>（1）提供一个初始的草案规范，与最终标准中包含的特性不会有太大差别。草案之后，原则上只接受增量修改。<br>（2）开始实验如何实现，实现形式包括polyfill, 实现引擎（提供草案执行本地支持），或者编译转换（例如babel）</p><h3 id="stage3-candidate"><a href="#stage3-candidate" class="headerlink" title="stage3 candidate"></a>stage3 candidate</h3><p>（1）候选阶段，获得具体实现和用户的反馈。此后，只有在实现和使用过程中出现了重大问题才会修改。 （2）规范文档必须是完整的，评审人和ECMAScript的编辑要在规范上签字。<br>（3）至少要在一个浏览器中实现，提供polyfill或者babel插件。</p><h3 id="stage4-finished"><a href="#stage4-finished" class="headerlink" title="stage4 finished"></a>stage4 finished</h3><p>（1）已经准备就绪，该特性会出现在下个版本的ECMAScript规范之中。<br>（2）需要通过有2个独立的实现并通过验收测试，以获取使用过程中的重要实践经验。</p><h2 id="TC39什么鬼？什么成分？主要业务是什么？"><a href="#TC39什么鬼？什么成分？主要业务是什么？" class="headerlink" title="TC39什么鬼？什么成分？主要业务是什么？"></a>TC39什么鬼？什么成分？主要业务是什么？</h2><p>一个推动 JavaScript 发展的委员会，由各个主流浏览器厂商的代表构成。制定ECMAScript标准，标准生成的流程，并实现。</p><h2 id="相关-stage0-4的具体内容查看地址"><a href="#相关-stage0-4的具体内容查看地址" class="headerlink" title="相关 stage0-4的具体内容查看地址"></a>相关 stage0-4的具体内容查看地址</h2><p>stage0 的提案 <a href="https://github.com/tc39/proposals/blob/master/stage-0-proposals.md" target="_blank" rel="noopener">https://github.com/tc39/proposals/blob/master/stage-0-proposals.md</a><br>stage1 - 4 的提案 <a href="https://github.com/tc39/proposa" target="_blank" rel="noopener">https://github.com/tc39/proposa</a></p><p>推荐阅读：<br><a href="https://zhuanlan.zhihu.com/p/27762556" target="_blank" rel="noopener">精读 TC39 与 ECMAScript 提案</a></p>]]></content>
    
    <summary type="html">
    
      了解ECMAScript从提案到标准的制定落地
    
    </summary>
    
      <category term="ECMAScript" scheme="http://yoursite.com/categories/ECMAScript/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="ECMAScript提案" scheme="http://yoursite.com/tags/ECMAScript%E6%8F%90%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>js异常处理机制详解</title>
    <link href="http://yoursite.com/2019/07/13/javaScript/try-catch/"/>
    <id>http://yoursite.com/2019/07/13/javaScript/try-catch/</id>
    <published>2019-07-13T09:50:46.000Z</published>
    <updated>2019-07-13T15:07:46.457Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>​ 从ES3开始，js也提供了类似的异常处理机制，从而让js代码变的更健壮，及时执行的过程中出现了异常，也可以让程序具有了一部分的异常恢复能力。</p></blockquote><h3 id="一、Javascript的异常捕获机制"><a href="#一、Javascript的异常捕获机制" class="headerlink" title="一、Javascript的异常捕获机制"></a>一、Javascript的异常捕获机制</h3><h4 id="1-1-基本的try…catch语句"><a href="#1-1-基本的try…catch语句" class="headerlink" title="1.1 基本的try…catch语句"></a>1.1 基本的try…catch语句</h4><p>ES3开始引入了 try-catch 语句，是 JavaScript 中处理异常的标准方式。</p><p>语法：<br>try{ </p><pre><code>可能发生异常的代码 </code></pre><p>}catch(error){ </p><pre><code>发生错误执行的代码 </code></pre><p>}</p><p>看下面的代码：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    try&#123;</span><br><span class="line">        console.log(b);</span><br><span class="line">        console.log(&quot;我不会输出的，不要找了&quot;)</span><br><span class="line"></span><br><span class="line">    &#125;catch(error)&#123;</span><br><span class="line">        console.log(&quot;发生错误了&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&quot;我try catch后面的代码&quot;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="./images/try-catch/try-catch0.png" alt="控制台："><br><strong> 说明：</strong></p><ol><li><p>把有可能出的问题的代码放在 try语句中。try语句中可以理论上可以写任何的代码，只要有一行代码出现问题，整个程序的执行流程就会立即调到catch语句中执行。</p></li><li><p>一旦try中有一行代码发生异常，则这行出错代码的后面的try中的其他语句都不会再执行。比如上面代码中的console.log(b);这行代码会出错，则立即去执行catch中的代码。所以console.log(“我不会输出的，不要找了”)这行代码则不会再执行</p></li><li><p>在执行catch中的代码之前，js引擎会首先根据错误类型自动创建一个错误，并通过catch后面的参数传递到catch中。不同的浏览器创建的error对象不一样，但是同创他们都包含一个message属性，值是这个错误的一些信息。</p></li><li><p>catch中的代码执行完毕之后，会继续执行后面的代码，程序不会停止下来。</p></li></ol><h4 id="1-2-finally语句"><a href="#1-2-finally语句" class="headerlink" title="1.2 finally语句"></a>1.2 finally语句</h4><p>在 try…catch 中，try 中一旦出现错误则其他语句不能执行，如果不出现错误则 catch 中的语句不会执行。</p><p>Javascript 参考其他编程语言，也提供了一种 finally 语句：不管 try 中的语句有没有错误，在最后都会执行 finally 中的语句。</p><p>即：try 中语句不发生错误执行完毕后会执行 finally 中的语句，try 中的语句发生错误，则执行 catch中的语句，catch 中的语句执行完毕后也会执行 finally 中的语句。</p><p>语法：</p><p>try{</p><p>}catch(error){</p><p>}finally{</p><p>}</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    try&#123;</span><br><span class="line">        console.log(b);</span><br><span class="line">        console.log(&quot;我不会输出的，不要找了&quot;)</span><br><span class="line"></span><br><span class="line">    &#125;catch(error)&#123;</span><br><span class="line">        console.log(&quot;发生错误了&quot;)</span><br><span class="line">    &#125;finally &#123;</span><br><span class="line">        console.log(&quot;不管发生不发生错误，我都会执行&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&quot;我try catch后面的代码&quot;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="./images/try-catch/try-catch1.png" alt="控制台："></p><blockquote><p>所以在 finally 中我们可以放置我们必须要执行的代码。</p></blockquote><p><strong>注意：</strong></p><ol><li>在js中，如果添加了 finally 语句，则 catch 语句可以省略。所以下面的代码也是正确的。</li><li>如果没有 catch 语句，则一旦发生错误就无法捕获这个错误，所以在执行完 finally 中的语句后，程序就会立即停止了。</li><li>所以，在实际使用中，最好一直带着 catch 语句。</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    try&#123;</span><br><span class="line">        console.log(b);</span><br><span class="line">        console.log(&quot;我不会输出的，不要找了&quot;)</span><br><span class="line"></span><br><span class="line">    &#125;finally &#123;</span><br><span class="line">        console.log(&quot;不管发生不发生错误，我都会执行&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&quot;我try catch后面的代码&quot;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="./images/try-catch/try-catch2.png" alt="控制台："></p><h4 id="1-3-合理使用try…catch"><a href="#1-3-合理使用try…catch" class="headerlink" title="1.3 合理使用try…catch"></a>1.3 合理使用try…catch</h4><p>当 try-catch 语句中发生错误时，浏览器会认为错误已经被处理了，浏览器就不再报告错误了。这也是最简单的一种情况。</p><p>​ 使用 try-catch 最适合处理那些我们无法控制的错误。假设你在使用一个大型 JavaScript 库中的 函数，该函数可能会有意无意地抛出一些错误。由于我们不能修改这个库的源代码，所以大可将对该函 数的调用放在 try-catch 语句当中，一有什么错误发生，也好可以恰当地处理它们。</p><p>​ 在明明知道自己的代码会发生错误时，再使用 try-catch 语句就不太合适了。例如，如果 传给函数的参数是字符串而非数值，就会造成函数出错，那么就应该先检查参数的类型，然后再决定 如何去做。在这种情况下，不应用使用 try-catch 语句。因为try…catch语句比较是比较好资源的事情。</p><h3 id="二、throw主动抛出异常"><a href="#二、throw主动抛出异常" class="headerlink" title="二、throw主动抛出异常"></a>二、throw主动抛出异常</h3><h4 id="2-1-抛出js内置错误类型的对象"><a href="#2-1-抛出js内置错误类型的对象" class="headerlink" title="2.1 抛出js内置错误类型的对象"></a>2.1 抛出js内置错误类型的对象</h4><blockquote><p>在大部分的代码执行过程中，都是出现错误的时候，由浏览器(javascript引擎)抛出异常，然后程序或者停止执行，或被try…catch 捕获。</p></blockquote><p>​ 然而有时候我们在检测到一些不合理的情况发生的时候也可以主动抛出错误。</p><p>​ 使用 throw 关键字抛出来主动抛出异常。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    throw new Error(&quot;你好坏&quot;);</span><br><span class="line">    console.log(&quot;执行不到这里的&quot;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="./images/try-catch/try-catch3.png" alt="控制台："><br><strong>注意：</strong></p><ol><li><p>thow后面就是我们要抛出的异常对象。在以前的时候都是出现错误的时候浏览器抛出异常对象，只是现在是我们自己主动抛出的异常对象。</p></li><li><p>只要有异常对象抛出，不管是浏览器抛出的，还是代码主动抛出，都会让程序停止执行。如果想让程序继续执行，则有也可以用try…catch来捕获。</p></li><li><p>每一个错误类型都可以传入一个参数，表示实际的错误信息。</p></li><li><p>我们可以在适当的时候抛出任何我们想抛出的异常类型。throw new SyntaxError(“语法错误…”);</p></li></ol><p>看下面的代码:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    /*该函数接收一个数字，返回他的平方。*/</span><br><span class="line">    function foo(num) &#123;</span><br><span class="line">        if(typeof num == &quot;number&quot;)&#123;</span><br><span class="line">            return num * num;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            throw new TypeError(&quot;类型错误，你应该传入一个数字...&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(foo(33))</span><br><span class="line">    console.log(foo(&quot;abc&quot;))</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="./images/try-catch/try-catch4.png" alt="控制台："></p><h4 id="2-2-抛出自定义类型的错误对象"><a href="#2-2-抛出自定义类型的错误对象" class="headerlink" title="2.2 抛出自定义类型的错误对象"></a>2.2 抛出自定义类型的错误对象</h4><p>我们不仅仅可以抛出js内置的错误类型的对象，也可以自定义错误类型，然后抛出自定义错误类型的对象。</p><p>​ 如果要自定义错误类型，只需要继承任何一个自定义错误类型都可以。一般直接继承Error即可。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    function MyError(message) &#123;</span><br><span class="line">        this.message = &quot;注意：这是自定义的错误&quot;</span><br><span class="line">        this.name = &quot;自定义错误&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    MyError.prototype = new Error();</span><br><span class="line">    try &#123;</span><br><span class="line">        throw new MyError(&quot;注意：这是自定义错误类型&quot;)</span><br><span class="line">    &#125;catch (error)&#123;</span><br><span class="line">        console.log(error.message)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="./images/try-catch/try-catch5.png" alt="控制台："></p>]]></content>
    
    <summary type="html">
    
      js异常处理机制详解
    
    </summary>
    
      <category term="javaScript基础" scheme="http://yoursite.com/categories/javaScript%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
      <category term="异常处理" scheme="http://yoursite.com/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    
      <category term="try-catch" scheme="http://yoursite.com/tags/try-catch/"/>
    
  </entry>
  
  <entry>
    <title>thinkjs项目目录解析</title>
    <link href="http://yoursite.com/2019/07/13/node/application/"/>
    <id>http://yoursite.com/2019/07/13/node/application/</id>
    <published>2019-07-13T09:50:46.000Z</published>
    <updated>2019-07-13T15:10:55.099Z</updated>
    
    <content type="html"><![CDATA[<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><img src="/2019/07/13/node/application/directory.png" title="目录结构"><p>注：指定不同的模式创建的项目目录机构可能有细微的差别，但总体是类似的</p><h3 id="nginx-conf"><a href="#nginx-conf" class="headerlink" title="nginx.conf"></a>nginx.conf</h3><p>nginx 的配置文件，建议线上使用 nginx 做反向代理。</p><h3 id="src"><a href="#src" class="headerlink" title="src"></a>src</h3><p>源代码目录，使用 –es6 参数创建项目才有该目录。项目启动时会自动将 src 目录下的文件编译到 app 目录下。</p><p>如果没有使用 ES6 特性创建项目，则直接有 app/ 目录。</p><h3 id="src-common"><a href="#src-common" class="headerlink" title="src/common"></a>src/common</h3><p>通用模块目录，项目目录都是按模块来划分的，common 模块下存放一些通用的处理逻辑。</p><h3 id="src-common-bootstrap"><a href="#src-common-bootstrap" class="headerlink" title="src/common/bootstrap"></a>src/common/bootstrap</h3><p>项目启动目录，该目录下的文件会自动加载，无需手动 require 。</p><p>可以在这个目录下文件里定义一些全局函数、注册中间件等常用的功能。</p><p>定义全局函数<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// src/common/bootstrap/fn.js global.formatDate = obj =&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里定义了一个全局函数 formatDate，那么项目里任何地方都可以直接使用该函数。</p><p>注册中间件<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// src/common/bootstrap/middleware.js think.middleware(&quot;replace_image&quot;, http =&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这里定义了一个中间件 replace_image，那么就可以在配置文件 hook.js 里将该中间件注册进去了。</p><p>注：bootstrap 只能放在 common 模块里。</p><h3 id="src-common-config"><a href="#src-common-config" class="headerlink" title="src/common/config"></a>src/common/config</h3><p>配置文件，这里放一些通用的配置。</p><p>其中：路由配置、hook 配置、本地化配置等必须放在这里。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;; /**</span><br><span class="line"> * config</span><br><span class="line"> */ export default &#123; //key: value &#125;;</span><br></pre></td></tr></table></figure></p><h3 id="src-common-controller"><a href="#src-common-controller" class="headerlink" title="src/common/controller"></a>src/common/controller</h3><p>控制器，放一些通用的控制器。其中 error.js 里错误处理的不同行为，项目里可以根据需要进行修改。</p><h3 id="src-common-runtime"><a href="#src-common-runtime" class="headerlink" title="src/common/runtime"></a>src/common/runtime</h3><p>项目运行时生成的一些目录，如：缓存文件目录，用户上传的文件临时存放的目录。</p><h3 id="src-home"><a href="#src-home" class="headerlink" title="src/home"></a>src/home</h3><p>home 模块，项目默认模块。可以在 src/common/config/config.js 中修改配置 default_module 来重新定义默认模块。</p><h3 id="src-home-logic"><a href="#src-home-logic" class="headerlink" title="src/home/logic"></a>src/home/logic</h3><p>逻辑处理。每个操作执行前可以先进行逻辑校验，可以包含：参数是否合法、提交的数据是否正常、当前用户是否已经登录、当前用户是否有权限等。这样可以降低 controller 里的 action 的复杂度。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;; /**</span><br><span class="line"> * logic</span><br><span class="line"> * @param  &#123;&#125; []</span><br><span class="line"> * @return &#123;&#125;     []</span><br><span class="line"> */ export default class extends think.logic.base &#123; /**</span><br><span class="line">   * index action logic</span><br><span class="line">   * @return &#123;&#125; []</span><br><span class="line">   */ indexAction()&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="src-home-controller"><a href="#src-home-controller" class="headerlink" title="src/home/controller"></a>src/home/controller</h3><p>控制器。一个 url 对应一个 controller 下的 action。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;; import Base from &quot;./base.js&quot;; export default class extends Base &#123; /**</span><br><span class="line">   * index action</span><br><span class="line">   * @return &#123;Promise&#125; []</span><br><span class="line">   */ indexAction()&#123; //auto render template file index_index.html return this.display();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="src-home-model"><a href="#src-home-model" class="headerlink" title="src/home/model"></a>src/home/model</h3><p>模型。数据库相关操作。</p><h3 id="view"><a href="#view" class="headerlink" title="view"></a>view</h3><p>视图目录，存放对应的模版文件。如果支持国际化和多主题，那么视图目录下需要有对应的子目录。</p><h3 id="www"><a href="#www" class="headerlink" title="www"></a>www</h3><p>项目的可访问根目录，nginx 里的根目录会配置到此目录下。</p><h3 id="www-development-js"><a href="#www-development-js" class="headerlink" title="www/development.js"></a>www/development.js</h3><p>开发模式下项目的入口文件，可以根据项目需要进行修改。www/production.js 为线上的入口文件。</p><p>入口文件的代码类似如下，可以根据项目需要进行修改。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var thinkjs = require(&quot;thinkjs&quot;); var path = require(&quot;path&quot;); var rootPath = path.dirname(__dirname); var instance = new thinkjs(&#123;</span><br><span class="line">  APP_PATH: rootPath + &quot;/app&quot;,</span><br><span class="line">  ROOT_PATH: rootPath,</span><br><span class="line">  RESOURCE_PATH: __dirname,</span><br><span class="line">  env: &quot;development&quot; &#125;);</span><br><span class="line"></span><br><span class="line">instance.compile(&#123;retainLines: true, log: true&#125;);</span><br><span class="line"></span><br><span class="line">instance.run();</span><br></pre></td></tr></table></figure></p><h3 id="www-static"><a href="#www-static" class="headerlink" title="www/static"></a>www/static</h3><p>存放一些静态资源文件。</p>]]></content>
    
    <summary type="html">
    
      thinkjs项目目录解析
    
    </summary>
    
      <category term="node" scheme="http://yoursite.com/categories/node/"/>
    
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
      <category term="目录结构" scheme="http://yoursite.com/tags/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
    
      <category term="thinkjs" scheme="http://yoursite.com/tags/thinkjs/"/>
    
  </entry>
  
  <entry>
    <title>node异常处理机制详解</title>
    <link href="http://yoursite.com/2019/07/13/node/try-catch/"/>
    <id>http://yoursite.com/2019/07/13/node/try-catch/</id>
    <published>2019-07-13T09:50:46.000Z</published>
    <updated>2019-07-13T15:10:11.760Z</updated>
    
    <content type="html"><![CDATA[<hr><ol><li>assert()</li><li>assert.ok()</li><li>assert.equal()</li><li>assert.notEqual()</li><li>assert.deepEqual()</li><li>assert.notDeepEqual()</li><li>assert.strictEqual()</li><li>assert.notStrictEqual()</li><li>assert.throws()</li><li>assert.ifError()</li><li>assert.fail()</li></ol><hr><p>assert模块是Node的内置模块，主要用于断言。如果表达式不符合预期，就抛出一个错误。该模块提供11个方法，但只有少数几个是常用的。</p><h3 id="1-assert"><a href="#1-assert" class="headerlink" title="1. assert()"></a>1. assert()</h3><p>assert方法接受两个参数，当第一个参数对应的布尔值为true时，不会有任何提示，返回undefined。当第一个参数对应的布尔值为false时，会抛出一个错误，该错误的提示信息就是第二个参数设定的字符串。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 格式</span><br><span class="line">assert(value, message)</span><br><span class="line"></span><br><span class="line">// 例子</span><br><span class="line">var assert = require(&apos;assert&apos;);</span><br><span class="line"></span><br><span class="line">function add (a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var expected = add(1,2);</span><br><span class="line">assert( expected === 3, &apos;预期1加2等于3&apos;);</span><br></pre></td></tr></table></figure><p>上面代码不会有任何输出，因为assert方法的第一个参数是true。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assert( expected === 4, &apos;预期1加2等于3&apos;)</span><br><span class="line">// AssertionError: 预期1加2等于3</span><br></pre></td></tr></table></figure><p>上面代码会抛出一个错误，因为assert方法的第一个参数是false。</p><h3 id="2-assert-ok"><a href="#2-assert-ok" class="headerlink" title="2. assert.ok()"></a>2. assert.ok()</h3><p>ok是assert方法的另一个名字，与assert方法完全一样。</p><h3 id="3-assert-equal"><a href="#3-assert-equal" class="headerlink" title="3. assert.equal()"></a>3. assert.equal()</h3><p>equal方法接受三个参数，第一个参数是实际值，第二个是预期值，第三个是错误的提示信息。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 格式</span><br><span class="line">assert.equal(actual, expected, [message])</span><br><span class="line"></span><br><span class="line">assert.equal(true, value, message);</span><br><span class="line">// 等同于</span><br><span class="line">assert(value, message);</span><br><span class="line"></span><br><span class="line">// 例子</span><br><span class="line">var assert = require(&apos;assert&apos;);</span><br><span class="line"></span><br><span class="line">function add (a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var expected = add(1,2);</span><br><span class="line"></span><br><span class="line">// 以下三句效果相同</span><br><span class="line">assert(expected == 3, &apos;预期1+2等于3&apos;);</span><br><span class="line">assert.ok(expected == 3, &apos;预期1+2等于3&apos;);</span><br><span class="line">assert.equal(expected, 3, &apos;预期1+2等于3&apos;);</span><br></pre></td></tr></table></figure><p>equal方法内部使用的是相等运算符（==），而不是严格运算符（===），进行比较运算。</p><h3 id="4-assert-notEqual"><a href="#4-assert-notEqual" class="headerlink" title="4. assert.notEqual()"></a>4. assert.notEqual()</h3><p>notEqual方法的用法与equal方法类似，但只有在实际值等于预期值时，才会抛出错误。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 格式</span><br><span class="line">assert.notEqual(actual, expected, [message])</span><br><span class="line"></span><br><span class="line">// 用法</span><br><span class="line">var assert = require(&apos;assert&apos;);</span><br><span class="line"></span><br><span class="line">function add (a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var expected = add(1,2);</span><br><span class="line"></span><br><span class="line">// 以下三种写法效果相同</span><br><span class="line">assert(expected != 4, &apos;预期不等于4&apos;);</span><br><span class="line">assert.ok(expected != 4, &apos;预期不等于4&apos;);</span><br><span class="line">assert.notEqual(expected, 4, &apos;预期不等于4&apos;);</span><br></pre></td></tr></table></figure><p>notEqual方法内部使用不相等运算符（!=），而不是严格不相等运算符（!==），进行比较运算。</p><h3 id="5-assert-deepEqual"><a href="#5-assert-deepEqual" class="headerlink" title="5. assert.deepEqual()"></a>5. assert.deepEqual()</h3><p>deepEqual方法用来比较两个对象。只要它们的属性一一对应，且值都相等，就认为两个对象相等，否则抛出一个错误。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 格式</span><br><span class="line">assert.deepEqual(actual, expected, [message])</span><br><span class="line"></span><br><span class="line">// 例子</span><br><span class="line">var assert = require(&apos;assert&apos;);</span><br><span class="line"></span><br><span class="line">var list1 = [1, 2, 3, 4, 5];</span><br><span class="line">var list2 = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">assert.deepEqual(list1, list2, &apos;预期两个数组应该有相同的属性&apos;);</span><br><span class="line"></span><br><span class="line">var person1 = &#123; &quot;name&quot;:&quot;john&quot;, &quot;age&quot;:&quot;21&quot; &#125;;</span><br><span class="line">var person2 = &#123; &quot;name&quot;:&quot;john&quot;, &quot;age&quot;:&quot;21&quot; &#125;;</span><br><span class="line"></span><br><span class="line">assert.deepEqual(person1, person2, &apos;预期两个对象应该有相同的属性&apos;);</span><br></pre></td></tr></table></figure><h3 id="6-assert-notDeepEqual"><a href="#6-assert-notDeepEqual" class="headerlink" title="6. assert.notDeepEqual()"></a>6. assert.notDeepEqual()</h3><p>notDeepEqual方法与deepEqual方法正好相反，用来断言两个对象是否不相等。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 格式</span><br><span class="line">assert.notDeepEqual(actual, expected, [message])</span><br><span class="line"></span><br><span class="line">// 例子</span><br><span class="line">var assert = require(&apos;assert&apos;);</span><br><span class="line"></span><br><span class="line">var list1 = [1, 2, ,3, 4, 5];</span><br><span class="line">var list2 = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">assert.notDeepEqual(list1, list2, &apos;预期两个对象不相等&apos;);</span><br><span class="line"></span><br><span class="line">var person1 = &#123; &quot;name&quot;:&quot;john&quot;, &quot;age&quot;:&quot;21&quot; &#125;;</span><br><span class="line">var person2 = &#123; &quot;name&quot;:&quot;jane&quot;, &quot;age&quot;:&quot;19&quot; &#125;;</span><br><span class="line"></span><br><span class="line">// deepEqual checks the elements in the objects are identical</span><br><span class="line">assert.notDeepEqual(person1, person2, &apos;预期两个对象不相等&apos;);</span><br></pre></td></tr></table></figure><h3 id="7-assert-strictEqual"><a href="#7-assert-strictEqual" class="headerlink" title="7. assert.strictEqual()"></a>7. assert.strictEqual()</h3><p>strictEqual方法使用严格相等运算符（===），比较两个表达式。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 格式</span><br><span class="line">assert.strictEqual(actual, expected, [message])</span><br><span class="line"></span><br><span class="line">// 例子</span><br><span class="line">var assert = require(&apos;assert&apos;);</span><br><span class="line"></span><br><span class="line">assert.strictEqual(1, &apos;1&apos;, &apos;预期严格相等&apos;);</span><br><span class="line">// AssertionError: 预期严格相等</span><br></pre></td></tr></table></figure><h3 id="8-assert-notStrictEqual"><a href="#8-assert-notStrictEqual" class="headerlink" title="8. assert.notStrictEqual()"></a>8. assert.notStrictEqual()</h3><p>assert.notStrictEqual方法使用严格不相等运算符（!==），比较两个表达式。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 格式</span><br><span class="line">assert.notStrictEqual(actual, expected, [message])</span><br><span class="line"></span><br><span class="line">// 例子</span><br><span class="line">var assert = require(&apos;assert&apos;);</span><br><span class="line"></span><br><span class="line">assert.notStrictEqual(1, true, &apos;预期严格不相等&apos;);</span><br></pre></td></tr></table></figure><h3 id="9-assert-throws"><a href="#9-assert-throws" class="headerlink" title="9. assert.throws()"></a>9. assert.throws()</h3><p>throws方法预期某个代码块会抛出一个错误，且抛出的错误符合指定的条件。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 格式</span><br><span class="line">assert.throws(block, [error], [message])</span><br><span class="line"></span><br><span class="line">// 例一，抛出的错误符合某个构造函数</span><br><span class="line">assert.throws(</span><br><span class="line">  function() &#123;</span><br><span class="line">    throw new Error(&quot;Wrong value&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">  Error,</span><br><span class="line">  &apos;不符合预期的错误类型&apos;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 例二、抛出错误的提示信息符合正则表达式</span><br><span class="line">assert.throws(</span><br><span class="line">  function() &#123;</span><br><span class="line">    throw new Error(&quot;Wrong value&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">  /value/,</span><br><span class="line">  &apos;不符合预期的错误类型&apos;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 例三、抛出的错误符合自定义函数的校验</span><br><span class="line">assert.throws(</span><br><span class="line">  function() &#123;</span><br><span class="line">    throw new Error(&quot;Wrong value&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">  function(err) &#123;</span><br><span class="line">    if ( (err instanceof Error) &amp;&amp; /value/.test(err) ) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &apos;不符合预期的错误类型&apos;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="10-assert-doesNotThrow"><a href="#10-assert-doesNotThrow" class="headerlink" title="10. assert.doesNotThrow()"></a>10. assert.doesNotThrow()</h3><p>doesNotThrow方法与throws方法正好相反，预期某个代码块不抛出错误。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 格式</span><br><span class="line">assert.doesNotThrow(block, [message])</span><br><span class="line"></span><br><span class="line">// 用法</span><br><span class="line">assert.doesNotThrow(</span><br><span class="line">  function() &#123;</span><br><span class="line">    console.log(&quot;Nothing to see here&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">  &apos;预期不抛出错误&apos;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="11-assert-ifError"><a href="#11-assert-ifError" class="headerlink" title="11. assert.ifError()"></a>11. assert.ifError()</h3><p>ifError方法断言某个表达式是否false，如果该表达式对应的布尔值等于true，就抛出一个错误。它对于验证回调函数的第一个参数十分有用，如果该参数为true，就表示有错误。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 格式</span><br><span class="line">assert.ifError(value)</span><br><span class="line"></span><br><span class="line">// 用法</span><br><span class="line">function sayHello(name, callback) &#123;</span><br><span class="line">  var error = false;</span><br><span class="line">  var str   = &quot;Hello &quot;+name;</span><br><span class="line">  callback(error, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// use the function</span><br><span class="line">sayHello(&apos;World&apos;, function(err, value)&#123;</span><br><span class="line">  assert.ifError(err);</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="12-assert-fail"><a href="#12-assert-fail" class="headerlink" title="12. assert.fail()"></a>12. assert.fail()</h3><p>fail方法用于抛出一个错误。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 格式</span><br><span class="line">assert.fail(actual, expected, message, operator)</span><br><span class="line"></span><br><span class="line">// 例子</span><br><span class="line">var assert = require(&apos;assert&apos;);</span><br><span class="line"></span><br><span class="line">assert.fail(21, 42, &apos;Test Failed&apos;, &apos;###&apos;)</span><br><span class="line">// AssertionError: Test Failed</span><br><span class="line">assert.fail(21, 21, &apos;Test Failed&apos;, &apos;###&apos;)</span><br><span class="line">// AssertionError: Test Failed</span><br><span class="line">assert.fail(21, 42, undefined, &apos;###&apos;)</span><br><span class="line">// AssertionError: 21 ### 42</span><br></pre></td></tr></table></figure><p>该方法共有四个参数，但是不管参数是什么值，它总是抛出一个错误。如果message参数对应的布尔值不为false，抛出的错误信息就是message，否则错误信息就是“实际值 + 分隔符 + 预期值”。</p>]]></content>
    
    <summary type="html">
    
      node异常处理机制详解
    
    </summary>
    
      <category term="node" scheme="http://yoursite.com/categories/node/"/>
    
    
      <category term="异常处理" scheme="http://yoursite.com/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>babel-stage-x</title>
    <link href="http://yoursite.com/2019/07/13/packaging/webpack/babel-stage/"/>
    <id>http://yoursite.com/2019/07/13/packaging/webpack/babel-stage/</id>
    <published>2019-07-13T09:50:46.000Z</published>
    <updated>2019-07-13T09:50:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="babel-stage"><a href="#babel-stage" class="headerlink" title="babel-stage"></a>babel-stage</h1><blockquote><p>关于stage-x第一次遇见是在第一次搭建react项目时，项目搭建完成后在里边写箭头函数时报错,但当时没有深究只是在网上查找了一个方案说在loader里添加一个stage-0就能解决但是但是没有总结，后来babel升级遇到几次.babelrc的代码报错一直没有找到原因，后来总算知道原来是缺少插件</p></blockquote><h2 id="如何区分Babel中的stage-0-stage-1-stage-2以及stage-3"><a href="#如何区分Babel中的stage-0-stage-1-stage-2以及stage-3" class="headerlink" title="如何区分Babel中的stage-0,stage-1,stage-2以及stage-3"></a>如何区分Babel中的stage-0,stage-1,stage-2以及stage-3</h2><h4 id="大家知道，将ES6代码编译为ES5时，我们常用到Babel这个编译工具。大家参考一些网上的文章或者官方文档，里面常会建议大家在-babelrc中输入如下代码："><a href="#大家知道，将ES6代码编译为ES5时，我们常用到Babel这个编译工具。大家参考一些网上的文章或者官方文档，里面常会建议大家在-babelrc中输入如下代码：" class="headerlink" title="大家知道，将ES6代码编译为ES5时，我们常用到Babel这个编译工具。大家参考一些网上的文章或者官方文档，里面常会建议大家在.babelrc中输入如下代码："></a>大家知道，将ES6代码编译为ES5时，我们常用到Babel这个编译工具。大家参考一些网上的文章或者官方文档，里面常会建议大家在.babelrc中输入如下代码：</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;: [</span><br><span class="line">      &quot;es2015&quot;,</span><br><span class="line">      &quot;react&quot;,</span><br><span class="line">      &quot;stage-0&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;plugins&quot;: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在来说明下这个配置文件是什么意思。首先，这个配置文件是针对babel 6的。Babel 6做了一系列模块化，不像Babel 5一样把所有的内容都加载。比如需要编译ES6，我们需要设置presets为”es2015”，也就是预先加载es6编译的相关模块，如果需要编译jsx，需要预先加载”react”这个模块。那问题来了，这个”stage-0”又代表什么呢？ 有了”react-0”，是否又有诸如”stage-1”, “stage-2”等等呢？<br>事实上， ”stage-0”是对ES7一些提案的支持，Babel通过插件的方式引入，让Babel可以编译ES7代码。当然由于ES7没有定下来，所以这些功能随时肯能被废弃掉的。现在我们来一一分析里面都有什么。</p><h2 id="法力无边的stage-0"><a href="#法力无边的stage-0" class="headerlink" title="法力无边的stage-0"></a>法力无边的stage-0</h2><p>为什么说“stage-0” 法力无边呢，因为它包含stage-1, stage-2以及stage-3的所有功能，同时还另外支持如下两个功能插件：</p><p><img src="https://babeljs.io/docs/plugins/transform-do-expressions" alt="* transform-do-expressions"><br><img src="https://babeljs.io/docs/plugins/transform-function-bind" alt="* transform-function-bind"></p><p>用过React的同学可能知道，jsx对条件表达式支持的不是太好，你不能很方便的使用if/else表达式，要么你使用三元表达，要么用函数。例如你不能写如下的代码：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var App = React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">        let &#123; color &#125; = this.props;</span><br><span class="line"></span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&quot;parents&quot;&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    if(color == &apos;blue&apos;) &#123;</span><br><span class="line">                        &lt;BlueComponent/&gt;;</span><br><span class="line">                    &#125;else if(color == &apos;red&apos;) &#123;</span><br><span class="line">                        &lt;RedComponent/&gt;;</span><br><span class="line">                    &#125;else &#123;</span><br><span class="line">                        &lt;GreenComponent/&gt;; &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在React中你只能写成这样：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var App = React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">        let &#123; color &#125; = this.props;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        const getColoredComponent = color =&gt; &#123;</span><br><span class="line">            if(color === &apos;blue&apos;) &#123; return &lt;BlueComponent/&gt;; &#125;</span><br><span class="line">            if(color === &apos;red&apos;) &#123; return &lt;RedComponent/&gt;; &#125;</span><br><span class="line">            if(color === &apos;green&apos;) &#123; return &lt;GreenComponent/&gt;; &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&quot;parents&quot;&gt;</span><br><span class="line">                &#123; getColoredComponent(color) &#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>transform-do-expressions 这个插件就是为了方便在 jsx写if/else表达式而提出的，我们可以重写下代码。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var App = React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">        let &#123; color &#125; = this.props;</span><br><span class="line"></span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&quot;parents&quot;&gt;</span><br><span class="line">                &#123;do &#123;</span><br><span class="line">                    if(color == &apos;blue&apos;) &#123;</span><br><span class="line">                        &lt;BlueComponent/&gt;;</span><br><span class="line">                    &#125;else if(color == &apos;red&apos;) &#123;</span><br><span class="line">                        &lt;RedComponent/&gt;;</span><br><span class="line">                    &#125;else &#123;</span><br><span class="line">                        &lt;GreenComponent/&gt;; &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>再说说 transform-function-bind, 这个插件其实就是提供过 :: 这个操作符来方便快速切换上下文， 如下面的代码：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">obj::func</span><br><span class="line">// is equivalent to:</span><br><span class="line">func.bind(obj)</span><br><span class="line"></span><br><span class="line">obj::func(val)</span><br><span class="line">// is equivalent to:</span><br><span class="line">func.call(obj, val)</span><br><span class="line"></span><br><span class="line">::obj.func(val)</span><br><span class="line">// is equivalent to:</span><br><span class="line">func.call(obj, val)</span><br><span class="line"></span><br><span class="line">// 再来一个复杂点的样例</span><br><span class="line"></span><br><span class="line">const box = &#123;</span><br><span class="line">  weight: 2,</span><br><span class="line">  getWeight() &#123; return this.weight; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const &#123; getWeight &#125; = box;</span><br><span class="line"></span><br><span class="line">console.log(box.getWeight()); // prints &apos;2&apos;</span><br><span class="line"></span><br><span class="line">const bigBox = &#123; weight: 10 &#125;;</span><br><span class="line">console.log(bigBox::getWeight()); // prints &apos;10&apos;</span><br><span class="line"></span><br><span class="line">// Can be chained:</span><br><span class="line">function add(val) &#123; return this + val; &#125;</span><br><span class="line"></span><br><span class="line">console.log(bigBox::getWeight()::add(5)); // prints &apos;15&apos;</span><br></pre></td></tr></table></figure><p>如果想更屌点，还可以写出更牛逼的代码：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const &#123; map, filter &#125; = Array.prototype;</span><br><span class="line"></span><br><span class="line">let sslUrls = document.querySelectorAll(&apos;a&apos;)</span><br><span class="line">                ::map(node =&gt; node.href)</span><br><span class="line">                ::filter(href =&gt; href.substring(0, 5) === &apos;https&apos;);</span><br><span class="line"></span><br><span class="line">console.log(sslUrls);</span><br></pre></td></tr></table></figure><h2 id="包罗万象的stage-1"><a href="#包罗万象的stage-1" class="headerlink" title="包罗万象的stage-1"></a>包罗万象的stage-1</h2><p>stage-1除了包含stage-2和stage-3，还包含了下面4个插件：</p><p><img src="http://babeljs.io/docs/plugins/transform-class-constructor-call" alt="* transform-class-constructor-call (Deprecated)"><br><img src="http://babeljs.io/docs/plugins/transform-class-properties" alt="* transform-class-properties"><br><img src="http://babeljs.io/docs/plugins/transform-export-extensions" alt="* transform-export-extensions"></p><h2 id="深藏不露的stage-2"><a href="#深藏不露的stage-2" class="headerlink" title="深藏不露的stage-2"></a>深藏不露的stage-2</h2><p>为什么说 stage-2深藏不露呢，因为它很低调，低调到你可以忽略它，但事实上，它很有内涵的。它除了覆盖stage-3的所有功能，还支持如下两个插件：</p><p><img src="http://babeljs.io/docs/plugins/syntax-trailing-function-commas/" alt="* syntax-trailing-function-commas"><br><img src="http://babeljs.io/docs/plugins/transform-object-rest-spread" alt="* ransform-object-reset-spread"></p><h3 id="syntax-trailing-function-commas"><a href="#syntax-trailing-function-commas" class="headerlink" title="syntax-trailing-function-commas"></a>syntax-trailing-function-commas</h3><p>这个插件让人一看觉得挺没趣的，让人甚至觉得它有点鸡肋。因它不是对ES6功能的增加，而是为了增强代码的可读性和可修改性而提出的。如下面的代码所示：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 假设有如下的一个函数，它有两个参数</span><br><span class="line">function clownPuppiesEverywhere(</span><br><span class="line">  param1,</span><br><span class="line">  param2</span><br><span class="line">) &#123; /* ... */ &#125;</span><br><span class="line"></span><br><span class="line">clownPuppiesEverywhere(</span><br><span class="line">  &apos;foo&apos;,</span><br><span class="line">  &apos;bar&apos;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 有一天，它需要变成3个参数，你需要这样修改</span><br><span class="line">function clownPuppiesEverywhere(</span><br><span class="line">  param1,</span><br><span class="line">- param2</span><br><span class="line">+ param2, // 这一行得加一个逗号</span><br><span class="line">+ param3  // 增加参数param3</span><br><span class="line">) &#123; /* ... */ &#125;</span><br><span class="line"></span><br><span class="line">clownPuppiesEverywhere(</span><br><span class="line">  &apos;foo&apos;,</span><br><span class="line">- &apos;bar&apos;</span><br><span class="line">+ &apos;bar&apos;, // 这里的修改为逗号</span><br><span class="line">+ &apos;baz&apos;  // 增加新的参数</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 看到没？ 我们修改了4行代码。。啊啊。修改了4行代码。</span><br></pre></td></tr></table></figure><p>修改了4行代码，嗯嗯嗯。。追求高效的程序猿想想了，以后如果有更多参数了，我是不是要改等多行，得想想，代码改的越少越好，于是有了下面的改动。。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 我们来重新定义一下函数</span><br><span class="line">function clownPuppiesEverywhere(</span><br><span class="line">  param1,</span><br><span class="line">  param2, // 注意这里，我们加了一个逗号哟</span><br><span class="line">) &#123; /* ... */ &#125;</span><br><span class="line"></span><br><span class="line">clownPuppiesEverywhere(</span><br><span class="line">  &apos;foo&apos;,</span><br><span class="line">  &apos;bar&apos;, // 这里我们也加了一个逗号</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 现在函数需要三个参数，我们来修改下</span><br><span class="line">function clownPuppiesEverywhere(</span><br><span class="line">  param1,</span><br><span class="line">  param2,</span><br><span class="line">+ param3, // 增加params3参数</span><br><span class="line">) &#123; /* ... */ &#125;</span><br><span class="line"></span><br><span class="line">clownPuppiesEverywhere(</span><br><span class="line">  &apos;foo&apos;,</span><br><span class="line">  &apos;bar&apos;,</span><br><span class="line">+ &apos;baz&apos;, // 增加第三个参数</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 叮叮当，我们只修改了两行代码就完成了，好开森</span><br></pre></td></tr></table></figure><p>说实话吧，这个功能让人有点很无语。不过程序猿对干净代码的追求真的很让人感动，还是值得鼓励的。这个就是stage-2中”尾逗号函数”功能。哈哈哈哈。</p><h3 id="transform-object-rest-spread"><a href="#transform-object-rest-spread" class="headerlink" title="transform-object-rest-spread"></a>transform-object-rest-spread</h3><p>再来说transform-object-rest-spread， 其实它是对 ES6中解构赋值的一个扩展，因为ES6只支持对数组的解构赋值，对对象是不支持的。如下面的代码所示：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 获取剩下的属性</span><br><span class="line"></span><br><span class="line">let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;</span><br><span class="line">console.log(x); // 1</span><br><span class="line">console.log(y); // 2</span><br><span class="line">console.log(z); // &#123; a: 3, b: 4 &#125;</span><br><span class="line"></span><br><span class="line">// 属性展开</span><br><span class="line">let n = &#123; x, y, ...z &#125;;</span><br><span class="line">console.log(n); // &#123; x: 1, y: 2, a: 3, b: 4 &#125;</span><br></pre></td></tr></table></figure><h2 id="大放异彩的stage3"><a href="#大放异彩的stage3" class="headerlink" title="大放异彩的stage3"></a>大放异彩的stage3</h2><p>为啥说stage3大放异彩呢？因为它支持大名鼎鼎的async和await, 这两个哥们可是解决(Ajax)回调函数的终极解决方法呀！管你什么异步，我都可以用同步的思维来写，ES7里面非常强悍的存在。总的来说，它包含如下两个插件:</p><p><img src="http://babeljs.io/docs/plugins/transform-async-to-generator/" alt="* transform-async-to-generator"><br><img src="http://babeljs.io/docs/plugins/transform-exponentiation-operator" alt="* transform-exponentiation-operator"></p><h3 id="transform-async-to-generator"><a href="#transform-async-to-generator" class="headerlink" title="transform-async-to-generator"></a>transform-async-to-generator</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">transform-async-to-generator主要用来支持ES7中的async和await， 我们可以写出下面的代码：</span><br><span class="line"></span><br><span class="line">const sleep = (timeout)=&gt;&#123;</span><br><span class="line">    return new Promise( (resolve, reject)=&gt;&#123;</span><br><span class="line">        setTimeout(resolve, timeout)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(async ()=&gt;&#123;</span><br><span class="line">    console.time(&quot;async&quot;);</span><br><span class="line">    await sleep(3000);</span><br><span class="line">    console.timeEnd(&quot;async&quot;);</span><br><span class="line">&#125;)()</span><br><span class="line">再来一个实际点的例子</span><br><span class="line"></span><br><span class="line">const fetchUsers = (user)=&gt;&#123;</span><br><span class="line">    return window.fetch(`https://api.douban.com/v2/user/$&#123;user&#125;`).then( res=&gt;res.json())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const getUser = async (user) =&gt;&#123;</span><br><span class="line">    let users = await fetchUsers(user);</span><br><span class="line">    console.log( users);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log( getUser(&quot;flyingzl&quot;)</span><br></pre></td></tr></table></figure><p>提示： 由于asycn和await是ES7里面的内容，现阶段不建议使用。为了顺利运行上面的代码，建议用webpack进行编译。</p><h3 id="transform-exponentiation-operator"><a href="#transform-exponentiation-operator" class="headerlink" title="transform-exponentiation-operator"></a>transform-exponentiation-operator</h3><p>transform-exponentiation-operator这个插件算是一个语法糖，可以通过**这个符号来进行幂操作，想当于Math.pow(a,b)。如下面的样例</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// x ** y</span><br><span class="line"></span><br><span class="line">let squared = 2 ** 2;</span><br><span class="line">// 相当于: 2 * 2</span><br><span class="line"></span><br><span class="line">let cubed = 2 ** 3;</span><br><span class="line">// 相当于: 2 * 2 * 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// x **= y</span><br><span class="line"></span><br><span class="line">let a = 2;</span><br><span class="line">a **= 2;</span><br><span class="line">// 相当于: a = a * a;</span><br><span class="line"></span><br><span class="line">let b = 3;</span><br><span class="line">b **= 3;</span><br><span class="line">// 相当于: b = b * b * b;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      如何区分Babel中的stage-0,stage-1,stage-2以及stage-3
    
    </summary>
    
      <category term="webpack" scheme="http://yoursite.com/categories/webpack/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
      <category term="packaging" scheme="http://yoursite.com/tags/packaging/"/>
    
      <category term="babel" scheme="http://yoursite.com/tags/babel/"/>
    
      <category term="stage" scheme="http://yoursite.com/tags/stage/"/>
    
  </entry>
  
  <entry>
    <title>自定义命令行配置</title>
    <link href="http://yoursite.com/2019/07/13/other/cmd/"/>
    <id>http://yoursite.com/2019/07/13/other/cmd/</id>
    <published>2019-07-13T09:50:46.000Z</published>
    <updated>2019-07-13T15:13:23.166Z</updated>
    
    <content type="html"><![CDATA[<p>平常在开发的时候因为项目多集合项目之间频繁切换非常浪费时间，因为启动项目是命令行所以想配置一个自定义命令来快速的进行项目切换和编辑器打开以及启动。</p><h3 id="mac下自定义命令的配置"><a href="#mac下自定义命令的配置" class="headerlink" title="mac下自定义命令的配置"></a>mac下自定义命令的配置</h3><p>在命令行里用 VSCode 打开 .zshrc 文件如图：<br><img src="/2019/07/13/other/cmd/zshrc.jpg" title="mac的path路径文件"></p><p>上图是我自定的自定义命令</p><h3 id="window-下自定义命令"><a href="#window-下自定义命令" class="headerlink" title="window 下自定义命令"></a>window 下自定义命令</h3>]]></content>
    
    <summary type="html">
    
      mac和window配置自定义命令行
    
    </summary>
    
      <category term="命令行" scheme="http://yoursite.com/categories/%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
    
      <category term="mac" scheme="http://yoursite.com/tags/mac/"/>
    
      <category term="window" scheme="http://yoursite.com/tags/window/"/>
    
      <category term="cmd" scheme="http://yoursite.com/tags/cmd/"/>
    
  </entry>
  
  <entry>
    <title>nuxt服务端项目集成引入iView</title>
    <link href="http://yoursite.com/2019/07/13/nuxt/init/"/>
    <id>http://yoursite.com/2019/07/13/nuxt/init/</id>
    <published>2019-07-13T09:50:46.000Z</published>
    <updated>2019-07-13T15:12:19.276Z</updated>
    
    <content type="html"><![CDATA[<p>Nuxt.js 是一个基于 Vue.js 的通用应用框架。</p><p>通过对客户端/服务端基础架构的抽象组织，Nuxt.js 主要关注的是应用的 UI渲染。</p><p>我们的目标是创建一个灵活的应用框架，你可以基于它初始化新项目的基础结构代码，或者在已有 Node.js 项目中使用 Nuxt.js。</p><p>Nuxt.js 预设了利用Vue.js开发服务端渲染的应用所需要的各种配置。</p><p>除此之外，我们还提供了一种命令叫：nuxt generate，为基于 Vue.js 的应用提供生成对应的静态站点的功能。</p><p>我们相信这个命令所提供的功能，是向开发集成各种微服务（microservices）的 Web 应用迈开的新一步。</p><p>作为框架，Nuxt.js 为 客户端/服务端 这种典型的应用架构模式提供了许多有用的特性，例如异步数据加载、中间件支持、布局支持等。</p><h2 id="Nuxt-项目–构建"><a href="#Nuxt-项目–构建" class="headerlink" title="Nuxt 项目–构建"></a>Nuxt 项目–构建</h2><p>因为Nuxt是基于vue的通用应用框架所以构建Nuxt项目可以同vue-cil来构建</p><h3 id="1-安装vue-cil"><a href="#1-安装vue-cil" class="headerlink" title="1. 安装vue-cil"></a>1. 安装vue-cil</h3><p>相信有vue使用经验的开发者对这款cil工具是非常熟悉的</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --global vue-cli</span><br></pre></td></tr></table></figure><h3 id="2-用vue-cil搭建项目"><a href="#2-用vue-cil搭建项目" class="headerlink" title="2. 用vue-cil搭建项目"></a>2. 用vue-cil搭建项目</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ vue init nuxt-community/starter-template nuxt </span><br><span class="line">//(你要构建的项目名称我的项目叫做nuxt)</span><br><span class="line">$ cd nuxt</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><h3 id="3-接着通过以下命令启动项目"><a href="#3-接着通过以下命令启动项目" class="headerlink" title="3. 接着通过以下命令启动项目"></a>3. 接着通过以下命令启动项目</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run dev</span><br></pre></td></tr></table></figure><p>访问 <a href="http://localhost:3000" target="_blank" rel="noopener">http://localhost:3000</a><br><img src="/2019/07/13/nuxt/init/init.png" title="启动页"></p><h3 id="集成-iview-UI框架"><a href="#集成-iview-UI框架" class="headerlink" title="集成 iview UI框架"></a>集成 iview UI框架</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 安装 iview</span><br><span class="line">$ npm install iview --save</span><br></pre></td></tr></table></figure><h3 id="在根目录的-plugins-中新建-iview-js"><a href="#在根目录的-plugins-中新建-iview-js" class="headerlink" title="在根目录的 plugins 中新建 iview.js"></a>在根目录的 plugins 中新建 iview.js</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import iView from &apos;iview&apos;</span><br><span class="line">Vue.use(iView)</span><br></pre></td></tr></table></figure><p>这里有个大坑因为Nuxt语法检测机制在Vue.use(iView)的后面要加一个回车要不会报一下错误，这个问题当时让我很郁闷</p><img src="/2019/07/13/nuxt/init/error.png" title="启动页"><h3 id="修改-nuxt-config-js"><a href="#修改-nuxt-config-js" class="headerlink" title="修改 nuxt.config.js"></a>修改 nuxt.config.js</h3><p>在module.exports最后添加如下内容：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plugins: [ &#123; src: &apos;~plugins/iview&apos;, ssr: false &#125; ],</span><br><span class="line">css: [&apos;iview/dist/styles/iview.css&apos;],</span><br></pre></td></tr></table></figure></p><img src="/2019/07/13/nuxt/init/add.png" title="添加"><h3 id="在pages-index-vue-加入-Button-标签"><a href="#在pages-index-vue-加入-Button-标签" class="headerlink" title="在pages/index.vue,加入 Button 标签"></a>在pages/index.vue,加入 Button 标签</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button type=&quot;primary&quot;&gt;Primary&lt;/Button&gt;</span><br></pre></td></tr></table></figure><img src="/2019/07/13/nuxt/init/add.png" title="按钮"><h3 id="再次启动页面"><a href="#再次启动页面" class="headerlink" title="再次启动页面"></a>再次启动页面</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run dev</span><br></pre></td></tr></table></figure><p>效果页面如下：</p><img src="/2019/07/13/nuxt/init/end.png" title="最后的效果"><h3 id="大功告成-后续会添加nuxt的相关内容"><a href="#大功告成-后续会添加nuxt的相关内容" class="headerlink" title="大功告成 后续会添加nuxt的相关内容"></a>大功告成 后续会添加nuxt的相关内容</h3>]]></content>
    
    <summary type="html">
    
      nuxt项目构架
    
    </summary>
    
      <category term="nuxt" scheme="http://yoursite.com/categories/nuxt/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
      <category term="nuxt" scheme="http://yoursite.com/tags/nuxt/"/>
    
      <category term="服务端项目集成" scheme="http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%A1%B9%E7%9B%AE%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>chrome扩展开发</title>
    <link href="http://yoursite.com/2019/07/13/other/chrome/"/>
    <id>http://yoursite.com/2019/07/13/other/chrome/</id>
    <published>2019-07-13T09:50:46.000Z</published>
    <updated>2019-07-13T15:12:51.511Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在平时的前端开发中chrome的扩展应用是非常常见的我平常应用的chrome扩展程序用Postman、React Developer Tools、Redux DevTools 等使用了这么长时间了扩展就想开发一款属于自己的chrome扩展，下面来介绍一下一个简单的扩展开发。</p></blockquote><h2 id="chrome扩展与chrome应用的区别"><a href="#chrome扩展与chrome应用的区别" class="headerlink" title="chrome扩展与chrome应用的区别"></a>chrome扩展与chrome应用的区别</h2><p>Chrome应用更强调是独立的程序，你可以不打开Chrome浏览器而运行这些程序。同时这些程序可以调用更加底层的系统接口，比如串口、USB、本地文件读写等等。同时Chrome应用可以拥有样式更加自由的独立窗口，而Chrome扩展的界面只能限定在浏览器窗口中。</p><p>Chrome扩展是一系列文件的集合，这些文件包括HTML文件、CSS样式文件、JavaScript脚本文件、图片等静态文件以及manifest.json。个别扩展还会包含二进制文件，如DLL动态库和so动态库等，但这需要调用NPAPI，而Google出于安全性考虑已经决定逐渐淘汰NPAPI</p><h2 id="一个简单的chrome扩展"><a href="#一个简单的chrome扩展" class="headerlink" title="一个简单的chrome扩展"></a>一个简单的chrome扩展</h2><p>新建文件夹 my_chrome 为项目目录<br>开发目录<br>——   images<br>——   js<br>——   css<br>——   index.html<br>——   manifest.json</p><p>项目目录搭建完毕</p><h2 id="manifest-json-文件"><a href="#manifest-json-文件" class="headerlink" title="manifest.json 文件"></a>manifest.json 文件</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;manifest_version&quot;: 2,</span><br><span class="line">    &quot;name&quot;: &quot;my_chrome&quot;,//扩展名称</span><br><span class="line">    &quot;version&quot;: &quot;1.0&quot;,//版本号</span><br><span class="line">    &quot;description&quot;: &quot;我的第一个Chrome扩展&quot;,//项目描述</span><br><span class="line">    &quot;icons&quot;: &#123;  //icons定义了扩展相关图标文件的位置</span><br><span class="line">        &quot;16&quot;: &quot;images/icon.png&quot;,</span><br><span class="line">        &quot;48&quot;: &quot;images/icon.png&quot;,</span><br><span class="line">        &quot;128&quot;: &quot;images/icon.png&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;browser_action&quot;: &#123;</span><br><span class="line">        &quot;default_icon&quot;: &#123; //定义了相应图标文件的位置</span><br><span class="line">            &quot;19&quot;: &quot;images/icon.png&quot;,</span><br><span class="line">            &quot;38&quot;: &quot;images/icon.png&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;default_title&quot;: &quot;我的时钟&quot;,//当用户鼠标悬停于扩展图标上所显示的文字</span><br><span class="line">        &quot;default_popup&quot;: &quot;index.html&quot; //当用户单击扩展图标时所显示页面的文件位置。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="html的代码"><a href="#html的代码" class="headerlink" title="html的代码"></a>html的代码</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            * &#123;</span><br><span class="line">                margin: 0;</span><br><span class="line">                padding: 0;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            body &#123;</span><br><span class="line">                width: 200px;</span><br><span class="line">                height: 100px;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            div &#123;</span><br><span class="line">                line-height: 100px;</span><br><span class="line">                font-size: 42px;</span><br><span class="line">                text-align: center;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div id=&quot;clock_div&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;script src=&quot;js/my_clock.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="js-代码"><a href="#js-代码" class="headerlink" title="js 代码"></a>js 代码</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function my_clock(el)&#123;</span><br><span class="line">    var today=new Date();</span><br><span class="line">    var h=today.getHours();</span><br><span class="line">    var m=today.getMinutes();</span><br><span class="line">    var s=today.getSeconds();</span><br><span class="line">    m=m&gt;=10?m:(&apos;0&apos;+m);</span><br><span class="line">    s=s&gt;=10?s:(&apos;0&apos;+s);</span><br><span class="line">    el.innerHTML = h+&quot;:&quot;+m+&quot;:&quot;+s;</span><br><span class="line">    setTimeout(function()&#123;my_clock(el)&#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var clock_div = document.getElementById(&apos;clock_div&apos;);</span><br><span class="line">my_clock(clock_div);</span><br></pre></td></tr></table></figure><h2 id="扩展导入"><a href="#扩展导入" class="headerlink" title="扩展导入"></a>扩展导入</h2><img src="/2019/07/13/other/chrome/play.png" title="扩展导入"><h2 id="到这了一个简单的chrome扩展就完成了"><a href="#到这了一个简单的chrome扩展就完成了" class="headerlink" title="到这了一个简单的chrome扩展就完成了"></a>到这了一个简单的chrome扩展就完成了</h2>]]></content>
    
    <summary type="html">
    
      chrome扩展应用开发初试
    
    </summary>
    
      <category term="chrome" scheme="http://yoursite.com/categories/chrome/"/>
    
    
      <category term="chrome" scheme="http://yoursite.com/tags/chrome/"/>
    
  </entry>
  
  <entry>
    <title>Vue项目搭建</title>
    <link href="http://yoursite.com/2019/07/13/vue/start/"/>
    <id>http://yoursite.com/2019/07/13/vue/start/</id>
    <published>2019-07-13T09:50:46.000Z</published>
    <updated>2019-07-13T09:50:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Vue项目搭建"><a href="#Vue项目搭建" class="headerlink" title="Vue项目搭建"></a>Vue项目搭建</h3><p>Vue项目搭建非常简单这里就只说一下命令操作<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 全局安装 vue-cli</span><br><span class="line">$ npm install --global vue-cli</span><br><span class="line"># 创建一个基于 webpack 模板的新项目</span><br><span class="line">$ vue init webpack my-project</span><br><span class="line"># 安装依赖，走你</span><br><span class="line">$ cd my-project</span><br><span class="line">$ npm install</span><br><span class="line">$ npm run dev</span><br></pre></td></tr></table></figure></p><p><a href="https://cn.vuejs.org/v2/guide/installation.html" target="_blank" rel="noopener">Vue项目搭建原文地址</a></p>]]></content>
    
    <summary type="html">
    
      Vue项目搭建
    
    </summary>
    
      <category term="vue" scheme="http://yoursite.com/categories/vue/"/>
    
    
      <category term="项目搭建" scheme="http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"/>
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>mac终端配置sublime和vsCode的快捷方式</title>
    <link href="http://yoursite.com/2019/07/13/IDE/mac-path/"/>
    <id>http://yoursite.com/2019/07/13/IDE/mac-path/</id>
    <published>2019-07-13T09:50:46.000Z</published>
    <updated>2019-07-13T15:33:51.019Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vsCode的终端命令配置"><a href="#vsCode的终端命令配置" class="headerlink" title="vsCode的终端命令配置"></a>vsCode的终端命令配置</h2><h3 id="mac端配置"><a href="#mac端配置" class="headerlink" title="mac端配置"></a>mac端配置</h3><blockquote><p>vsCode的终端命令配置较为简单，运行VS code并打开命令面板（ ⇧⌘P ），然后输入 shell command 找到: Install ‘code’ command in PATH 就行了。<br>code命令还支持其他参数，具体看 <a href="http://www.jianshu.com/p/3dda4756eca5" target="_blank" rel="noopener">Visual Studio Code入门</a></p></blockquote><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//配好后的使用方法(打开当前路径)</span><br><span class="line">code .</span><br></pre></td></tr></table></figure><h2 id="sublime的终端配置"><a href="#sublime的终端配置" class="headerlink" title="sublime的终端配置"></a>sublime的终端配置</h2><h3 id="mac端配置-1"><a href="#mac端配置-1" class="headerlink" title="mac端配置"></a>mac端配置</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 1. 打开终端</span><br><span class="line">cd ~</span><br><span class="line"></span><br><span class="line">ls -la</span><br><span class="line">//找打.zshrc文件如果安装过atom 就输入 atom .zshrc 如果有 vim 就输入 vim .zshrc这里我用vim</span><br><span class="line"></span><br><span class="line">vim .zshrc</span><br><span class="line"></span><br><span class="line">//到 atom 中</span><br></pre></td></tr></table></figure><p>//把下面内容粘贴到最后</p><p>alias subl=”‘/Applications/Sublime.app/Contents/SharedSupport/bin/subl’”<br>alias nano=”subl”<br>export EDITOR=”subl”</p><p>上面的第一行里是自己sublime的在、安装路径一般只有 Sublime.app 不一样</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//配好后的使用方法(打开当前路径)记得重启终端</span><br><span class="line">subl .</span><br></pre></td></tr></table></figure><p>因为 atom 在这两款中显得较为鸡肋就不做介绍</p>]]></content>
    
    <summary type="html">
    
      mac终端配置sublime和vsCode的快捷方式
    
    </summary>
    
      <category term="辅助工具" scheme="http://yoursite.com/categories/%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="mac" scheme="http://yoursite.com/tags/mac/"/>
    
      <category term="辅助工具" scheme="http://yoursite.com/tags/%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>vue-router</title>
    <link href="http://yoursite.com/2019/07/13/vue/router/"/>
    <id>http://yoursite.com/2019/07/13/vue/router/</id>
    <published>2019-07-13T09:50:46.000Z</published>
    <updated>2019-07-13T09:50:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h1><blockquote><p>Vue.js的一大特色就是构建单页面应用十分方便，既然要方便构建单页面应用那么自然少不了路由，vue-router就是vue官方提供的一个路由框架。总体来说，vue-router设计得简单好用，下面就来聊聊我实际用到过的一些方法，文章没有提到的可以去查看官方文档。vue-router的安装这里就不提了，相信会来看这篇博客同学，这些基本能力都是有的。</p></blockquote><p>先上例子<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- html部分，省略head --&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">        &lt;router-link to=&quot;/goods&quot;&gt;商品&lt;/router-link&gt;</span><br><span class="line">        &lt;router-link to=&quot;/ratings&quot;&gt;评论&lt;/router-link&gt;</span><br><span class="line">        &lt;router-link to=&quot;/seller&quot;&gt;商家&lt;/router-link&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script src=&quot;path-to-vue&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;path-to-vue-router&quot;&gt;&lt;/script&gt;</span><br><span class="line">// 首先定义或者引入路由的组件</span><br><span class="line">// 方法一：直接定义路由组件</span><br><span class="line">const goods = &#123; template: &apos;&lt;p&gt;goods&lt;/p&gt;&apos; &#125;;</span><br><span class="line">const ratings = &#123; template: &apos;&lt;p&gt;ratings&lt;/p&gt;&apos; &#125;;</span><br><span class="line">const seller = &#123; template: &apos;&lt;p&gt;seller&lt;/p&gt;&apos; &#125;;</span><br><span class="line">// 方法二：import引入路由组件</span><br><span class="line">import goods from &apos;components/goods/goods&apos;;</span><br><span class="line">import ratings from &apos;components/ratings/ratings&apos;;</span><br><span class="line">import seller from &apos;components/seller/seller&apos;;</span><br><span class="line">// 然后定义路由(routes)，components还可以是Vue.extend()创建的</span><br><span class="line">const routes = [</span><br><span class="line">  &#123; path: &apos;/goods&apos;, component: goods &#125;,</span><br><span class="line">  &#123; path: &apos;/ratings&apos;, component: ratings &#125;,</span><br><span class="line">  &#123; path: &apos;/seller&apos;, component: seller &#125;</span><br><span class="line">];</span><br><span class="line">// 接着创建路由实例</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  // ES6缩写语法，相当于routes:routes</span><br><span class="line">  routes  </span><br><span class="line">&#125;);</span><br><span class="line">// 最后创建vue实例并挂载</span><br><span class="line">const app = new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  router</span><br><span class="line">&#125;);</span><br><span class="line">// 或者</span><br><span class="line">const app = new Vue(&#123;</span><br><span class="line">  router</span><br><span class="line">&#125;).$mount(&apos;#app&apos;)</span><br></pre></td></tr></table></figure></p><p>到这里就可以用vue-router轻松搭建一个单页面应用了。我一般都是使用模块化编程的形式，用.vue单文件，不知道在模块化编程里怎么加载vue-router的可以参考我的某个项目源码。</p><p>router-link和router-view<br>看了上面的例子，一定对router-link和router-view很感兴趣。</p><h3 id="router-link"><a href="#router-link" class="headerlink" title="router-link"></a>router-link</h3><p>从上面例子中的书写形式就可以看出，router-link是一个组件，它默认会被渲染成一个带有链接的a标签，通过to属性指定链接地址。<br>注意：被选中的router-link将自动添加一个class属性值.router-link-active。</p><h5 id="router-link属性配置"><a href="#router-link属性配置" class="headerlink" title="router-link属性配置"></a>router-link属性配置</h5><h5 id="to"><a href="#to" class="headerlink" title="to"></a>to</h5><p>这是一个必须设置的属性，否则路由无法生效。它表示路由的链接，可以是一个字符串也可以是一个描述目标位置的对象。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link to=&quot;goods&quot;&gt;&lt;/router-link&gt;</span><br><span class="line">&lt;router-link to=&quot;&#123;path=&apos;goods&apos;&#125;&quot;&gt;&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></p><h5 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h5><p>一个布尔类型，默认为false。如果replace设置为true，那么导航不会留下history记录，点击浏览器回退按钮不会再回到这个路由。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link to=&quot;goods&quot; replace&gt;&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></p><h5 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h5><p>router-link默认渲染成a标签，也有方法让它渲染成其他标签，tag属性就用来设置router-link渲染成什么标签的。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 渲染成li标签 --&gt;</span><br><span class="line">&lt;router-link to=&quot;goods&quot; tag=&quot;li&quot;&gt;&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></p><h5 id="active-class"><a href="#active-class" class="headerlink" title="active-class"></a>active-class</h5><p>上面说了被选中的router-link将自动添加一个class属性值.router-link-active，这个属性就是来修改这个class值的。</p><h3 id="router-view"><a href="#router-view" class="headerlink" title="router-view"></a>router-view</h3><p>这个组件十分关键，它就是用来渲染匹配到的路由的。<br>可以给router-view组件设置transition过渡，具体用法见Vue2.0 Transition常见用法全解惑。<br>还可以配合<keep-alive>使用，keep-alive可以缓存数据，这样不至于重新渲染路由组件的时候，之前那个路由组件的数据被清除了。比如对当前的路由组件a进行了一些DOM操作之后，点击进入另一个路由组件b，再回到路由组件a的时候之前的DOM操作还保存在，如果不加keep-alive再回到路由组件a时，之前的DOM操作就没有了，得重新进行。如果你的应用里有一个购物车组件，就需要用到keep-alive。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition&gt;</span><br><span class="line">  &lt;keep-alive&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">  &lt;/keep-alive&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure></keep-alive></p><h3 id="一些小需求怎么实现"><a href="#一些小需求怎么实现" class="headerlink" title="一些小需求怎么实现"></a>一些小需求怎么实现</h3><p>不同路由不同页面标题<br>多页面应用我们可以给每一个页面都设置一个不同的标题，但是如果是单页面应用的路由呢？其实也是可以实现的，实现的方法不止一种，我之前用的是结合命名路由和导航钩子函数的方法。如下：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 定义路由的时候如下定义，name也可为中文</span><br><span class="line">const routes = [</span><br><span class="line">  &#123; path: &apos;/goods&apos;, component: goods, name: &apos;goods&apos; &#125;,</span><br><span class="line">  &#123; path: &apos;/ratings&apos;, component: ratings, name: &apos;ratings&apos; &#125;,</span><br><span class="line">  &#123; path: &apos;/seller&apos;, component: seller, name: &apos;seller&apos; &#125;</span><br><span class="line">];</span><br><span class="line">// 创建路由实例</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: routes</span><br><span class="line">&#125;)</span><br><span class="line">// 关键在这里，设置afterEach钩子函数</span><br><span class="line">router.afterEach((to, from, next) =&gt; &#123;</span><br><span class="line">  document.title = to.name;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h3><p>既然用到了命名路由，这里就提一下吧。命名路由就是用一个名称来标识一个路由，在定义路由的时候设置一个name属性即可。在router-link中也可以用路由的名字来链接到一个路由。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to=&quot;&#123; name: &apos;seller&apos;&#125;&quot;&gt;seller&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></p><p>导航钩子<br>这个我还没怎么用过，它主要是用来拦截导航的，想使用的参考官方文档吧。</p><p>怎么刚进入应用就渲染某个路由组件<br>刚进入应用都是进入到“/”这个路由的，如果想直接进入到“/goods”怎么办，这里提供两种方法。一种是利用重定向，另一种是利用vue-router的导航式编程。</p><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const routes = [</span><br><span class="line">  &#123; path: &apos;/&apos;, redirect: &apos;/goods&apos;&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>是不是很简单呢？重定向的目标也可以是一个命名的路由。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const routes = [</span><br><span class="line">  &#123; path: &apos;/&apos;, redirect: &#123; name: &apos;goods&apos; &#125;&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="导航式编程"><a href="#导航式编程" class="headerlink" title="导航式编程"></a>导航式编程</h3><p>利用vue-router的导航式编程的router.push方法也可以实现上面的需求。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 在创建vue实例并挂载后调用</span><br><span class="line">router.push(&apos;/goods&apos;)</span><br></pre></td></tr></table></figure></p><p>router.push方法就是用来动态导航到不同的链接的。它会向history栈添加一个新的记录，点击<router-link :to="...">等同于调用router.push(…)。</router-link></p><p>vue-router中还有router.replace方法和router.go方法，概念及用法可参考<a href="https://router.vuejs.org/zh-cn/" target="_blank" rel="noopener">https://router.vuejs.org/zh-cn</a>。</p>]]></content>
    
    <summary type="html">
    
      Vue.js的一大特色就是构建单页面应用十分方便，既然要方便构建单页面应用那么自然少不了路由，vue-router就是vue官方提供的一个路由框架。总体来说，vue-router设计得简单好用，下面就来聊聊我实际用到过的一些方法，文章没有提到的可以去查看官方文档。vue-router的安装这里就不提了，相信会来看这篇博客同学，这些基本能力都是有的。
    
    </summary>
    
      <category term="vue" scheme="http://yoursite.com/categories/vue/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
      <category term="router" scheme="http://yoursite.com/tags/router/"/>
    
  </entry>
  
  <entry>
    <title>github上的协议知识普及</title>
    <link href="http://yoursite.com/2019/07/13/IDE/agreement/"/>
    <id>http://yoursite.com/2019/07/13/IDE/agreement/</id>
    <published>2019-07-13T09:50:46.000Z</published>
    <updated>2019-07-13T09:50:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="github上的协议知识普及"><a href="#github上的协议知识普及" class="headerlink" title="github上的协议知识普及"></a>github上的协议知识普及</h1><h3 id="选择一分协议的好处"><a href="#选择一分协议的好处" class="headerlink" title="选择一分协议的好处"></a>选择一分协议的好处</h3><blockquote><p>你的作品如果不是定性为全商业性质，可以考虑选择一分流行度比较高的开源协议。具体来说的话，你肯定希望作品能够被多数人分享查阅吧，不但提高自己业界的知名度，同时也方便了需要的人为开源做出了贡献。换句话说，你不分享出来的话你的作品的意义何在呢（当然，自己捣腾的私人东西还是自己保留吧）？可是一旦你把你的代码贴出来，这就表示任何人都可以看到并获取，之后发生的事情你无法控制，有的人或许稍微修改一下放进自己的代码中，有的把你的软件改个名字拿去贩卖，有的甚至会拿去把作者名字改为自己然后拿去找工作什么的，而不会有人知道这个作品的原作者，背后辛勤付出了的人。所以为了公开分享你的代码，同时又让你对代码保留一定权利，在作品中声明一个许可协议是非常有必要的，这是很多新人所忽略的问题，同时很多人在使用别人的劳动成果时也会忽视协议的存在，这样不好。所以你会看到我的博客里面时不时会给出连接指向来源页面，同时文末也会列出所有参考过的文章。我相信我做到了这点，别人在转载我的文章的时候，也可以做到这点，这样营造出来的氛围一定会非常和谐，互相尊重/Show Respect。</p></blockquote><p>多说一句，一个事实让你了解国外开发者在尊重他人劳动成果方面做得是如何的到位，如果A的作品是因为B的作品的启发而来，A甚至都没有使用B任何一句代码，但A会在他的作品里面指明是受到了B的启发”Inspired by XXX link :<a href="http://www.blah.com&quot;。" target="_blank" rel="noopener">http://www.blah.com&quot;。</a></p><p>当然有人会觉得，有了一分协议声明在那里，我就需要鸟你么，我拿来用了把作者名字去掉同时还要加上我的名字，你咬我？！这是后话，只是在利益很小的情况下，或者作者不知情的情况下，作者不会追究什么责任，但如果你的产品做成功了，那就不一定了。另外就是，有协议和没声明协议的裸代码是有非常重要区别的，一般作品当中没声明协议的默认为Copy right的，也就是版权保留。此种情况表明他人没有任何授权，不得复制分发修改使用等等，但一如上面所讨论的，这样的话还何来开源，何来分享呢。有了协议的声明，在未来你的维权上面会方便很多，让你的作品在分享的同时保留了自身的一些权利。</p><h3 id="快速选择"><a href="#快速选择" class="headerlink" title="快速选择"></a>快速选择</h3><blockquote><p>目前流行的开源协议有很多，并且同一款协议有很多变种，比如你或许看到过’ CC Attribution-NoDerivs’,’ CC Attribution-NonCommercial’同属CC协议（后面会有介绍）。如此纷繁的协议该如何选择？协议太宽松会导致作者丧失对作品的很多权利，太严格又不便于使用者使用及作品的传播。所以除了协议多之外，你还要考虑你对作品想保留哪些权利，放开哪些限制。</p></blockquote><p>如果你不想了解太多，只是想要一个简直直接的答案，下面给出的建议或许适合你。下方关于协议的选择及表格来自GitHub choosealicence项目。</p><h4 id="简单宽松的协议"><a href="#简单宽松的协议" class="headerlink" title="简单宽松的协议"></a>简单宽松的协议</h4><blockquote><p>如果你只想要一个简单点的协议不想太麻烦的话。</p></blockquote><p>MIT协议相对宽松但还是抓住了要点的。此协议允许别人以任何方式使用你的代码同时署名原作者，但原作者不承担代码使用后的风险，当然也没有技术支持的义务。jQuery和Rails就是MIT协议。</p><h4 id="代码分享与促进"><a href="#代码分享与促进" class="headerlink" title="代码分享与促进"></a>代码分享与促进</h4><p>如果你在乎作品的传播和别人的修改，希望别人也以相同的协议分享出来。</p><p>GPL（V2或V3）是一种版本自由的协议（可以参照copy right来理解，后者是版本保留，那copyleft便是版权自由，或者无版权，但无版权不代表你可以不遵守软件中声明的协议）。此协议要求代码分发者或者以此代码为基础开发出来的衍生作品需要以同样的协议来发布。此协议的版本3与版本2相近，只是多3中加了条对于不支持修改后代码运行的硬件的限制（没太明白此句话的内涵）。</p><h3 id="各协议授权详情"><a href="#各协议授权详情" class="headerlink" title="各协议授权详情"></a>各协议授权详情</h3><blockquote><p>下面是更多开源协议的一个表格任君选择，总有一款是你的菜。<br>不过先来了解一些下方表格中出现的用词的解释：<br>协议和版权信息(License and copyright notice)：在代码中保留作者提供的协议和版权信息<br>声明变更(State Changes)：在代码中声明对原来代码的重大修改及变更<br>公开源码(Disclose Source)：代码必需公开。如果是基于LGPL协议 下，则只需使用的开源代码公开，不必将整个软件源码公开<br>库引用(Library usage)：该库可以用于商业软件中<br>责任承担(Hold Liable)：代码的作者承担代码使用后的风险及产生的后果<br>商标使用(Use Trademark)：可以使用作者的姓名，作品的Logo，或商标<br>附加协议(Sublicensing)：允许在软件分发传播过程中附加上原来没有的协议条款等</p></blockquote><table><thead><tr><th style="text-align:left">协议</th><th style="text-align:left">描述</th><th style="text-align:left">要求</th><th style="text-align:left">允许</th><th style="text-align:left">禁止</th></tr></thead><tbody><tr><td style="text-align:left">Apache</td><td style="text-align:left">一个较宽松且简明地指出了专利授权的协议。</td><td style="text-align:left">○协议和版权信息<br> ○声明变更</td><td style="text-align:left">○商用<br>○分发<br>○修改<br>○专利授权<br>○私用<br>○附加协议</td><td style="text-align:left">○责任承担（禁止让作者承担责任，可以理解为免责<br>○商标使用</td></tr><tr><td style="text-align:left">GPL</td><td style="text-align:left">此协议是应用最为广泛的开源协议，拥有较强的版权自由( copyleft )要求。衍生代码的分发需开源并且也要遵守此协议。此协议有许多变种，不同变种的要求略有不同</td><td style="text-align:left">○公开源码<br>○协议和版权信息<br>○声明变更</td><td style="text-align:left">○商用<br>○分发<br>○修改<br>○专利授权<br>○私用</td><td style="text-align:left">○责任承担<br>○附加协议</td></tr><tr><td style="text-align:left">MIT</td><td style="text-align:left">宽松简单且精要的一个协议。在适当标明来源及免责的情况下，它允许你对代码进行任何形式的使用</td><td style="text-align:left">○协议和版权信息</td><td style="text-align:left">○商用<br>○分发<br>○修改<br>○私用<br>○附加协议</td><td style="text-align:left">○责任承担</td></tr><tr><td style="text-align:left">Artistic</td><td style="text-align:left">Perl社区尤为钟爱此协议。要求更改后的软件不能影响原软件的使用。</td><td style="text-align:left">○协议和版权信息<br>○声明变更</td><td style="text-align:left">○商用<br>○分发<br>○修改<br>○私用<br>○附加协议</td><td style="text-align:left">○责任承担<br>○商标使用</td></tr><tr><td style="text-align:left">BSD</td><td style="text-align:left">较为宽松的协议，包含两个变种BSD 2-Clause 和BSD3-Clause，两者都与MIT协议只存在细微差异。</td><td style="text-align:left">○协议和版权信息</td><td style="text-align:left">○商用<br>○分发<br>○修改<br>○私用<br>○附加协议</td><td style="text-align:left">○责任承担</td></tr><tr><td style="text-align:left">Eclipse</td><td style="text-align:left">对商用非常友好的一种协议，可以用于软件的商业授权。包含对专利的优雅授权，并且也可以对相关代码应用商业协议。</td><td style="text-align:left">○公开源码<br>○协议和版权信息</td><td style="text-align:left">○商用<br>○分发<br>○修改<br>○专利授权<br>○私用<br>○附加协议</td><td style="text-align:left">○责任承担</td></tr><tr><td style="text-align:left">LGPL</td><td style="text-align:left">主要用于一些代码库。衍生代码可以以此协议发布（言下之意你可以用其他协议），但与此协议相关的代码必需遵循此协议</td><td style="text-align:left">○公开源码<br>○库引用<br>○协议和版权信息</td><td style="text-align:left">○商用<br>○分发<br>○修改<br>○专利授权<br>○私用<br>○附加协议</td><td style="text-align:left">○责任承担</td></tr><tr><td style="text-align:left">Mozilla</td><td style="text-align:left">Mozilla Public License(MPL 2.0)是由Mozilla基金创建维护的。此协议旨在较为宽松的BSD协议和更加互惠的GPL协议中寻找一个折衷点。</td><td style="text-align:left">○公开源码<br>○协议和版权信息</td><td style="text-align:left">○商用<br>○分发<br>○修改<br>○专利授权<br>○私用<br>○附加协议</td><td style="text-align:left">○责任承担<br>○商标使用</td></tr><tr><td style="text-align:left">No license</td><td style="text-align:left">你保留所有权利，不允许他人分发，复制或者创造衍生物。当你将代码发表在一些网站上时需要遵守该网站的协议，此协议可能包含了一些对你劳动成果的授权许可。比如你将代码发布到GitHub，那么你就必需同意别人可以查看和Fork你的代码。</td><td style="text-align:left">○协议和版权信息</td><td style="text-align:left">○商用<br>○私用</td><td style="text-align:left">○分发<br>○修改<br>○附加协议</td></tr><tr><td style="text-align:left">Public domain dedication</td><td style="text-align:left">在许多国家，默认版权归作者自动拥有，所以Unlicense协议提供了一种通用的模板，此协议表明你放弃版权，将劳动成果无私贡献出来。你将丧失对作品的全部权利，包括在MIT/X11中定义的无担保权利。</td><td style="text-align:left">N/A</td><td style="text-align:left">○商用<br>○分发<br>○修改<br>○私用</td><td style="text-align:left">○责任承担</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      github上的协议知识普及
    
    </summary>
    
      <category term="辅助知识" scheme="http://yoursite.com/categories/%E8%BE%85%E5%8A%A9%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="github" scheme="http://yoursite.com/tags/github/"/>
    
      <category term="辅助知识" scheme="http://yoursite.com/tags/%E8%BE%85%E5%8A%A9%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>MobX入坑</title>
    <link href="http://yoursite.com/2019/07/13/React/mobx/"/>
    <id>http://yoursite.com/2019/07/13/React/mobx/</id>
    <published>2019-07-13T09:50:46.000Z</published>
    <updated>2019-07-13T09:50:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MobX入坑"><a href="#MobX入坑" class="headerlink" title="MobX入坑"></a>MobX入坑</h1><p>MobX 是一个简单、方便扩展、久经考验的状态管理解决方案。这个教程旨在十分钟内向你介绍 MobX 的一些重要概念。MobX 是一个独立的苦，不过大多数人都把它和 React 一起使用，所以本教程也就着眼于这个组合展开。</p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p>State 是每一个应用程序的核心部分，而使用一个不合规范的 State 则是让你的应用充满 bug 和失控的不二法门，或者就是局部变量环绕，让你的 state 失去了同步。有很多框架试图解决这个问题，比如使用不可变的 state，但是这样以来又带来了新的问题，比如数据必须规格化，完整性约束失效等等。</p><p>MobX 让整个事情又变简单了：它不允许产生失控的 state。它的理念也很简单：所有可以从 state 中派生的事物，都会自动的派生。</p><p>把 MobX 想象成 Excel 表格。</p><p>首先，有一个 state，它可以是一个object，array，primitives等等任何组成你程序的部分。你可以把这个想象成你应用程序的“单元格”。<br>然后就是 derivations，一般它是指可以从 state 中直接计算的来的结果。比如未完成的任务的数量，这个比较简单，也可以稍复杂一些比如渲染你的任务显示的html。它类似于你的应用程序中的“公式和图表”。<br>Reactions 和 derivations 很像，主要的区别在于 reactions 并不产生数据结果，而是自动完成一些任务，一般是和 I/O 相关的。他们保证了 DOM 和 网络请求会自动适时地出发。<br>最后是 actions。Actions 指的是所有会改变 state 的事情，MobX 保证所有 actions 都会有对应的 derivations 和 reactions 相伴，保证同步。<br>一个简单的 todo 的 state</p><p>理论说的够多的了，看一个例子也许会更明白一些。我们从一个简单的 todo 程序开始。</p><p>下面是一个简单直接的 TodoStore，没有鱼丸，没有粗面，没有 MobX ……</p><p>JavaScript<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class TodoStore &#123;</span><br><span class="line">todos = [];</span><br><span class="line"></span><br><span class="line">get completedTodosCount() &#123;</span><br><span class="line">    return this.todos.filter(</span><br><span class="line">todo =&gt; todo.completed === true</span><br><span class="line">).length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">report() &#123;</span><br><span class="line">if (this.todos.length === 0)</span><br><span class="line">return &quot;&lt;none&gt;&quot;;</span><br><span class="line">return `Next todo: &quot;$&#123;this.todos[0].task&#125;&quot;. ` +</span><br><span class="line">`Progress: $&#123;this.completedTodosCount&#125;/$&#123;this.todos.length&#125;`;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    addTodo(task) &#123;</span><br><span class="line">this.todos.push(&#123;</span><br><span class="line">task: task,</span><br><span class="line">completed: false,</span><br><span class="line">            assignee: null</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const todoStore = new TodoStore();</span><br></pre></td></tr></table></figure></p><p>我们创建了一个 todoStore，它拥有一个 todos 集合。现在我们往这个 todoStore 里添加一些东西，为了明显起见，我们每修改一个地方，就调用todoStore.report。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">todoStore.addTodo(&quot;read MobX tutorial&quot;);</span><br><span class="line">console.log(todoStore.report());</span><br><span class="line">​</span><br><span class="line">todoStore.addTodo(&quot;try MobX&quot;);</span><br><span class="line">console.log(todoStore.report());</span><br><span class="line">​</span><br><span class="line">todoStore.todos[0].completed = true;</span><br><span class="line">console.log(todoStore.report());</span><br><span class="line">​</span><br><span class="line">todoStore.todos[1].task = &quot;try MobX in own project&quot;;</span><br><span class="line">console.log(todoStore.report());</span><br><span class="line">​</span><br><span class="line">todoStore.todos[0].task = &quot;grok MobX tutorial&quot;;</span><br><span class="line">console.log(todoStore.report());</span><br></pre></td></tr></table></figure><p>到现在为止，没有什么特别的。不过如果我们可以不再手动调用 report 方法，事情会不会更美好一些？我们只需要在想要的地方修改这个 state，所有的汇报都自动来做。</p><p>太巧了，这就是 MobX 能为你做的事情。自动执行只在 state 改变的时候触发，就好像 Excel 中的图表只在单元格数据改变时更新一样。为了达到这个目标，TodoStore 必须成为可观测的（observable）才行，让我们来改一些代码。</p><p>同时，completedTodosCount 属性应该被自动派生，使用 @observable 和 @computed 装饰器来做这些事情：</p><p>JavaScript<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">class ObservableTodoStore &#123;</span><br><span class="line">    @observable todos = [];</span><br><span class="line">    @observable pendingRequests = 0;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        mobx.autorun(() =&gt; console.log(this.report));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @computed get completedTodosCount() &#123;</span><br><span class="line">    return this.todos.filter(</span><br><span class="line">todo =&gt; todo.completed === true</span><br><span class="line">).length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @computed get report() &#123;</span><br><span class="line">        if (this.todos.length === 0)</span><br><span class="line">            return &quot;&lt;none&gt;&quot;;</span><br><span class="line">return `Next todo: &quot;$&#123;this.todos[0].task&#125;&quot;. ` +</span><br><span class="line">    `Progress: $&#123;this.completedTodosCount&#125;/$&#123;this.todos.length&#125;`;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    addTodo(task) &#123;</span><br><span class="line">this.todos.push(&#123;</span><br><span class="line">    task: task,</span><br><span class="line">    completed: false,</span><br><span class="line">    assignee: null</span><br><span class="line">&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const observableTodoStore = new ObservableTodoStore();</span><br><span class="line"></span><br><span class="line">class ObservableTodoStore &#123;</span><br><span class="line">    @observable todos = [];</span><br><span class="line">    @observable pendingRequests = 0;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        mobx.autorun(() =&gt; console.log(this.report));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @computed get completedTodosCount() &#123;</span><br><span class="line">    return this.todos.filter(</span><br><span class="line">todo =&gt; todo.completed === true</span><br><span class="line">).length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @computed get report() &#123;</span><br><span class="line">        if (this.todos.length === 0)</span><br><span class="line">            return &quot;&lt;none&gt;&quot;;</span><br><span class="line">return `Next todo: &quot;$&#123;this.todos[0].task&#125;&quot;. ` +</span><br><span class="line">    `Progress: $&#123;this.completedTodosCount&#125;/$&#123;this.todos.length&#125;`;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    addTodo(task) &#123;</span><br><span class="line">this.todos.push(&#123;</span><br><span class="line">    task: task,</span><br><span class="line">    completed: false,</span><br><span class="line">    assignee: null</span><br><span class="line">&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const observableTodoStore = new ObservableTodoStore();</span><br></pre></td></tr></table></figure></p><p>运行它，太棒了，我们每次赋值都能获得输出结果了。</p><p>有个 pendingRequests 暂时没用到，我们后面会用。另外这个教程都用了 ES6 的写法，不过 MobX 也支持 ES5 的写法。</p><p>在这个构造器中，我们使用autorun包裹了一个打出report的小函数。Autorun里的东西首先会运行一次，然后当其中的函数有observable的数据发生变化时，会再次运行。 这里我们使用了todos属性，每次todos变化了我们就打印出新的东西。</p><p>JavaScript<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">observableTodoStore.addTodo(&quot;read MobX tutorial&quot;);</span><br><span class="line">observableTodoStore.addTodo(&quot;try MobX&quot;);</span><br><span class="line">observableTodoStore.todos[0].completed = true;</span><br><span class="line">observableTodoStore.todos[1].task = &quot;try MobX in own project&quot;;</span><br><span class="line">observableTodoStore.todos[0].task = &quot;grok MobX tutorial&quot;;</span><br></pre></td></tr></table></figure></p><p>（可以自己试试结果）</p><p>非常有趣是吧，report确实自己执行了，而且同步又精准。如果你仔细查看运行结果的话，你挥发性我们的第四句语句没有产生输出，因为我们修改了todos[1]的数据，而我们在report中指明的数据，并没有todos[1]的变化而发生变化。而第五句话修改了todos[0]的数据则输出了。这个例子很好的说明了，autorun不是简单的监视了todos，而是精确到了具体的一项。</p><p>让React更美好</p><p>好了，到目前未知，我们使report自动化了，是实话把react拉出来遛遛了。为了是的react 的组件可以识别mobx，我们需要使用mobx-react包来完成，使用autorun，自动的让组件和state同步，这个简直就和上面的让report自动输出一样简单。</p><p>下面是一个react 组件，唯一MobX出场的地方就是一个@observer修饰符，这已经足够了，你再也不用使用setState了，你也不需要指明这个组件需要关注state的哪个部分，也不许手动写什么高阶组件。一般来说，所有的部件都变成人工智能了，即使他被定义成一个木偶（纯展示）组件。</p><p>JavaScript<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">@observer</span><br><span class="line">class TodoList extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const store = this.props.store;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123; store.report &#125;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">          &#123; store.todos.map(</span><br><span class="line">            (todo, idx) =&gt; &lt;TodoView todo=&#123; todo &#125; key=&#123; idx &#125; /&gt;</span><br><span class="line">          ) &#125;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">        &#123; store.pendingRequests &gt; 0 ? &lt;marquee&gt;Loading...&lt;/marquee&gt; : null &#125;</span><br><span class="line">        &lt;button onClick=&#123; this.onNewTodo &#125;&gt;New Todo&lt;/button&gt;</span><br><span class="line">        &lt;small&gt; (double-click a todo to edit)&lt;/small&gt;</span><br><span class="line">      &lt;RenderCounter /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">​</span><br><span class="line">  onNewTodo = () =&gt; &#123;</span><br><span class="line">    this.props.store.addTodo(prompt(&apos;Enter a new todo:&apos;,&apos;coffee plz&apos;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">@observer</span><br><span class="line">class TodoView extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const todo = this.props.todo;</span><br><span class="line">    return (</span><br><span class="line">      &lt;li onDoubleClick=&#123; this.onRename &#125;&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=&apos;checkbox&apos;</span><br><span class="line">          checked=&#123; todo.completed &#125;</span><br><span class="line">          onChange=&#123; this.onToggleCompleted &#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &#123; todo.task &#125;</span><br><span class="line">        &#123; todo.assignee</span><br><span class="line">          ? &lt;small&gt;&#123; todo.assignee.name &#125;&lt;/small&gt;</span><br><span class="line">          : null</span><br><span class="line">        &#125;</span><br><span class="line">      &lt;RenderCounter /&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">​</span><br><span class="line">  onToggleCompleted = () =&gt; &#123;</span><br><span class="line">    const todo = this.props.todo;</span><br><span class="line">    todo.completed = !todo.completed;</span><br><span class="line">  &#125;</span><br><span class="line">​</span><br><span class="line">  onRename = () =&gt; &#123;</span><br><span class="line">    const todo = this.props.todo;</span><br><span class="line">    todo.task = prompt(&apos;Task name&apos;, todo.task) || todo.task;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;TodoList store=&#123; observableTodoStore &#125; /&gt;,</span><br><span class="line">  document.getElementById(&apos;reactjs-app&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>执行下面的语句，我们会发现MobX帮我们把数据的更改反应到界面上去了。</p><p>JavaScript<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">store.todos[0].completed = !store.todos[0].completed;</span><br><span class="line">store.todos[1].task = &quot;Random todo &quot; + Math.random();</span><br><span class="line">store.todos.push(&#123; task: &quot;Find a fine cheese&quot;, completed: true &#125;);</span><br><span class="line">// etc etc.. add your own statements here...</span><br></pre></td></tr></table></figure></p><p>使用引用（References)</p><p>到现在位置，我们已经使用 observable 创建了个数据类型了。也许你会想，MobX 能不能应付引用呢？在之前的例子里，你可能主意到了又一个 assignee 的属性，我们就在这里放另外的一个 store，然后把它赋值给 tasks。</p><p>JavaScript<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var peopleStore = mobx.observable([</span><br><span class="line">  &#123; name: &quot;Michel&quot; &#125;,</span><br><span class="line">  &#123; name: &quot;Me&quot; &#125;</span><br><span class="line">]);</span><br><span class="line">observableTodoStore.todos[0].assignee = peopleStore[0];</span><br><span class="line">observableTodoStore.todos[1].assignee = peopleStore[1];</span><br><span class="line">peopleStore[0].name = &quot;Michel Weststrate&quot;;</span><br></pre></td></tr></table></figure></p><p>毫无疑问的，MobX 把着一切打理的井井有条。使用 MobX ，不需要规格话数据，不需要指明控件，事实上你的数据在哪里都无所谓。只要 observale 了，什么都好了。</p><p>总结</p><p>好了，仅仅依靠一些简单的修饰器，我们就让 react 程序如此生动有趣。最后总结一些：</p><p>@observale 修饰器或者 observable 函数让对象可以被追踪；<br>@computed 修饰器创造了自动运算的表达式；<br>autorun 函数让依靠 observable 的函数自动执行，这个用来写 log，发请求很不错；<br>@observer 修饰器让 React 组建自动起来，它会自动更新，即便是在一个很大的程序里也会工作的很好；</p><p>最后，MobX 不是一个状态容器</p><p>很多人把 MobX 当作另外一个 Redux，但是它仅仅是一个库，不是一个什么架构。上面的例子还是需要程序员自己去组织逻辑和store或者控制器什么的。</p>]]></content>
    
    <summary type="html">
    
      MobX 是一个简单、方便扩展、久经考验的状态管理解决方案。这个教程旨在十分钟内向你介绍 MobX 的一些重要概念。MobX 是一个独立的苦，不过大多数人都把它和 React 一起使用，所以本教程也就着眼于这个组合展开。
    
    </summary>
    
      <category term="react" scheme="http://yoursite.com/categories/react/"/>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
      <category term="mobx" scheme="http://yoursite.com/tags/mobx/"/>
    
      <category term="数据层" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>Redux使用入门</title>
    <link href="http://yoursite.com/2019/07/13/React/redux/"/>
    <id>http://yoursite.com/2019/07/13/React/redux/</id>
    <published>2019-07-13T09:50:46.000Z</published>
    <updated>2019-07-13T09:50:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redux使用入门"><a href="#Redux使用入门" class="headerlink" title="Redux使用入门"></a>Redux使用入门</h1><p><a href="http://cn.redux.js.org/" target="_blank" rel="noopener">参考网站</a></p><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>随着WEB应用变得越来越复杂，再加上node前后端分离越来越流行，那么对数据流动的控制就显得越发重要。redux是在flux的基础上产生的，基本思想是保证数据的单向流动，同时便于控制、使用、测试。</p><p>redux不依赖于任意框架(库)，只要subscribe相应框架(库)的内部方法，就可以使用该应用框架保证数据流动的一致性。</p><p>那么如何使用redux呢？下面一步步进行解析，并带有源码说明，不仅做到 知其然 ，还要做到 知其所以然 。</p><h3 id="2-主干逻辑介绍-createStore"><a href="#2-主干逻辑介绍-createStore" class="headerlink" title="2. 主干逻辑介绍(createStore)"></a>2. 主干逻辑介绍(createStore)</h3><h4 id="2-1-简单demo入门"><a href="#2-1-简单demo入门" class="headerlink" title="2.1 简单demo入门"></a>2.1 简单demo入门</h4><p>先来一个直观的认识：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 首先定义一个改变数据的plain函数，成为reducer</span><br><span class="line">function count (state, action) &#123;</span><br><span class="line">  var defaultState = &#123;</span><br><span class="line">    year: 2015,</span><br><span class="line">  &#125;;</span><br><span class="line">  state = state || defaultState;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case &apos;add&apos;:</span><br><span class="line">      return &#123;</span><br><span class="line">        year: state.year + 1</span><br><span class="line">      &#125;;</span><br><span class="line">    case &apos;sub&apos;:</span><br><span class="line">      return &#123;</span><br><span class="line">        year: state.year - 1</span><br><span class="line">      &#125;</span><br><span class="line">    default :</span><br><span class="line">      return state;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">// store的创建</span><br><span class="line">var createStore = require(&apos;redux&apos;).createStore;</span><br><span class="line">var store = createStore(count);</span><br><span class="line"></span><br><span class="line">// store里面的数据发生改变时，触发的回调函数</span><br><span class="line">store.subscribe(function () &#123;</span><br><span class="line">  console.log(&apos;the year is: &apos;, store.getState().year);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// action: 触发state改变的唯一方法(按照redux的设计思路)</span><br><span class="line">var action1 = &#123; type: &apos;add&apos; &#125;;</span><br><span class="line">var action2 = &#123; type: &apos;add&apos; &#125;;</span><br><span class="line">var action3 = &#123; type: &apos;sub&apos; &#125;;</span><br><span class="line"></span><br><span class="line">// 改变store里面的方法</span><br><span class="line">store.dispatch(action1); // &apos;the year is: 2016</span><br><span class="line">store.dispatch(action2); // &apos;the year is: 2017</span><br><span class="line">store.dispatch(action3); // &apos;the year is: 2016</span><br></pre></td></tr></table></figure></p><h4 id="2-2-挖掘createStore实现"><a href="#2-2-挖掘createStore实现" class="headerlink" title="2.2 挖掘createStore实现"></a>2.2 挖掘createStore实现</h4><p>为了说明主要问题，仅列出其中的关键代码，全部代码，可以点击 这里 阅读。</p><p>a首先看createStore到底都返回的内容:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export default function createStore(reducer, initialState) &#123;</span><br><span class="line">  ...</span><br><span class="line">  return &#123;</span><br><span class="line">    dispatch,</span><br><span class="line">    subscribe,</span><br><span class="line">    getState,</span><br><span class="line">    replaceReducer</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每个属性的含义是: - dispatch: 用于action的分发，改变store里面的state - subscribe: 注册listener，store里面state发生改变后，执行该listener - getState: 读取store里面的state - replaceReducer: 替换reducer，改变state修改的逻辑</p><p>b关键代码解析<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">export default function createStore(reducer, initialState) &#123;</span><br><span class="line">  // 这些都是闭包变量</span><br><span class="line">  var currentReducer = reducer</span><br><span class="line">  var currentState = initialState</span><br><span class="line">  var listeners = []</span><br><span class="line">  var isDispatching = false;</span><br><span class="line"></span><br><span class="line">  // 返回当前的state</span><br><span class="line">  function getState() &#123;</span><br><span class="line">    return currentState</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 注册listener，同时返回一个取消事件注册的方法</span><br><span class="line">  function subscribe(listener) &#123;</span><br><span class="line">    listeners.push(listener)</span><br><span class="line">    var isSubscribed = true</span><br><span class="line"></span><br><span class="line">    return function unsubscribe() &#123;</span><br><span class="line">    if (!isSubscribed) &#123;</span><br><span class="line">   return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isSubscribed = false</span><br><span class="line">    var index = listeners.indexOf(listener)</span><br><span class="line">      listeners.splice(index, 1)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 通过action该改变state，然后执行subscribe注册的方法</span><br><span class="line">  function dispatch(action) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      isDispatching = true</span><br><span class="line">      currentState = currentReducer(currentState, action)</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      isDispatching = false</span><br><span class="line">    &#125;</span><br><span class="line">    listeners.slice().forEach(listener =&gt; listener())</span><br><span class="line">    return action</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 替换reducer，修改state变化的逻辑</span><br><span class="line">  function replaceReducer(nextReducer) &#123;</span><br><span class="line">    currentReducer = nextReducer</span><br><span class="line">    dispatch(&#123; type: ActionTypes.INIT &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  // 初始化时，执行内部一个dispatch，得到初始state</span><br><span class="line">  dispatch(&#123; type: ActionTypes.INIT &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果还按照2.1的方式进行开发，那跟flux没有什么大的区别，需要手动解决很多问题，那redux如何将整个流程模板化(Boilerplate)呢?</p><h3 id="3-保证store的唯一性"><a href="#3-保证store的唯一性" class="headerlink" title="3. 保证store的唯一性"></a>3. 保证store的唯一性</h3><p>随着应用越来越大，一方面，不能把所有的数据都放到一个reducer里面，另一方面，为每个reducer创建一个store，后续store的维护就显得比较麻烦。如何将二者统一起来呢？</p><h4 id="3-1-demo入手"><a href="#3-1-demo入手" class="headerlink" title="3.1 demo入手"></a>3.1 demo入手</h4><p>通过combineReducers将多个reducer合并成一个rootReducer: // 创建两个reducer: count year function count (state, action) { state = state || {count: 1} switch (action.type) { default: return state; } } function year (state, action) { state = state || {year: 2015} switch (action.type) { default: return state; } }<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 将多个reducer合并成一个</span><br><span class="line">var combineReducers = require(&apos;./&apos;).combineReducers;</span><br><span class="line">var rootReducer = combineReducers(&#123;</span><br><span class="line">  count: count,</span><br><span class="line">  year: year,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 创建store，跟2.1没有任何区别</span><br><span class="line">var createStore = require(&apos;./&apos;).createStore;</span><br><span class="line">var store = createStore(rootReducer);</span><br><span class="line"></span><br><span class="line">var util = require(&apos;util&apos;);</span><br><span class="line">console.log(util.inspect(store));</span><br><span class="line">//输出的结果，跟2.1的store在结构上不存在区别</span><br><span class="line">// &#123; dispatch: [Function: dispatch],</span><br><span class="line">//   subscribe: [Function: subscribe],</span><br><span class="line">//   getState: [Function: getState],</span><br><span class="line">//   replaceReducer: [Function: replaceReducer]</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-2-源码解析combineReducers"><a href="#3-2-源码解析combineReducers" class="headerlink" title="3.2 源码解析combineReducers"></a>3.2 源码解析combineReducers</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 高阶函数，最后返回一个reducer</span><br><span class="line">export default function combineReducers(reducers) &#123;</span><br><span class="line">  // 提出不合法的reducers, finalReducers就是一个闭包变量</span><br><span class="line">  var finalReducers = pick(reducers, (val) =&gt; typeof val === &apos;function&apos;)</span><br><span class="line">  // 将各个reducer的初始state均设置为undefined</span><br><span class="line">  var defaultState = mapValues(finalReducers, () =&gt; undefined)</span><br><span class="line"></span><br><span class="line">  // 一个总reducer，内部包含子reducer</span><br><span class="line">  return function combination(state = defaultState, action) &#123;</span><br><span class="line">    var finalState = mapValues(finalReducers, (reducer, key) =&gt; &#123;</span><br><span class="line">      var previousStateForKey = state[key]</span><br><span class="line">      var nextStateForKey = reducer(previousStateForKey, action)</span><br><span class="line">      hasChanged = hasChanged || nextStateForKey !== previousStateForKey</span><br><span class="line">      return nextStateForKey</span><br><span class="line">    );</span><br><span class="line">    return hasChanged ? finalState : state</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-自动实现dispatch"><a href="#4-自动实现dispatch" class="headerlink" title="4. 自动实现dispatch"></a>4. 自动实现dispatch</h3><h4 id="4-1-demo介绍"><a href="#4-1-demo介绍" class="headerlink" title="4.1 demo介绍"></a>4.1 demo介绍</h4><p>在2.1中，要执行state的改变，需要手动dispatch:</p><p>var action = { type: ‘<strong><em>‘, payload: ‘</em></strong>‘};<br>dispatch(action);<br>手动dispatch就显得啰嗦了，那么如何自动完成呢?<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var bindActionCreators = require(&apos;redux&apos;).bindActionCreators;</span><br><span class="line">// 可以在具体的应用框架隐式进行该过程(例如react-redux的connect组件中)</span><br><span class="line">bindActionCreators(action)</span><br></pre></td></tr></table></figure></p><h4 id="4-2-源码解析"><a href="#4-2-源码解析" class="headerlink" title="4.2 源码解析"></a>4.2 源码解析</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 隐式实现dispatch</span><br><span class="line">function bindActionCreator(actionCreator, dispatch) &#123;</span><br><span class="line">  return (...args) =&gt; dispatch(actionCreator(...args))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default function bindActionCreators(actionCreators, dispatch) &#123;</span><br><span class="line">  if (typeof actionCreators === &apos;function&apos;) &#123;</span><br><span class="line">    return bindActionCreator(actionCreators, dispatch)</span><br><span class="line">  &#125;</span><br><span class="line">  return mapValues(actionCreators, actionCreator =&gt;</span><br><span class="line">    bindAQctionCreator(actionCreator, dispatch)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-支持插件-对dispatch的改造"><a href="#5-支持插件-对dispatch的改造" class="headerlink" title="5. 支持插件 - 对dispatch的改造"></a>5. 支持插件 - 对dispatch的改造</h3><h4 id="5-1-插件使用demo"><a href="#5-1-插件使用demo" class="headerlink" title="5.1 插件使用demo"></a>5.1 插件使用demo</h4><p>一个action可以是同步的，也可能是异步的，这是两种不同的情况， dispatch执行的时机是不一样的:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 同步的action creator, store可以默认实现dispatch</span><br><span class="line">function add() &#123;</span><br><span class="line">  return &#123; tyle: &apos;add&apos; &#125;</span><br><span class="line">&#125;</span><br><span class="line">dispatch(add());</span><br><span class="line"></span><br><span class="line">// 异步的action creator，因为异步完成的时间不确定，只能手工dispatch</span><br><span class="line">function fetchDataAsync() &#123;</span><br><span class="line">  return function (dispatch) &#123;</span><br><span class="line">    requst(url).end(function (err, res) &#123;</span><br><span class="line">      if (err) return dispatch(&#123; type: &apos;SET_ERR&apos;, payload: err&#125;);</span><br><span class="line">      if (res.status === &apos;success&apos;) &#123;</span><br><span class="line">        dispatch(&#123; type: &apos;FETCH_SUCCESS&apos;, payload: res.data &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面的问题就变成了，如何根据实际情况实现不同的dispatch方法，也即是根据需要实现不同的moddleware:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 普通的dispatch创建方法</span><br><span class="line">var store = createStore(reducer, initialState);</span><br><span class="line">console.log(store.dispatch);</span><br><span class="line"></span><br><span class="line">// 定制化的dispatch</span><br><span class="line">var applyMiddleware = require(&apos;redux&apos;).applyMiddleware;</span><br><span class="line">// 实现action异步的middleware</span><br><span class="line">var thunk = requre(&apos;redux-thunk&apos;);</span><br><span class="line">var store = applyMiddleware([thunk])(createStore);</span><br><span class="line">// 经过处理的dispatch方法</span><br><span class="line">console.log(store.dispatch);</span><br></pre></td></tr></table></figure></p><h4 id="5-2-源码解析"><a href="#5-2-源码解析" class="headerlink" title="5.2 源码解析"></a>5.2 源码解析</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// next: 其实就是createStore</span><br><span class="line">export default function applyMiddleware(...middlewares) &#123;</span><br><span class="line">  return (next) =&gt; (reducer, initialState) =&gt; &#123;</span><br><span class="line">    var store = next(reducer, initialState)</span><br><span class="line">    var dispatch = store.dispatch</span><br><span class="line">    var chain = []</span><br><span class="line"></span><br><span class="line">    var middlewareAPI = &#123;</span><br><span class="line">      getState: store.getState,</span><br><span class="line">      dispatch: (action) =&gt; dispatch(action)</span><br><span class="line">    &#125;</span><br><span class="line">    chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))</span><br><span class="line">    dispatch = compose(...chain)(store.dispatch)</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      ...store,</span><br><span class="line">      dispatch // 实现新的dispatch方法</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 再看看redux-thunk的实现, next就是store里面的上一个dispatch</span><br><span class="line">function thunkMiddleware(&#123; dispatch, getState &#125;) &#123;</span><br><span class="line">  return function(next) &#123;</span><br><span class="line">    return function(action) &#123;</span><br><span class="line">      typeof action === &apos;function&apos; ? action(dispatch, getState) : next(action);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return next =&gt; action =&gt;</span><br><span class="line">    typeof action === &apos;function&apos; ?</span><br><span class="line">      action(dispatch, getState) :</span><br><span class="line">      next(action);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="6-与react框架的结合"><a href="#6-与react框架的结合" class="headerlink" title="6. 与react框架的结合"></a>6. 与react框架的结合</h3><p>####6.1 基本使用</p><p>目前已经有现成的工具 react-redux 来实现二者的结合:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var rootReducers = combineReducers(reducers);</span><br><span class="line">var store = createStore(rootReducers);</span><br><span class="line">var Provider = require(&apos;react-redux&apos;).Provider;</span><br><span class="line">// App 为上层的Component</span><br><span class="line">class App extend React.Component&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;Provier store=&#123;store&#125;&gt;</span><br><span class="line">        &lt;Container /&gt;</span><br><span class="line">      &lt;/Provider&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Container作用: 1. 获取store中的数据; 2.将dispatch与actionCreator结合起来</span><br><span class="line">var connect = require(&apos;react-redux&apos;).connect;</span><br><span class="line">var actionCreators = require(&apos;...&apos;);</span><br><span class="line">// MyComponent是与redux无关的组件</span><br><span class="line">var MyComponent = require(&apos;...&apos;);</span><br><span class="line"></span><br><span class="line">function select(state) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    count: state.count</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default connect(select, actionCreators)(MyComponent)</span><br></pre></td></tr></table></figure></p><h4 id="6-2-Provider-–-提供store"><a href="#6-2-Provider-–-提供store" class="headerlink" title="6.2 Provider – 提供store"></a>6.2 Provider – 提供store</h4><p>React通过Context属性，可以将属性(props)直接给子孙component，无须通过props层层传递, Provider仅仅起到获得store，然后将其传递给子孙元素而已:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">export default class Provider extends Component &#123;</span><br><span class="line">  getChildContext() &#123; // getChildContext: 将store传递给子孙component</span><br><span class="line">    return &#123; store: this.store &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  constructor(props, context) &#123;</span><br><span class="line">    super(props, context)</span><br><span class="line">    this.store = props.store</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">    const &#123; store &#125; = this</span><br><span class="line">    const &#123; store: nextStore &#125; = nextProps</span><br><span class="line"></span><br><span class="line">    if (store !== nextStore) &#123;</span><br><span class="line">      warnAboutReceivingStore()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    let &#123; children &#125; = this.props</span><br><span class="line">    return Children.only(children)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="6-3-connect-–-获得store及dispatch-actionCreator"><a href="#6-3-connect-–-获得store及dispatch-actionCreator" class="headerlink" title="6.3 connect – 获得store及dispatch(actionCreator)"></a>6.3 connect – 获得store及dispatch(actionCreator)</h4><p>connect是一个高阶函数，首先传入mapStateToProps、mapDispatchToProps，然后返回一个生产 Component 的函数(wrapWithConnect)，然后再将真正的Component作为参数传入wrapWithConnect(MyComponent)，这样就生产出一个经过包裹的Connect组件，该组件具有如下特点:</p><p>通过this.context获取祖先Component的store<br>props包括stateProps、dispatchProps、parentProps,合并在一起得到 nextState ，作为props传给真正的Component<br>componentDidMount时，添加事件this.store.subscribe(this.handleChange)，实现页面交互<br>shouldComponentUpdate时判断是否有避免进行渲染，提升页面性能，并得到nextState<br>componentWillUnmount时移除注册的事件this.handleChange<br>在非生产环境下，带有热重载功能<br>主要的代码逻辑:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">export default function connect(mapStateToProps, mapDispatchToProps, mergeProps, options = &#123;&#125;) &#123;</span><br><span class="line">  return function wrapWithConnect(WrappedComponent) &#123;</span><br><span class="line">    class Connect extends Component &#123;</span><br><span class="line">      constructor(props, context) &#123;</span><br><span class="line">        // 从祖先Component处获得store</span><br><span class="line">        this.store = props.store || context.store</span><br><span class="line">        this.stateProps = computeStateProps(this.store, props)</span><br><span class="line">        this.dispatchProps = computeDispatchProps(this.store, props)</span><br><span class="line">        this.state = &#123; storeState: null &#125;</span><br><span class="line">        // 对stateProps、dispatchProps、parentProps进行合并</span><br><span class="line">        this.updateState()</span><br><span class="line">      &#125;</span><br><span class="line">      shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">        // 进行判断，当数据发生改变时，Component重新渲染</span><br><span class="line">        if (propsChanged || mapStateProducedChange || dispatchPropsChanged) &#123;</span><br><span class="line">          this.updateState(nextProps)</span><br><span class="line">            return true</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        componentDidMount() &#123;</span><br><span class="line">          // 改变Component的state</span><br><span class="line">          this.store.subscribe(() = &#123;</span><br><span class="line">            this.setState(&#123;</span><br><span class="line">              storeState: this.store.getState()</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        render() &#123;</span><br><span class="line">          // 生成包裹组件Connect</span><br><span class="line">          return (</span><br><span class="line">            &lt;WrappedComponent &#123;...this.nextState&#125; /&gt;</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      Connect.contextTypes = &#123;</span><br><span class="line">        store: storeShape</span><br><span class="line">      &#125;</span><br><span class="line">      return Connect;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="7-redux与react-redux关系图"><a href="#7-redux与react-redux关系图" class="headerlink" title="7. redux与react-redux关系图"></a>7. redux与react-redux关系图</h3><p><img src="images/redux.png!web"></p>]]></content>
    
    <summary type="html">
    
      Redux使用入门
    
    </summary>
    
      <category term="react" scheme="http://yoursite.com/categories/react/"/>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
      <category term="数据层" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%B1%82/"/>
    
      <category term="redux" scheme="http://yoursite.com/tags/redux/"/>
    
  </entry>
  
</feed>
