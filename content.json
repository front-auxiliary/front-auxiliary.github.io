{"pages":[{"title":"关于我们","text":"一群有意思的人一起提升成长一群有意思的人一起提升成长一群有意思的人一起提升成长一群有意思的人一起提升成长 一群有意思的人一起提升成长 一群有意思的人一起提升成长一群有意思的人一起提升成长一群有意思的人一起提升成长","link":"/about/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"[object Object]","text":"","link":"/scaffolds/draft.html"},{"title":"[object Object]","text":"","link":"/scaffolds/page.html"},{"title":"[object Object]","text":"","link":"/scaffolds/post.html"},{"title":"","text":"alert(\"uuuuuu\");","link":"/js/index.js"},{"title":"","text":"* { margin: 0; padding: 0; } html, body { width: 100%; height: 100%; overflow: hidden; } .content{ height: 100%; } #bideo-container{ height:100%; } #container { overflow: hidden; position: absolute; top: 0; left: 0; right: 0; bottom: 0; } #background_video { /* position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); object-fit: cover; */ height: 100%; width: 100%; } #video_cover { position: absolute; width: 100%; height: 100%; background-size: cover; background-position: center; } #video_controls { position: absolute; left: 50%; transform: translate(-50%, 0); } #play img { width: 100px; } #pause img { width: 90px; } #pause { display: none; } @media (min-width: 768px) { #video_controls { display: none; } } /* Demo page specific styles */ body { text-align: center; font-family: 'proxima-nova', Helvetica; } #container { height: 100%; } #overlay { position: absolute; top: 0; right: 0; left: 0; bottom: 0; background: rgba(0,0,0,0.4); } #links { margin-top: 50px; } #links a { border: 2px solid rgba(255,255,255,0.20); border-radius: 61px; font-size: 12px; color: #FFFFFF; letter-spacing: 1px; text-decoration: none; text-transform: uppercase; padding: 10px 25px; display: inline-block; margin-right: 15px; } #footer { position: absolute; bottom: 0; left: 0; right: 0; } #footer a { color: rgba(255,255,255,0.5); text-decoration: none; margin: 10px; font-size: 12px; } #footer a:first-child { float: left; } #footer a:last-child { float: right; } try{Typekit.load({ async: true });}catch(e){}","link":"/schedule/index.html"},{"title":"文章标签","text":"","link":"/tags/index.html"},{"title":"","text":"document.innerHtml=\"123ee\";","link":"/schedule/js/index.js"}],"posts":[{"title":"CSS省略号实现","text":"CSS实现单行多行添加省略号先介绍一下单行文本添加省略号的css代码 以下代码实现的效果为下图1234overflow: hidden;text-overflow:ellipsis;white-space: nowrap; 先介绍一下多行文本添加省略号的css代码 以下代码实现的效果为下图1234display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 3;overflow: hidden; 先介绍一下多行文本添加省略号的css代码的优化 以下代码实现的效果为下图1234567div{position: relative; line-height: 20px; max-height: 40px;overflow: hidden;}div::after{content: &quot;...&quot;; position: absolute; bottom: 0; right: 0; padding-left: 40px;background: -webkit-linear-gradient(left, transparent, #fff 55%);background: -o-linear-gradient(right, transparent, #fff 55%);background: -moz-linear-gradient(right, transparent, #fff 55%);background: linear-gradient(to right, transparent, #fff 55%);}","link":"/2016/08/25/CSS/ellipsis/"},{"title":"Flex布局","text":"Flex布局注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。 [flex学习地址]（https://css-tricks.com/snippets/css/a-guide-to-flexbox/） 一、基本概念 1234Flex容器（flex container）：采用Flex布局的元素。水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end 二、容器的属性有六个属性设置在容器上 flex-direction flex-wrap flex-flow justify-content align-items align-content flex-direction属性决定主轴的方向（即子元素的排列方向）123.box { flex-direction: row | row-reverse | column | column-reverse;} 他有四个值 row(默认值)：主轴为水平方向，起点在左边 row-reverse:主轴为水平方向，起点为右边 column：主轴为垂直方向，起点在上方 column-reverse：主轴为垂直方向，起点在下方 flex-wrap属性定义如果一条轴放不下，该如何换行123.box{ flex-wrap: nowrap | wrap | wrap-reverse;} 他有三个可取值 nowrap(默认)：不换行 wrap:换行，第一行在上方 wrap-reverse:换行，第一行在下方 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。123.box { flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;} justify-content定义了子元素在主轴上的对齐方向123.box { justify-content: flex-start | flex-end | center | space-between | space-around;} 他有5个值 flex-start(默认值)：左对齐 flex-end:右对齐 center：居中 space-between：两端对齐，项目之间的间隔都相等 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-itemsalign-items属性定义项目在交叉轴上如何对齐123.box { align-items: flex-start | flex-end | center | baseline | stretch;} flex-start：交叉轴的起点对齐 flex-end:交叉轴的终点对齐 center：交叉轴的中点对齐 baseline：项目的第一行文字的基线对齐 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度 align-contentalign-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。123.box { align-content: flex-start | flex-end | center | space-between | space-around | stretch;} flex-start：交叉轴的起点对齐 flex-end:交叉轴的终点对齐 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 三、项目的属性以下6个属性设置在项目上 order flex-grow flex-shrink flex-basis flex align-self orderorder属性定义项目的排列顺序。数值越小，排列越靠前，默认为0123.item { order: &lt;integer&gt;;} flex-growflex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrink定义项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。123.item { flex-shrink: &lt;number&gt;; /* default 1 */} 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小 flex-basisflex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。123.item { flex-basis: &lt;length&gt; | auto; /* default auto */} 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间 flexflex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。123.item { flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ]} 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值. align-selfalign-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。123.item { align-self: auto | flex-start | flex-end | center | baseline | stretch;} 四、flex兼容性flex更新版本 display:box是2009年的语法版本，使用时需要加上浏览器的前缀，不过现在已经过时了。 display:flex是2012年最新修正的语法版本，浏览器支持较好，也将成为以后标准的语法。 中间2011年也提出了一个奇葩的语法版本display:flexbox，非官方的，当时主要是为IE浏览器使用。 PC端：display:box 浏览器支持 IE Firefox Chrome Safari Opera 不支持 2.0-40.0（-moz-） 4.0-45.0(-webkit-) 6.0-8.0(-webkit-) 15.0-29.0(-webkit-) display:flex浏览器支持 IE Firefox Chrome Safari Opera 11.0+ 22.0+ 21.0+(-webkit-) 29.0+ 6.1+(-webkit-) 9.0+ 15.0+(-webkit-) 17.0+ 移动端：display:flex iOS的原生safari浏览器是支持的；UC浏览器支持的很好；微信浏览器不支持 安卓的原生浏览器不支持，能够正常显示模块，文档流依次排列；UC浏览器不支持，显示为空白；微信浏览器不支持 display:box ios的原生safari浏览器是支持的；UC浏览器支持的很好 安卓的原生浏览器支持；UC浏览器支持 123456789其实要使多浏览器兼容flexbox容器样式，可以使用如下CSS样式进行定义：.box { display: -webkit-box; /* Chrome 4+, Safari 3.1, iOS Safari 3.2+ */ display: -moz-box; /* Firefox 17- */ display: -webkit-flex; /* Chrome 21+, Safari 6.1+, iOS Safari 7+, Opera 15/16 */ display: -moz-flex; /* Firefox 18+ */ display: -ms-flexbox; /* IE 10 */ display: flex; /* Chrome 29+, Firefox 22+, IE 11+, Opera 12.1/17/18, Android 4.4+ */}","link":"/2016/08/25/CSS/flex/"},{"title":"mac终端配置sublime和vsCode的快捷方式","text":"mac终端配置sublime和vsCode的快捷方式vsCode的终端命令配置mac端配置 vsCode的终端命令配置较为简单，运行VS code并打开命令面板（ ⇧⌘P ），然后输入 shell command 找到: Install ‘code’ command in PATH 就行了。code命令还支持其他参数，具体看 12//配好后的使用方法(打开当前路径)code . sublime的终端配置mac端配置123456789// 1. 打开终端cd ~ls -la//找打.zshrc文件如果安装过atom 就输入 atom .zshrc 如果有 vim 就输入 vim .zshrc这里我用vimvim .zshrc//到 atom 中 //把下面内容粘贴到最后 alias subl=”‘/Applications/Sublime.app/Contents/SharedSupport/bin/subl’”alias nano=”subl”export EDITOR=”subl” 上面的第一行里是自己sublime的在、安装路径一般只有 Sublime.app 不一样 12//配好后的使用方法(打开当前路径)记得重启终端subl . 因为 atom 在这两款中显得较为鸡肋就不做介绍","link":"/2019/07/13/IDE/mac-path/"},{"title":"vim命令总结","text":"vim 的基本概念vim大致分可为这么几种状态，分别是命令模式、插入模式、视图模式、和底行模式，各模式的功能区分如下： 1) 命令行模式控制屏幕光标的移动，字符、字或行的删除，移动复制某区段 2) 插入模式按 i 进入插入模式,对文件的内容进行编辑操作，按 ESC 键可回到命令行模式 3) 视图模式按 v 或者 V 进入视图模式，对文字区段进行选择,然后进行相应的操作（比如复制一段文字，删除一段文字等等） 4) 底行模式按 : 或者 / 进入底行模式,其实底行模式也是命令模式的一种等 常使用底行模式对文件文件保存或退出vim，也可以设置编辑环境，如寻找字符串、列出行号……等 基本命令1) 命令行模式h 向左移动光标 j 向下移动光标 k 向上移动光标 l 向右移动光标 0 移到文件的开头 G 移动到文件的最后 $ 移动到光标所在行的“行尾” ^ 移动到光标所在行的“行首” w 光标跳到下个字的开头 e 光标跳到下个字的字尾 b 光标回到上个字的开头 nl 光标移到该行的第n的位置，其中n是数字 如：5l 将光标移动到当前行的第5个字符处 x 每按一次，删除光标所在位置的“后面”一个字符 nx 删除光标所在位置的“后面”n个字符,n是数字,比如 5x X 删除光标所在位置的“前面”一个字符 nX 删除光标所在位置的“前面”n个字符,n是数字,比如 5X dd 删除光标所在行 ndd 从光标所在行开始删除n行 yw 将光标所在之处到字尾的字符复制到缓冲区中 nyw 复制n个字到缓冲区 yy 复制光标所在行到缓冲区 nyy 例如，6yy表示拷贝从光标所在的该行“往下数”6行文字 p 将缓冲区内的字符贴到光标所在位置注意：所有与“y”有关的复制命令都必须与“p”配合才能完成复制与粘贴功能 r 替换光标所在处的字符 R 替换光标所到之处的字符，直到按下「ESC」键为止 u 如果您误执行一个命令，可以马上按下「u」，回到上一个操作按多次“u”可以执行多次回复 cw 更改光标所在处的字到字尾处 cnw 例如，c3w表示更改3个字,其中n是数字 nG(或者ngg)例如，15G表示移动光标至文件的第15行的行首,其中n是数字 ctrl+g 列出光标所在行的行号 ci”清除引号内容 ci&gt; 清除尖括号内容 cit 清除标签内的内容 zc 折叠 zC 对所在范围内所有嵌套的折叠点进行折叠 zo 展开折叠 zO 对所在范围内所有嵌套的折叠点展开 [z 到当前打开的折叠的开始处 ]z 到当前打开的折叠的末尾处 zj 向下移动,到达下一个折叠的开始处,关闭的折叠也被计入 zk 向上移动到前一折叠的结束处,关闭的折叠也被计入 xp 交换两个字符的位置 ddp 上下两行调换 移动屏幕ctrl+g 列出光标所在行的行 ctrl+b 屏幕往“后”移动一页 ctrl+f 屏幕往“前”移动一页 ctrl+u 屏幕往“后”移动半页 ctrl+d 屏幕往“前”移动半页 shift +3 选中并查找该词组 跳转位置ctrl+o 回到更老的跳转位置 ctrl+i 向前跳转位置(两个命令前面可以加数字来表示倍数) 改变大小写~ 将光标下的字母改变大小写 3~ 将光标位置开始的3个字母改变其大小写 g~~ 改变当前行字母的大小写 U 将可视模式下选择的字母全改成大写字母 u 将可视模式下选择的字母全改成小写 gUU 将当前行的字母改成大写 3gUU 将从光标开始到下面3行字母改成大写 guu 将当前行的字母全改成小写 gUw 将光标下的单词改成大写。 guw 将光标下的单词改成小写。 2) 插入模式i 在光标的前面插入字符 I 在当前行的第一个字符前插入字符 o 在当前行的下一行插入新的一行,并在新的一行的第一个字符处插入字符 O 在当前行的上一行插入新的一行,并在新的一行的第一个字符处插入字符 a 在光标的后面插入字符 A 在当前行的最后面插入字符 按[Esc]回到命令模式 3) 视图模式vi” 选择引号内容 vi&gt; 选择尖括号内容 vit 选择标签内的内容 va” 选择包括引号在内的内容 va&gt; 选择包括尖括号在内的内容 vat 选择整个标签 4) 底行模式 :w filename 将文件以指定的文件名filename保存 :wq 存盘并退出vim :q! 不存盘强制退出vim :set nu 显示行号 :15 回车，跳到文件第15行 /关键字, 先按「/」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往后寻找到您要的关键字为止 ?关键字, 先按「?」键，再输入您想寻找的字符，如果第一次找的关键字ä¡ :-n,+n d ‘-‘表示当前行的上n行，’+’表示当前行的下n行,比如命令’:-2,+2 d’的意思，就是说删除但前行的上2行到当前行的下2行 :n pu 将剪切板中的内容粘贴到n行 :e filename 在当前编辑的窗口中打开指定的“filename”的文件进行编辑操作 :p 文件操作，前一个文件 :n 文件操作，下一个文件 :last 文件操作，最后一个文件 :!cmd 执行shell命令 :sh 进入shell :exit 退出shell 按[Esc]回到命令模式","link":"/2016/08/25/IDE/vim/"},{"title":"atom快捷键总结","text":"atom一、快捷键部分A:光标及选取部分行部分： cmd+up 光标移动至文件开始处 cmd+down 光标移动至文件结束处 cmd+click 多行同时输入 cmd+l 选取此行 ctrl+shift+n 选取下一行 ctrl+shift+p 选取下一行 cmd+shift+left 选取至此行开始处 cmd+shift+right 选取至此行结束处 cmd+shift+up 选取至文件开始 cmd+shift+down 选取至文件结尾 单词(字符)部分： cmd+shift+w 选中此单词 alt+shift+left 选取至此单词开始处 alt+shift+right 选取至此单词结束处 cmd+d 选取文件中和当前单词相同的下一处并增加光标 ctrl+cmd+g 选取文档中所有和当前光标单词相同的位置并增加光标 括号部分： ctrl-m 相应括号之间，html tag之间等跳转 ctrl-cmd-m 括号(tag)之间文本选取 B:编辑操作行部分：cmd-J 将下一行与当前行合并ctrl-cmd-up, ctrl-cmd-down 使当前行向上或者向下移动cmd-shift-D 复制当前行到下一行ctrl-K 剪切到当前行结束ctrl-shift-K 删除当前行cmd-backspace 删除到当前行开始cmd-fn-backspace 删除到当前行结束 字符(单词)部分： ctrl-T 使光标前后字符交换 alt-backspace 或 alt-H 删除到当前单词开始 alt-delete 或 alt-D 删除到当前单词结束 cmd-K+cmd-U 使当前字符大写 cmd-K+cmd-L 使当前字符小写 C:功能部分 cmd+, 打开setting control+tab 切换标签页 control+数字 切换标签页 忽略文件显示更改： setting=&gt;open config Folder=&gt;config.cson=&gt;最后那个h开头的改为false 二、atom实用插件1 Emmet 用法：Ctrl+Alt+Enter 2 Atom Beautify 代码优化 3 Minimap sublime右上角代码缩略图 4 file-icons 文件图标 5 atom-ternjs js代码提示 6 atom-react-autocomplete jsx代码提示","link":"/2016/08/25/IDE/atom/"},{"title":"vsCode  编辑器","text":"vsCode 编辑器相关文档","link":"/2016/08/25/IDE/vscode/"},{"title":"React生命周期","text":"React生命周期用一个表格表示生命周期 函数 解释 getDefaultProps 作用于组件类，只调用一次，返回对象用于设置默认的props，对于引用值，会在实例中共享 getInitialState 作用于组件的实例，在实例创建时调用一次，用于初始化每个实例的state，此时可以访问this.props componentWillMount 在完成首次渲染之前调用，此时仍可以修改组件的state render 必选的方法，创建虚拟DOM，该方法具有特殊的规则： 1.只能通过this.props和this.state访问数据 2.可以返回null、false或任何React组件 3.只能出现一个顶级组件（不能返回数组） 4.不能改变组件的状态 5.不能修改DOM的输出 componentDidMount 真实的DOM被渲染出来后调用，在该方法中可通过this.getDOMNode()访问到真实的DOM元素。此时已可以使用其他类库来操作这个DOM。在服务端中，该方法不会被调用 componentWillReceiveProps 组件接收到新的props时调用，并将其作为参数nextProps使用，此时可以更改组件props及state shouldComponentUpdate 组件是否应当渲染新的props或state，返回false表示跳过后续的生命周期方法，通常不需要使用以避免出现bug。在出现应用的瓶颈时，可通过该方法进行适当的优化 componentWillUpdate 接收到新的props或者state后，进行渲染之前调用，此时不允许更新props或state componentDidUpdate 完成渲染新的props或者state后调用，此时可以访问到新的DOM元素 componentWillUnmount 组件被移除之前被调用，可以用于做一些清理工作，在componentDidMount方法中添加的所有任务都需要在该方法中撤销，比如创建的定时器或添加的事件监听器 实例化首次实例化12345getDefaultPropsgetInitialStatecomponentWillMountrendercomponentDidMount 实例化完成后的更新1234getInitialStatecomponentWillMountrendercomponentDidMount 存在期组件已存在时的状态改变12345componentWillReceivePropsshouldComponentUpdatecomponentWillUpdaterendercomponentDidUpdate 销毁&amp;清理期1componentWillUnmount 说明生命周期共提供了10个不同的API。 1.getDefaultProps作用于组件类，只调用一次，返回对象用于设置默认的props，对于引用值，会在实例中共享。 2.getInitialState作用于组件的实例，在实例创建时调用一次，用于初始化每个实例的state，此时可以访问this.props。 3.componentWillMount在完成首次渲染之前调用，此时仍可以修改组件的state。 4.render必选的方法，创建虚拟DOM，该方法具有特殊的规则： 只能通过this.props和this.state访问数据可以返回null、false或任何React组件只能出现一个顶级组件（不能返回数组）不能改变组件的状态不能修改DOM的输出 5.componentDidMount真实的DOM被渲染出来后调用，在该方法中可通过this.getDOMNode()访问到真实的DOM元素。此时已可以使用其他类库来操作这个DOM。 在服务端中，该方法不会被调用。 6.componentWillReceiveProps组件接收到新的props时调用，并将其作为参数nextProps使用，此时可以更改组件props及state。 componentWillReceiveProps: function(nextProps) { if (nextProps.bool) { this.setState({ bool: true }); } } 7.shouldComponentUpdate组件是否应当渲染新的props或state，返回false表示跳过后续的生命周期方法，通常不需要使用以避免出现bug。在出现应用的瓶颈时，可通过该方法进行适当的优化。 在首次渲染期间或者调用了forceUpdate方法后，该方法不会被调用 8.componentWillUpdate接收到新的props或者state后，进行渲染之前调用，此时不允许更新props或state。 9.componentDidUpdate完成渲染新的props或者state后调用，此时可以访问到新的DOM元素。 10.componentWillUnmount组件被移除之前被调用，可以用于做一些清理工作，在componentDidMount方法中添加的所有任务都需要在该方法中撤销，比如创建的定时器或添加的事件监听器。","link":"/2019/07/13/React/lifecyce/"},{"title":"react项目搭建","text":"react项目搭建要想使用npm,请先安装nodejs. 第一步、安装全局包123$ npm install babel -g$ npm install webpack -g$ npm install webpack-dev-server -g 第二步、创建根目录创建一个根目录，目录名为：reactApp，再使用 npm init 初始化，生成 package.json 文件：123$ mkdir reactApp$ cd reactApp/$ npm init 命令行显示以下内容1234567891011121314151617181920212223242526272829name: (reactApp) runoob-react-testversion: (1.0.0)description: cllgeekentry point: (index.js)test command:git repository:keywords:author:license: (ISC)About to write to /Users/tianqixin/www/reactApp/package.json:{ &quot;name&quot;: &quot;react-runoob&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;cllgeek test&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: { &quot;start&quot;: &quot;webpack-dev-server --hot&quot; }, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: { &quot;react&quot;: &quot;^0.14.8&quot;, &quot;react-dom&quot;: &quot;^0.14.8&quot; }}Is this ok? (yes) 第三步、添加越来包及插件因为我们要使用 React, 所以我们需要先安装它，–save 命令用于将包添加至 package.json 文件。12345678$ npm install react --save$ npm install react-dom --save同时我们也要安装一些 babel 插件$ npm install babel-core$ npm install babel-loader$ npm install babel-preset-react$ npm install babel-preset-es2015 第四步、创建文件123456接下来我们创建一些必要文件：$ touch index.html$ touch App.jsx$ touch main.js$ touch webpack.config.js 第五步、设置编译器，服务器，载入器打开 webpack.config.js 文件添加以下代码:12345678910111213141516171819202122232425262728var config = { entry: &apos;./main.js&apos;, output: { path:&apos;./&apos;, filename: &apos;index.js&apos;, }, devServer: { inline: true, port: 8888 }, module: { loaders: [ { test: /.jsx?$/, exclude: /node_modules/, loader: &apos;babel&apos;, query: { presets: [&apos;es2015&apos;, &apos;react&apos;] } }] }}module.exports = config; entry: 指定打包的入口文件 main.js。output：配置打包结果，path定义了输出的文件夹，filename则定义了打包结果文件的名称。devServer：设置服务器端口号为 8888，端口后你可以自己设定 。module：定义了对模块的处理逻辑，这里可以用loaders定义了一系列的加载器，以及一些正则。当需要加载的文件匹配test的正则时，就会调用后面的loader对文件进行处理，这正是webpack强大的原因。现在打开 package.json 文件，找到 “scripts” 中的 “test” “echo \\”Error: no test specified\\” &amp;&amp; exit 1″ 使用以下代码替换： “start”: “webpack-dev-server –hot”替换后的 package.json 文件 内容如下： $ cat package.json123456789101112131415{ &quot;name&quot;: &quot;runoob-react-test&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;cllgeek test&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: { &quot;start&quot;: &quot;webpack-dev-server --hot&quot; }, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: { &quot;react&quot;: &quot;^0.14.7&quot;, &quot;react-dom&quot;: &quot;^0.14.7&quot; }} 现在我们可以使用 npm start 命令来启动服务。–hot 命令会在文件变化后重新载入，这样我们就不需要在代码修改后重新刷新浏览器就能看到变化。 第六步、index.html设置 div id = “app” 为我们应用的根元素，并引入 index.js 脚本文件。1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset = &quot;UTF-8&quot;&gt;&lt;title&gt;React App - cllgeek(cllgeek.com)&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;div id = &quot;app&quot;&gt;&lt;/div&gt; &lt;script src = &quot;index.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 第七步、App.jsx 和 main.js这是第一个 react 组件。后面的章节我们会详细介绍 React 组件。这个组件将输出 Hello World!!!。1234567891011121314App.jsx 文件代码import React from &apos;react&apos;;class App extends React.Component { render() { return ( &lt;div&gt; Hello World!!! &lt;/div&gt; ); }}export default App; 我们需要引入组件并将其渲染到根元素 App 上，这样我们才可以在浏览器上看到它。main.js 文件代码123456import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import App from &apos;./App.jsx&apos;;ReactDOM.render(&lt;App /&gt;, document.getElementById(&apos;app&apos;)) 注意：如果想要组件可以在任何的应用中使用，需要在创建后使用 export 将其导出，在使用组件的文件使用 import将其导入。 第八步、运行服务完成以上配置后，我们即可运行该服务：12$ npm start通过浏览器访问 http://localhost:7777/，输出结果如下:","link":"/2019/07/13/React/react/"},{"title":"git区分大小写","text":"其实 git 默认对于文件名大小写是不敏感的,所以上面你修改了首字母大写,但是git 并没有发现代码任何改动. 那么如何才能让 git 识别文件名大小写变化. 一 配置git 使其对文件名大小写敏感 git config core.ignorecase false 12Administrator@SC-202102021413 F:\\xunlian\\hexo&gt;git config core.ignorecase false 二 从git 本地仓库删除此文件,然后添加再提交 (1) 删除12Administrator@SC-202102021413 F:\\xunlian\\hexo&gt;git rm readme.md (2) 重新添加12Administrator@SC-202102021413 F:\\xunlian\\hexo&gt;git add Readme.md (3)提交12Administrator@SC-202102021413 F:\\xunlian\\hexo&gt;git commit -m &apos;Readme.md&apos; 推荐第一种方法,配置好git 对文件名大小写敏感.","link":"/2019/07/13/git/git-capitalize/"},{"title":"Git设置上传忽略","text":"Git设置上传忽略忽略语法规则123456789101112131415161718192021222324252627282930313233343536373839404142# 忽略*.o和*.a文件 *.[oa]# 忽略*.b和*.B文件，my.b除外*.[bB]!my.b# 忽略dbg文件和dbg目录dbg# 只忽略dbg目录，不忽略dbg文件dbg/# 只忽略dbg文件，不忽略dbg目录dbg!dbg/# 只忽略当前目录下的dbg文件和目录，子目录的dbg不在忽略范围内/dbg# 忽略所有 .a 结尾的文件*.a# 但 lib.a 除外!lib.a # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO/TODO # 忽略 build/ 目录下的所有文件build/ # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txtdoc/*.txt 下面介绍3种方法来设置上传忽略配置： 【方法一】 通过配置.git/info/exclude文件来忽略文件。这种方式对仓库全局有效，只能对自己本地仓库有作用，其他人没办法通过这种方式来共享忽略规则，除非他人也修改其本地仓库的该文件。 【方法二】 通过.git/config配置文件的core. Excludesfile选项，指定一个忽略规则文件（完整路径），如下图所示。忽略规则在文件e:/gitignore.txt中（当然该文件名可以任意取）。在config的[remote “origin”]上一行添加 excludesfile = e:/gitignore.text即可 123456789 [core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true excludesfile = e:/gitignore.text[remote &quot;origin&quot;] 该方式的作用域是也全局的。 【方式三】 在项目根目录下创建.gitignore文件如果已经创建则不用创建然后在该文件中添加忽略语法 .gitignore文件对其所在的目录及所在目录的全部子目录均有效。通过将.gitignore文件添加到仓库，其他开发者更新该文件到本地仓库，以共享同一套忽略规则。","link":"/2019/07/13/git/git-neglect/"},{"title":"git命令总结","text":"Git查看、添加、提交、删除、找回，重置修改文件1234567891011121314151617181920212223242526272829git help &lt;command&gt; # 显示command的helpgit show # 显示某次提交的内容 git show $id#git checkout-- &lt;file&gt; # 抛弃工作区修改#git checkout. # 抛弃工作区修改git add &lt;file&gt; # 将工作文件修改提交到本地暂存区git add . # 将所有修改过的工作文件提交暂存区git rm &lt;file&gt; # 从版本库中删除文件git rm &lt;file&gt; --cached # 从版本库中删除文件，但不删除文件git reset &lt;file&gt; # 从暂存区恢复到工作文件git reset -- . # 从暂存区恢复到工作文件git reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改git commit &lt;file&gt; git commit . git commit -a # 将git add, git rm和git commit等操作都合并在一起做 git commit -am &quot;some comments&quot;git commit --amend # 修改最后一次提交记录git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建次提交对象git revert HEAD # 恢复最后一次提交的状态 查看文件diff1234567891011git diff &lt;file&gt; # 比较当前文件和暂存区文件差异 git diffgit diff &lt;id1&gt;&lt;id1&gt;&lt;id2&gt; # 比较两次提交之间的差异git diff &lt;branch1&gt;..&lt;branch2&gt; # 在两个分支之间比较git diff --staged # 比较暂存区和版本库差异git diff --cached # 比较暂存区和版本库差异git diff --stat # 仅仅比较统计信息 查看提交记录1234567891011git log git log &lt;file&gt; # 查看该文件每次提交记录git log -p &lt;file&gt; # 查看每次详细修改内容的diffgit log -p -2 # 查看最近两次详细修改内容的diffgit log --stat #查看提交统计信息tigMac上可以使用tig代替diff和log，brew install tig Git 本地分支管理查看、切换、创建和删除分支1234567891011121314151617181920212223git branch -r # 查看远程分支git branch &lt;new_branch&gt; # 创建新的分支git branch -v # 查看各个分支最后提交信息git branch --merged # 查看已经被合并到当前分支的分支git branch --no-merged # 查看尚未被合并到当前分支的分支git checkout&lt;branch&gt; # 切换到某个分支git checkout-b &lt;new_branch&gt; # git checkout-b &lt;new_branch&gt; &lt;branch&gt; # 基于branch创建新的new_branchgit checkout$id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除git checkout$id -b &lt;new_branch&gt; # 把某次历史提交记录checkout出来，创建成一个分支git branch -d &lt;branch&gt; # 删除某个分支git branch -D &lt;branch&gt; # 强制删除某个分支 (未被合并的分支被删除的时候需要强制) 分支合并和rebase12345678910111213git merge &lt;branch&gt; # 将branch分支合并到当前分支git merge origin/master --no-ff # 不要Fast-Foward合并，这样可以生成merge提交git rebase master &lt;branch&gt; # 将master rebase到branch，相当于： git checkout&lt;branch&gt; &amp;&amp; git rebase master &amp;&amp; git checkoutmaster &amp;&amp; git merge &lt;branch&gt; Git补丁管理(方便在多台机器上开发同步时用)# git diff &gt; ../sync.patch # 生成补丁# git apply ../sync.patch # 打补丁# git apply --check ../sync.patch #测试补丁能否成功 Git暂存管理1234567git stash # 暂存git stash list # 列所有stashgit stash apply # 恢复暂存创建新的分支，并且切换过去的内容git stash drop # 删除暂存区 Git远程分支管理1234567891011121314151617181920212223git pull # 抓取远程仓库所有分支更新并合并到本地error：git pull --no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并git fetch origin # 抓取远程仓库更新git merge origin/master # 将远程主分支合并到本地当前分支# git checkout--track origin/branch # 跟踪某个远程分支创建相应的本地分支git checkout-b &lt;local_branch&gt; origin/&lt;remote_branch&gt; # 基于远程分支创建本地分支，功能同上git push # push所有分支git push origin master # 将本地主分支推到远程主分支git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)git push origin &lt;local_branch&gt; # 创建远程分支， origin是远程仓库名git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; # 创建远程分支git push origin :&lt;remote_branch&gt; #先删除本地分支(git branch -d &lt;branch&gt;)，然后再push删除远程分支 Git远程仓库管理123456789GitHubgit remote -v # 查看远程服务器地址和仓库名称git remote show origin # 查看远程服务器仓库状态git remote add origin git@ github:robbin/robbin_site.git # 添加远程仓库地址git remote set-url origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址) git remote rm &lt;repository&gt; # 删除远程仓库 创建远程仓库12345678910111213git clone --bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库scp -r my_project.git git@ git.csdn.net:~ # 将纯仓库上传到服务器上mkdir robbin_site.git &amp;&amp; cd robbin_site.git &amp;&amp; git --bare init # 在服务器创建纯仓库git remote add origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址git push -u origin master # 客户端首次提交git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且trackgit remote set-head origin master # 设置远程仓库的HEAD指向master分支 也可以命令设置跟踪远程库和本地库123git branch --set-upstream master origin/mastergit branch --set-upstream develop origin/develop","link":"/2016/08/25/git/git/"},{"title":"ECMAScript 提案","text":"标准的流程包括五个步骤：stage0 strawman任何讨论、想法、改变或者还没加到提案的特性都在这个阶段。只有TC39成员可以提交。 stage1 proposal（1）产出一个正式的提案。（2）发现潜在的问题，例如与其他特性的关系，实现难题。（3）提案包括详细的API描述，使用例子，以及关于相关的语义和算法。 stage2 draft（1）提供一个初始的草案规范，与最终标准中包含的特性不会有太大差别。草案之后，原则上只接受增量修改。（2）开始实验如何实现，实现形式包括polyfill, 实现引擎（提供草案执行本地支持），或者编译转换（例如babel） stage3 candidate（1）候选阶段，获得具体实现和用户的反馈。此后，只有在实现和使用过程中出现了重大问题才会修改。 （2）规范文档必须是完整的，评审人和ECMAScript的编辑要在规范上签字。（3）至少要在一个浏览器中实现，提供polyfill或者babel插件。 stage4 finished（1）已经准备就绪，该特性会出现在下个版本的ECMAScript规范之中。（2）需要通过有2个独立的实现并通过验收测试，以获取使用过程中的重要实践经验。 TC39什么鬼？什么成分？主要业务是什么？一个推动 JavaScript 发展的委员会，由各个主流浏览器厂商的代表构成。制定ECMAScript标准，标准生成的流程，并实现。 相关 stage0-4的具体内容查看地址stage0 的提案 https://github.com/tc39/proposals/blob/master/stage-0-proposals.mdstage1 - 4 的提案 https://github.com/tc39/proposa 推荐阅读：精读 TC39 与 ECMAScript 提案","link":"/2019/07/13/javaScript/ECMAScript/"},{"title":"柯里化函数","text":"柯里化函数 在计算机科学中，柯里化（英语：Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。这个技术由 Christopher Strachey 以逻辑学家哈斯凯尔·加里命名的，尽管它是 Moses Schönfinkel 和 Gottlob Frege 发明的。 这是来自维基百科的名词解释。顾名思义，柯里化其实本身是固定一个可以预期的参数，并返回一个特定的函数，处理批特定的需求。这增加了函数的适用性，但同时也降低了函数的适用范围。看一下通用实现： 12345678function currying(fn) { var slice = Array.prototype.slice, __args = slice.call(arguments, 1); return function () { var __inargs = slice.call(arguments); return fn.apply(null, __args.concat(__inargs)); };} 柯里化的实用性体现在很多方面：1 提高适用性。 【通用函数】解决了兼容性问题，但同时也会再来，使用的不便利性，不同的应用场景往，要传递很多参数，以达到解决特定问题的目的。有时候应用中，同一种规则可能会反复使用，这就可能会造成代码的重复性。 看下面一个例子： 12345678910111213141516171819202122function square(i) { return i * i;}function dubble(i) { return i *= 2;}function map(handeler, list) { return list.map(handeler);}// 数组的每一项平方map(square, [1, 2, 3, 4, 5]);map(square, [6, 7, 8, 9, 10]);map(square, [10, 20, 30, 40, 50]);// ......// 数组的每一项加倍map(dubble, [1, 2, 3, 4, 5]);map(dubble, [6, 7, 8, 9, 10]);map(dubble, [10, 20, 30, 40, 50]); 例子中，创建了一个map通用函数，用于适应不同的应用场景。显然，通用性不用怀疑。同时，例子中重复传入了相同的处理函数：square和dubble。 应用中这种可能会更多。当然，通用性的增强必然带来适用性的减弱。但是，我们依然可以在中间找到一种平衡。 看下面，我们利用柯里化改造一下： 1234567891011121314151617181920212223function square(i) { return i * i;}function dubble(i) { return i *= 2;}function map(handeler, list) { return list.map(handeler);}var mapSQ = currying(map, square);mapSQ([1, 2, 3, 4, 5]);mapSQ([6, 7, 8, 9, 10]);mapSQ([10, 20, 30, 40, 50]);// ......var mapDB = currying(map, dubble);mapDB([1, 2, 3, 4, 5]);mapDB([6, 7, 8, 9, 10]);mapDB([10, 20, 30, 40, 50]);// ...... 我们缩小了函数的适用范围，但同时提高函数的适性。当然，也有扩展函数适用范围的方法–反柯里化，留到下一篇再讨论。 由此，可知柯里化不仅仅是提高了代码的合理性，更重的它突出一种思想—降低适用范围，提高适用性。 下面再看一个例子，一个应用范围更广泛更熟悉的例子：12345678910111213141516171819202122232425262728function Ajax() { this.xhr = new XMLHttpRequest();}Ajax.prototype.open = function(type, url, data, callback) { this.onload = function() { callback(this.xhr.responseText, this.xhr.status, this.xhr); } this.xhr.open(type, url, data.async); this.xhr.send(data.paras);}&apos;get post&apos;.split(&apos; &apos;).forEach(function(mt) { Ajax.prototype[mt] = currying(Ajax.prototype.open, mt);});var xhr = new Ajax();xhr.get(&apos;/articles/list.php&apos;, {},function(datas) { // done(datas) });var xhr1 = new Ajax();xhr1.post(&apos;/articles/add.php&apos;, {},function(datas) { // done(datas) }); 2 延迟执行。 柯里化的另一个应用场景是延迟执行。不断的柯里化，累积传入的参数，最后执行。 看下面：123456789101112131415var add = function() { var _this = this, _args = arguments return function() { if (!arguments.length) { var sum = 0; for (var i = 0, c; c = _args[i++];) sum += c return sum } else { Array.prototype.push.apply(_args, arguments) return arguments.callee } }}add(1)(2)(3)(4)();//10 通用的写法： 12345678910var curry = function(fn) { var _args = [] return function cb() { if (arguments.length == 0) { return fn.apply(this, _args) } Array.prototype.push.apply(_args, arguments); return cb; }} 上面累加的例子，可以实验一下怎么写？ 3 固定易变因素。柯里化特性决定了它这应用场景。提前把易变因素，传参固定下来，生成一个更明确的应用函数。最典型的代表应用，是bind函数用以固定this这个易变对象。 1234567Function.prototype.bind = function(context) { var _this = this, _args = Array.prototype.slice.call(arguments, 1); return function() { return _this.apply(context, _args.concat(Array.prototype.slice.call(arguments))) }}","link":"/2016/08/25/javaScript/Currying/"},{"title":"javaScript的arguments, caller, callee","text":"javaScript的arguments, caller, calleeargumentsarguments: 在函数调用时， 会自动在该函数内部生成一个名为 arguments的隐藏对象。 该对象类似于数组， 但又不是数组。可以使用[]操作符获取函数调用时传递的实参。12345678function testArg() { alert(&quot;real parameter count: &quot;+arguments.length); for(var i = 0; i &lt; arguments.length; i++) { alert(arguments[i]); } } 需要注意的是 argument 保存的实参的信息arguments 不是一个数组,验证代码1234(function () { alert(arguments instanceof Array); // false alert(typeof(arguments)); // object })(); 只有函数被调用时，arguments对象才会创建，未调用时其值为null：1alert(new Function().arguments);//return null arguments 的完整语法如下：[function.]arguments[n]参数function ：选项。当前正在执行的 Function 对象的名字。 n ：选项。要传递给 Function 对象的从0开始的参数值索引。 caller在一个函数调用另一个函数时，被调用函数会自动生成一个caller属性，指向调用它的函数对象。如果该函数当前未被调用，或并非被其他函数调用，则caller为null。12345678910function testCaller() { var caller = testCaller.caller; console.log(caller); } testCaller(); //nullfunction aCaller() { testCaller(); } aCaller(); //function aCaller() {testCaller();} callee当函数被调用时，它的arguments.callee对象就会指向自身，也就是一个对自己的引用。由于arguments在函数被调用时才有效，因此arguments.callee在函数未调用时是不存在的（即null.callee），且解引用它会产生异常。123456789function aCallee(arg) { console.log(arguments.callee); } function aCaller(arg1, arg2) { aCallee();} aCaller();","link":"/2016/08/25/javaScript/arguments/"},{"title":"js变量提升","text":"变量提升与函数提升 在JavaScript中存在提升的情况，这种提升有两种提升分别是变量提升与函数提升，而且是函数会首先被提升，然后才是变量。 变量提升看下面的例子： 12console.log( a ); //undefined。var a = 2; 上面代码可以写成下面的形式 123var a;console.log( a ); //undefineda=2; 再看下面的例子： 12var a=2;console.log(a); //2 上面的代码可以写成下面的形式： 123var a;a=2;console.log(a) //2 函数提升看下面的例子： 1234foo();function foo() { console.log( a ); // undefined var a = 2;} 上面的例子可以转化成下面的形式 1234function foo() { console.log( a ); // undefined var a = 2;}foo(); 再看下面的例子： 函数声明会被提升，但是函数表达式却不会被提升12345foo(); // TypeErrorbar(); // ReferenceErrorvar foo = function bar() { ...}; 上面的代码可以转化下面的代码123456var foo;foo(); // TypeErrorbar(); // ReferenceErrorfoo = function() { var bar = foo;} 或者是转化成下面的代码123456var foo;foo(); // TypeErrorbar(); // ReferenceErrorfoo = function() { var bar = ...self...;} 再看下面的例子1234567891011foo(); // 3function foo() { console.log( 1 );}var foo = function() { console.log( 2 );};function foo() { console.log( 3 );}foo(); //2 上面的代码可以转化下面的代码123456789101112var foo;function foo() { console.log( 1 );}function foo() { console.log( 3 );}foo(); // 3var foo = function() { console.log( 2 );};foo(); //2 非常有意思的现象","link":"/2016/08/25/javaScript/ascension/"},{"title":"javaScript的call,apply,bind","text":"javaScript的call,apply,bind1、方法定义call方法:语法：call([thisObj[,arg1[, arg2[, [,.argN]]]]])定义：调用一个对象的一个方法，以另一个对象替换当前对象。说明：call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。 apply方法：语法：apply([thisObj[,argArray]])定义：应用某一对象的一个方法，用另一个对象替换当前对象。说明：如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。如果没有提供 argArray 和 thisObj 任何一个参数，那么 Global 对象将被用作 thisObj， 并且无法被传递任何参数 bind方法：语法：bind([thisObj[,arg1[,arg2[,[,.argN]]]]])bind()方法会创建一个新的函数，称为绑定函数,fun方法在this环境下调用 该方法可传入两个参数，第一个参数作为this，第二个及以后的参数则作为函数的参数调用","link":"/2016/08/25/javaScript/call/"},{"title":"javaScript各种错误类型","text":"javaScript各种错误类型1.SyntaxError（语法错误）解析代码时发生的语法错误123eg:var 1a; Uncaught SyntaxError: Unexpected number 2.ReferenceError（引用错误）a.引用了一个不存在的变量123eg: console.log(a); Uncaught ReferenceError: a is not defined b.将变量赋值给一个无法被赋值的对象123eg:console.log()= 1; Uncaught ReferenceError: Invalid left-hand side in assignment 3.RangeError（范围错误）超出有效范围123eg:var a= new Array(-1); Uncaught RangeError: Invalid array length 4.TypeError（类型错误）a.变量或参数不是预期类型，比如，对字符串、布尔值、数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数。123eg: var a= new 123; Uncaught TypeError: 123 is not a function b.调用对象不存在的方法123eg:var a;a.aa(); Uncaught TypeError: Cannot read property &apos;aa&apos; of undefined 5.URLError（URL错误）与url相关函数参数不正确，主要是encodeURI()、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape()这六个函数。123eg: decodeURI(&apos;%2&apos;) Uncaught URIError: URI malformed 6.EvalError（eval错误）eval函数没有被正确执行时，会抛出EvalError错误。该错误类型已经不再在ES5中出现了，只是为了保证与以前代码兼容，才继续保留。 以上这6种派生错误，连同原始的Error对象，都是构造函数。开发者可以使用它们，人为生成错误对象的实例。123new Error(&quot;出错了！&quot;);new RangeError(&quot;出错了，变量超出有效范围！&quot;);new TypeError(&quot;出错了，变量类型无效！&quot;); 上面代码表示新建错误对象的实例，实质就是手动抛出错误。可以看到，错误对象的构造函数接受一个参数，代表错误提示信息（message）。","link":"/2016/08/25/javaScript/error/"},{"title":"执行上下文","text":"执行上下文 在《JavaScript深入之执行上下文栈》中讲到，当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。 对于每个执行上下文，都有三个重要属性： 变量对象(Variable object，VO) 作用域链(Scope chain) this 然后分别在《JavaScript深入之变量对象》、《JavaScript深入之作用域链》、《JavaScript深入之从ECMAScript规范解读this》中讲解了这三个属性。 阅读本文前，如果对以上的概念不是很清楚，希望先阅读这些文章。 因为，这一篇，我们会结合着所有内容，讲讲执行上下文的具体处理过程。 思考题在《JavaScript深入之词法作用域和动态作用域》中，提出这样一道思考题：123456789101112131415161718var scope = &quot;global scope&quot;;function checkscope(){ var scope = &quot;local scope&quot;; function f(){ return scope; } return f();}checkscope();var scope = &quot;global scope&quot;;function checkscope(){ var scope = &quot;local scope&quot;; function f(){ return scope; } return f;}checkscope()(); 两段代码都会打印’local scope’。虽然两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？ 紧接着就在下一篇《JavaScript深入之执行上下文栈》中，讲到了两者的区别在于执行上下文栈的变化不一样，然而，如果是这样笼统的回答，依然显得不够详细，本篇就会详细的解析执行上下文栈和执行上下文的具体变化过程。 具体执行分析我们分析第一段代码：123456789var scope = &quot;global scope&quot;;function checkscope(){ var scope = &quot;local scope&quot;; function f(){ return scope; } return f();}checkscope(); 执行过程如下： 1.执行全局代码，创建全局执行上下文，全局上下文被压入执行上下文栈 ECStack = [ globalContext ]; 2.全局上下文初始化 globalContext = { VO: [global, scope, checkscope], Scope: [globalContext.VO], this: globalContext.VO } 2.初始化的同时，checkscope 函数被创建，保存作用域链到函数的内部属性[[scope]] checkscope.[[scope]] = [ globalContext.VO ]; 3.执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈 ECStack = [ checkscopeContext, globalContext ]; 4.checkscope 函数执行上下文初始化： 复制函数 [[scope]] 属性创建作用域链，用 arguments 创建活动对象，初始化活动对象，即加入形参、函数声明、变量声明，将活动对象压入 checkscope 作用域链顶端。同时 f 函数被创建，保存作用域链到 f 函数的内部属性[[scope]]1234567891011checkscopeContext = { AO: { arguments: { length: 0 }, scope: undefined, f: reference to function f(){} }, Scope: [AO, globalContext.VO], this: undefined} 5.执行 f 函数，创建 f 函数执行上下文，f 函数执行上下文被压入执行上下文栈12345ECStack = [ fContext, checkscopeContext, globalContext]; 6.f 函数执行上下文初始化, 以下跟第 4 步相同： 复制函数 [[scope]] 属性创建作用域链用 arguments 创建活动对象初始化活动对象，即加入形参、函数声明、变量声明将活动对象压入 f 作用域链顶端123456789fContext = { AO: { arguments: { length: 0 } }, Scope: [AO, checkscopeContext.AO, globalContext.VO], this: undefined} 7.f 函数执行，沿着作用域链查找 scope 值，返回 scope 值 8.f 函数执行完毕，f 函数上下文从执行上下文栈中弹出1234ECStack = [ checkscopeContext, globalContext]; 9.checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出123ECStack = [ globalContext]; 第二段代码就留给大家去尝试模拟它的执行过程。123456789var scope = &quot;global scope&quot;;function checkscope(){ var scope = &quot;local scope&quot;; function f(){ return scope; } return f;}checkscope()(); 不过，在下一篇《JavaScript深入之闭包》中也会提及这段代码的执行过程。","link":"/2016/08/25/javaScript/context/"},{"title":"获取鼠标的位置","text":"获取鼠标的位置获取鼠标的位置可以分为多个情况 获取鼠标相对于浏览器窗口的位置 12let x = event.clientX;let y = event.clientY; 获取鼠标相对于整个页面的位置 12let x = event.pageX;let y = event.pageY; 获取鼠标相对点击元素的位置 这一个获取有点难度，因为在JavaScript原生方法中没有这个方法，那么需要分析如何获取，突破点一获取点击元素的相对其父本元素的偏移量这个属性在event的target属性下边绑定可以循环的方法获取点击元素相对于页面的位置方法如下 123456789101112131415161718 /* *该方法是获取点击元素相对于页面的距离 *传入的参数为event.target */ function getOffset(obj){ var tmp={ val:obj.offsetParent, //获取点击元素的父本 x:obj.offsetLeft, //获取点击元素的相对于父本的水平偏移 y:obj.offsetTop, //获取点击元素的相对于父本的垂直偏移 } while(tmp.val != null){ //当父级不存在是停止循环 tmp.x += tmp.val.offsetLeft; //水平偏移量累计 tmp.y += tmp.val.offsetTop; //垂直偏移量累计 tmp.val = tmp.val.offsetParent; //获取父本 } return tmp; //返回点击元素相对于页面的偏移值} 以上函数是获取了点击元素相对于页面的水平和垂直偏移，依赖以上获得的值，只需要鼠标相对于页面的偏移减去点击元素相对于页面的偏移方法如下： 123456789101112/**该方法是获取鼠标相对于点击元素的位移*传入的参数为event*/function getCurrent(elem){ let off = getOffset(elem.target); //获取元素相对于页面的位置 let tmp = {}; return tmp = { x:elem.pageX - off.x, y:elem.pageY - off.y }} 3.getBoundingClientRect用于获取某个html元素相对于页面的位置集合执行 object.getBoundingClientRect();会得到元素的top、right、bottom、left、width、height属性，这些属性以一个对象的方式返回。 主要是left和bottom要解释一下，left是指右边到页面最左边的距离，bottom是指底边到页面顶边的距离。 (ie5以上都能支持，但是又一点点地方需要修正一下，IE67的left、top会少2px,并且没有width、height属性。) 123456789101112131415161718192021222324&lt;div id=&quot;test&quot; style=&quot;width: 100px; height: 100px; background: #ddd;&quot;&gt;&lt;/div&gt;&lt;script&gt; function getObjXy(obj){ var xy = obj.getBoundingClientRect(); var top = xy.top-document.documentElement.clientTop+document.documentElement.scrollTop,//document.documentElement.clientTop 在IE67中始终为2，其他高级点的浏览器为0 bottom = xy.bottom, left = xy.left-document.documentElement.clientLeft+document.documentElement.scrollLeft,//document.documentElement.clientLeft 在IE67中始终为2，其他高级点的浏览器为0 right = xy.right, width = xy.width||right - left, //IE67不存在width 使用right - left获得 height = xy.height||bottom - top; return { top:top, right:right, bottom:bottom, left:left, width:width, height:height } } var test = getObjXy(document.getElementById(&apos;test&apos;)); alert(&quot;top:&quot; + test.top + &quot;, right:&quot; + test.right + &quot;, bottom:&quot; + test.bottom + &quot;, left:&quot; + test.left);&lt;/script&gt; 以上就是常用的获取鼠标位置的方法","link":"/2016/08/25/javaScript/mouse/"},{"title":"new实现原理","text":"javaScript的new实现原理其实javascript的new关键字只不过做了五件事情。 1.创建Object 2.查找class的prototype上的所有方法、属性，复制一份给创建的Object（注意，如果prototype上有属性是function或者数组或者Object，那么只复制指针） 3.将构造函数classA内部的this指向创建的Object 4.创建的Object的proto指向class的prototype 5.执行构造函数class 12345678910111213141516171819202122// 定义类 类名字是 classA function classA(){ this.b=1; } classA.prototype.b=44; classA.prototype.show = function(){ alert(this.b); }; // 用new实例化 var b = new classA(); b.show(); // 用函数实例化 function newClass(cls,args){ var obj = {}; for(var p in cls.prototype) obj[p] = cls.prototype[p]; obj.__proto__ = cls.prototype; cls.apply(obj,args||[]); return obj; }; var k = newClass(classA); k.show();","link":"/2016/08/25/javaScript/new/"},{"title":"forEach实现原理","text":"javaScript的forEach实现原理12345678910111213141516171819202122232425262728293031323334353637383940414243function forEach(object, block, context, fn) { if(object == null) return; if(!fn) { if(typeof object == &quot;function&quot; &amp;&amp; object.call) { //遍历普通对象 fn = Function; } else if(typeof object.forEach == &quot;function&quot; &amp;&amp; object.forEach != arguments.callee) { //如果目标已经实现了forEach方法，则使用它自己的forEach方法（如标准游览器的Array对象） object.forEach(block, context); return; } else if(typeof object.length == &quot;number&quot;) { // 如果是类数组对象或IE的数组对象 _Array_forEach(object, block, context); return; } } _Function_forEach(fn || Object, object, block, context);};function _Array_forEach(array, block, context) { if(array == null) return; var i = 0, length = array.length; if(typeof array == &quot;string&quot;) { for(; i &lt; length; i++) { block.call(context, array.charAt(i), i, array); } } else { for(; i &lt; length; i++) { block.call(context, array[i], i, array); } }};_Function_forEach = function(fn, object, block, context) { // 这里的fn恒为Function for(var key in object) { //只遍历本地属性 if(object.hasOwnProperty(key)) { //相当于 block(object[key], key) block.call(context, object[key], key, object); } }};","link":"/2016/08/25/javaScript/foreach/"},{"title":"promise原理解析","text":"promise原理解析promise模式这几种方式的可维护性逐级递增，理解难度也逐级递增。这篇总结也是针对promise模式的。 promise模式那么多中异步编程的方式，为什么选择promise, 因为前面几种方式不够灵活，用起来不够痛快，不优雅。为了降低异步编程的复杂性，所以promise。 promise的核心是有一个promise对象，这个对象有一个重要的then()方法, 它用于指定回调函数，如：f1().then(f2); promise模式在任何时刻都有三种状态：已完成（resolved），未完成（unfulfilled），那么then()方法就是为状态变化指定不同的回调函数，并总是返回一个promise对象，方便链式调用。 那promise模式下，返回的数据如何在各个回调函数之间传播呢，通过resolve方法，你可以将一个函数的返回值作为参数传递给另一个函数，并且将另一个函数的返回值作为参数再传递给下一个函数……像一条“链”一样无限的这么做下去。 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//constructorvar promise = function() { this.callbacks = [];}promise.prototype = { construct: promise, //成功的操作 resolve: function(result) { this.complete(&apos;resolve&apos;, result); }, //失败 reject: function(result) { this.complete(&quot;reject&quot;, result); }, //执行回调 complete: function(type, result) { while(this.callbacks[0]) { this.callbacks.shift()[type](result); } }, then: function(successHandler, failedHandler) { this.callbacks.push({ resolve: successHandler, reject: failedHandler }); return this; }}//运行下边是方法的调用var pro = new promise();var delay1 = function() { setTimeout(function() { pro.resolve(&apos;数据1&apos;); }, 1000); return pro;};var callback1 = function(re) { re = re + &apos;数据2&apos;; console.log(re);};delay1().then(callback1)console.log(&quot;我是最后吗&quot;); /* *以上方法输出的结果分别是 *我是最后吗 *数据1 *数据2 */ #####代码分析我们可看到一个简单的promise对象的构造函数的结构： callbacks: 用于管理回调函数 resolve: 请求成功时执行的方法 reject:请求失败时执行的方法 complete: 执行回调 then：绑定回调函数 第一步1234567var delay1 = function() { setTimeout(function() { promise.resolve(‘数据1’); }, 1000); return promise;};//这个函数通过setTimeout方法， 异步传递一个数据1， 并返回一个promise对象(必须)。 #####第二步123456var callback1 = function(re) { re = re + &apos;数据2&apos;; console.log(re); promise.resolve(re);};//callback1和callback2都是要通过then方法注册的回调函数， 其中callback1通过resolve方法把数据往下传递。 第三步12delay1().then(callback1).then(callback2);//delay1() 方法执行完， 因为返回了一个promise对象， 所以可以再调用then() 方法为delay1() 的setTimeout异步执行操作指定回调函数, 又因为then() 方法也返回的是promise对象， 所以还可以再调用then方法 第四步12345setTimeout(function() { promise.resolve(&apos;数据1&apos;);}, 1000);//一秒之后， 当其他代码执行完成， 开始执行异步代码promise.resolve(‘数据1’);，//这里调用promise的resolve() 方法， 指定了一个成功状态， 并把数据1作为参数。 第五步123resolve: function(result) { this.complete(&quot;resolve&quot;, result);}, 第六步：循环执行回调，将上一个回调的结果传递给下一个回调12345complete: function(type, result) { while(this.callbacks[0]) { this.callbacks.shift()[type](result); }},","link":"/2016/08/25/javaScript/promise/"},{"title":"正则表达式 - 语法","text":"正则表达式 - 语法正则表达式 - 语法","link":"/2016/08/25/javaScript/regular-expression/"},{"title":"Number深入解析","text":"Number深入解析Number简介 javaScript不区分整数值和浮点数值。javaScript中所有的数字均用浮点数值表示。javaScript应用的是IEEE754标准定义64位浮点格式表示的数字。它表示的最大值是+/-1.797693134862315710308,最小值是+/-5 10-324。javaScript能够表示的正数范围是-253~253,包含界限。如果使用了超出此范围的整数，则无法保证低位数字的精度。还需要注意的是javaScript中实际的操作（比如数组索引）则是基于32位整数。在javaScript中直接出现的数值称之为数字直接量（numneric lieral）。 整型直接量javaScript中识别十进制整数以及八进制（严格模式中是禁止使用八进制的）和十六进制 浮点型直接量浮点型直接量可以包含有小数点。下面是浮点型的书写方案：12345673.14033.56.7776.7e336.7E336.7e-336.7e3.3 //会报错 Uncaught SyntaxError: Unexpected number 书写语法表示为：[digits][.digits][(E|e)[+|-]digits] 算数运算算数运算的运算符有：加法运算符（+）、减法运算符（-）、乘法运算符（*）、除法运算符（/）、求余运算符（%）。以及Math的属性和方法。 Math对象的属性： 属性 描述 E 返回算术常量 e，即自然对数的底数（约等于2.718）。 LN2 返回 2 的自然对数（约等于0.693）。 LN10 返回 10 的自然对数（约等于2.302）。 LOG2E 返回以 2 为底的 e 的对数（约等于 1.414）。 PI 返回圆周率（约等于3.14159）。 LOG10E 返回以 10 为底的 e 的对数（约等于0.434）。 SQRT1_2 返回返回 2 的平方根的倒数（约等于 0.707）。 SQRT2 返回 2 的平方根（约等于 1.414）。 Math 对象方法 属性 描述 abs(x) 返回数的绝对值。 acos(x) 返回数的反余弦值。 asin(x) 返回数的反正弦值。 atan(x) 以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值。 atan2(y,x) 返回从 x 轴到点 (x,y) 的角度（介于 -PI/2 与 PI/2 弧度之间）。 ceil(x) 对数进行上舍入。 cos(x) 返回数的余弦 exp(x) 返回 e 的指数 floor(x) 对数进行下舍入 log(x) 返回数的自然对数（底为e） max(x,y) 返回 x 和 y 中的最高值 min(x,y) 返回 x 和 y 中的最低值 pow(x,y) 返回 x 的 y 次幂 random() 返回 0 ~ 1 之间的随机数 round(x) 把数四舍五入为最接近的整数 sin(x) 返回数的正弦。 sqrt(x) 返回数的平方根 tan(x) 返回角的正切 toSource() 返回该对象的源代码 valueOf() 返回 Math 对象的原始值 Infinity与NAN在JavaScript的算术运算在溢出(overflow)、下益(underflow)或被零整除时不会报错。溢出当数字超出数字的上限结果用Infinity表示超出下线用-Infinity表示。关于无穷大的行为特性为：基于它们的加、减、乘、除运算的结果还是无穷大。下益当运算结果无限接近零并比JavaScript能表示的最小值还小的时候发生的一种情形。这种情况下JavaScript将会返回0，当负数发生下益时，JavaScript会返回一个特殊的值“负零”。 寄语：生活想让我们缴械，但是从这一刻起我们要做的是反击 。:)","link":"/2016/08/25/javaScript/number/"},{"title":"原型到原型链","text":"原型到原型链构造函数创建对象我们先使用构造函数创建一个对象：123456function Person() {}var person = new Person();person.name = &apos;Kevin&apos;;console.log(person.name) // Kevin 在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。 很简单吧，接下来进入正题： prototype 每个函数都有一个 prototype 属性，就是我们经常在各种例子中看到的那个 prototype ，比如： 12345678910function Person() {}// 虽然写在注释里，但是你要注意：// prototype是函数才会有的属性Person.prototype.name = &apos;Kevin&apos;;var person1 = new Person();var person2 = new Person();console.log(person1.name) // Kevinconsole.log(person2.name) // Kevin 那这个函数的 prototype 属性到底指向的是什么呢？是这个函数的原型吗？ 其实，函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是这个例子中的 person1 和 person2 的原型。 那什么是原型呢？你可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。 让我们用一张图表示构造函数和实例原型之间的关系： 在这张图中我们用 Object.prototype 表示实例原型。 那么我们该怎么表示实例与实例原型，也就是 person 和 Person.prototype 之间的关系呢，这时候我们就要讲到第二个属性： proto 这是每一个JavaScript对象(除了 null )都具有的一个属性，叫proto，这个属性会指向该对象的原型。 为了证明这一点,我们可以在火狐或者谷歌中输入：12345function Person() {}var person = new Person();console.log(person.__proto__ === Person.prototype); // true 于是我们更新下关系图： 既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？ constructor 指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：constructor ，每个原型都有一个 constructor 属性指向关联的构造函数。 为了验证这一点，我们可以尝试：1234function Person() {}console.log(Person === Person.prototype.constructor); // true 所以再更新下关系图： 综上我们已经得出：12345678910function Person() {}var person = new Person();console.log(person.__proto__ == Person.prototype) // trueconsole.log(Person.prototype.constructor == Person) // true// 顺便学习一个ES5的方法,可以获得对象的原型console.log(Object.getPrototypeOf(person) === Person.prototype) // true 了解了构造函数、实例原型、和实例之间的关系，接下来我们讲讲实例和原型的关系： 实例与原型当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。 举个例子：12345678910111213141516function Person() {}Person.prototype.name = &apos;Kevin&apos;;var person = new Person();person.name = &apos;Daisy&apos;;console.log(person.name) // Daisydelete person.name;console.log(person.name) // Kevin在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.__proto__ ，也就是 Person.prototype中查找，幸运的是我们找到了 name 属性，结果为 Kevin。 但是万一还没有找到呢？原型的原型又是什么呢？ 原型的原型在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：123var obj = new Object();obj.name = &apos;Kevin&apos;console.log(obj.name) // Kevin 所以原型对象是通过 Object 构造函数生成的，结合之前所讲，实例的 proto 指向构造函数的 prototype ，所以我们再更新下关系图： 原型链那 Object.prototype 的原型呢？ null，不信我们可以打印：1console.log(Object.prototype.__proto__ === null) // true 所以查到属性的时候查到 Object.prototype 就可以停止查找了。 所以最后一张关系图就是 顺便还要说一下，图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。 补充最后，补充三点大家可能不会注意的地方： constructor 首先是 constructor 属性，我们看个例子：12345function Person() {}var person = new Person();console.log(person.constructor === Person); // true 当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：1person.constructor === Person.prototype.constructor proto 其次是 proto ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.proto 时，可以理解成返回了1Object.getPrototypeOf(obj)。 真的是继承吗？最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是： 继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。","link":"/2016/08/25/javaScript/prototype/"},{"title":"滚到底部加载","text":"滚到底部加载其实这个功能的实现就是监听滚动条是否滚动到底部，如果滚动到底部则向后后台获取数据废话不多说上代码浏览器视口的高度123456789getWindowHeight = () =&gt; { var windowHeight = 0; if(document.compatMode == &quot;CSS1Compat&quot;){ windowHeight = document.documentElement.clientHeight; }else{ windowHeight = document.body.clientHeight; } return windowHeight;} 文档的总高度1234567891011getScrollHeight = () =&gt; { var scrollHeight = 0, bodyScrollHeight = 0, documentScrollHeight = 0; if(document.body){ bodyScrollHeight = document.body.scrollHeight; } if(document.documentElement){ documentScrollHeight = document.documentElement.scrollHeight; } scrollHeight = (bodyScrollHeight - documentScrollHeight &gt; 0) ? bodyScrollHeight : documentScrollHeight; return scrollHeight;} 滚动条在Y轴上的滚动距离1234567891011getScrollTop = () =&gt; { var scrollTop = 0, bodyScrollTop = 0, documentScrollTop = 0; if(document.body){ bodyScrollTop = document.body.scrollTop; } if(document.documentElement){ documentScrollTop = document.documentElement.scrollTop; } scrollTop = (bodyScrollTop - documentScrollTop &gt; 0) ? bodyScrollTop : documentScrollTop; return scrollTop;} 那么剩下的就是在js里边进行判断这里主要说在react里的用法这里把所有的操作写在一个方法里12345onScrollListener = () =&gt;{ if(getScrollTop() + getWindowHeight() == getScrollHeight()){ alert(&quot;滚动条已经滚动到了底部&quot;); }} 在react的componentDidMount生命周期里写一下代码1234componentDidMount(){ //滚轮监听 addEventListener(&quot;scroll&quot;,this.onscrollListener,false) } 在react的componentWillUnmount生命周期里写一下代码(注册事件要在组件销毁以后注销这样可以提高性能) 123componentWillUnmount(){ window.removeEventListener(&quot;scroll&quot;,this.onscrollListener)}","link":"/2016/08/25/javaScript/to-bottom/"},{"title":"js异常处理机制详解","text":"js异常处理机制详解 ​ 从ES3开始，js也提供了类似的异常处理机制，从而让js代码变的更健壮，及时执行的过程中出现了异常，也可以让程序具有了一部分的异常恢复能力。 一、Javascript的异常捕获机制1.1 基本的try…catch语句ES3开始引入了 try-catch 语句，是 JavaScript 中处理异常的标准方式。 语法：try{ 可能发生异常的代码 }catch(error){ 发生错误执行的代码 } 看下面的代码： 12345678910&lt;script&gt; try{ console.log(b); console.log(&quot;我不会输出的，不要找了&quot;) }catch(error){ console.log(&quot;发生错误了&quot;) } console.log(&quot;我try catch后面的代码&quot;)&lt;/script&gt; 说明： 把有可能出的问题的代码放在 try语句中。try语句中可以理论上可以写任何的代码，只要有一行代码出现问题，整个程序的执行流程就会立即调到catch语句中执行。 一旦try中有一行代码发生异常，则这行出错代码的后面的try中的其他语句都不会再执行。比如上面代码中的console.log(b);这行代码会出错，则立即去执行catch中的代码。所以console.log(“我不会输出的，不要找了”)这行代码则不会再执行 在执行catch中的代码之前，js引擎会首先根据错误类型自动创建一个错误，并通过catch后面的参数传递到catch中。不同的浏览器创建的error对象不一样，但是同创他们都包含一个message属性，值是这个错误的一些信息。 catch中的代码执行完毕之后，会继续执行后面的代码，程序不会停止下来。 1.2 finally语句在 try…catch 中，try 中一旦出现错误则其他语句不能执行，如果不出现错误则 catch 中的语句不会执行。 Javascript 参考其他编程语言，也提供了一种 finally 语句：不管 try 中的语句有没有错误，在最后都会执行 finally 中的语句。 即：try 中语句不发生错误执行完毕后会执行 finally 中的语句，try 中的语句发生错误，则执行 catch中的语句，catch 中的语句执行完毕后也会执行 finally 中的语句。 语法： try{ }catch(error){ }finally{ } 123456789101112&lt;script&gt; try{ console.log(b); console.log(&quot;我不会输出的，不要找了&quot;) }catch(error){ console.log(&quot;发生错误了&quot;) }finally { console.log(&quot;不管发生不发生错误，我都会执行&quot;) } console.log(&quot;我try catch后面的代码&quot;)&lt;/script&gt; 所以在 finally 中我们可以放置我们必须要执行的代码。 注意： 在js中，如果添加了 finally 语句，则 catch 语句可以省略。所以下面的代码也是正确的。 如果没有 catch 语句，则一旦发生错误就无法捕获这个错误，所以在执行完 finally 中的语句后，程序就会立即停止了。 所以，在实际使用中，最好一直带着 catch 语句。 12345678910&lt;script&gt; try{ console.log(b); console.log(&quot;我不会输出的，不要找了&quot;) }finally { console.log(&quot;不管发生不发生错误，我都会执行&quot;) } console.log(&quot;我try catch后面的代码&quot;)&lt;/script&gt; 1.3 合理使用try…catch当 try-catch 语句中发生错误时，浏览器会认为错误已经被处理了，浏览器就不再报告错误了。这也是最简单的一种情况。 ​ 使用 try-catch 最适合处理那些我们无法控制的错误。假设你在使用一个大型 JavaScript 库中的 函数，该函数可能会有意无意地抛出一些错误。由于我们不能修改这个库的源代码，所以大可将对该函 数的调用放在 try-catch 语句当中，一有什么错误发生，也好可以恰当地处理它们。 ​ 在明明知道自己的代码会发生错误时，再使用 try-catch 语句就不太合适了。例如，如果 传给函数的参数是字符串而非数值，就会造成函数出错，那么就应该先检查参数的类型，然后再决定 如何去做。在这种情况下，不应用使用 try-catch 语句。因为try…catch语句比较是比较好资源的事情。 二、throw主动抛出异常2.1 抛出js内置错误类型的对象 在大部分的代码执行过程中，都是出现错误的时候，由浏览器(javascript引擎)抛出异常，然后程序或者停止执行，或被try…catch 捕获。 ​ 然而有时候我们在检测到一些不合理的情况发生的时候也可以主动抛出错误。 ​ 使用 throw 关键字抛出来主动抛出异常。 1234&lt;script&gt; throw new Error(&quot;你好坏&quot;); console.log(&quot;执行不到这里的&quot;)&lt;/script&gt; 注意： thow后面就是我们要抛出的异常对象。在以前的时候都是出现错误的时候浏览器抛出异常对象，只是现在是我们自己主动抛出的异常对象。 只要有异常对象抛出，不管是浏览器抛出的，还是代码主动抛出，都会让程序停止执行。如果想让程序继续执行，则有也可以用try…catch来捕获。 每一个错误类型都可以传入一个参数，表示实际的错误信息。 我们可以在适当的时候抛出任何我们想抛出的异常类型。throw new SyntaxError(“语法错误…”); 看下面的代码: 123456789101112&lt;script&gt; /*该函数接收一个数字，返回他的平方。*/ function foo(num) { if(typeof num == &quot;number&quot;){ return num * num; }else{ throw new TypeError(&quot;类型错误，你应该传入一个数字...&quot;) } } console.log(foo(33)) console.log(foo(&quot;abc&quot;))&lt;/script&gt; 2.2 抛出自定义类型的错误对象我们不仅仅可以抛出js内置的错误类型的对象，也可以自定义错误类型，然后抛出自定义错误类型的对象。 ​ 如果要自定义错误类型，只需要继承任何一个自定义错误类型都可以。一般直接继承Error即可。 123456789101112&lt;script&gt; function MyError(message) { this.message = &quot;注意：这是自定义的错误&quot; this.name = &quot;自定义错误&quot;; } MyError.prototype = new Error(); try { throw new MyError(&quot;注意：这是自定义错误类型&quot;) }catch (error){ console.log(error.message) }&lt;/script&gt;","link":"/2019/07/13/javaScript/try-catch/"},{"title":"webSocket","text":"webSocket目录结构如下 WebSocketTestChat.java里的代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.moven.websockets;import java.io.IOException;import java.util.Set;import javax.servlet.http.HttpSession;import javax.websocket.OnClose;import javax.websocket.OnError;import javax.websocket.OnMessage;import javax.websocket.OnOpen;import javax.websocket.Session;import javax.websocket.server.PathParam;import javax.websocket.server.ServerEndpoint;@ServerEndpoint(&quot;/chat/{username}&quot;)public class WebSocketTestChat { Set&lt;Session&gt; session_list = null; @OnMessage public void onMessage(String message, Session session) { try{ session_list = session.getOpenSessions(); HttpSession httpSession = null; String username = &quot;&quot;; if(session instanceof HttpSession){ httpSession = (HttpSession)session; Object param = httpSession.getAttribute(&quot;username&quot;); if(null != param){ username = param.toString(); } } else { username = session.getId(); } for (Session s : session_list) { s.getBasicRemote().sendText(&quot;当前总人数[&quot; + session_list.size() + &quot;]---&quot; + username + &quot;说:&quot; + message); } } catch(IOException e){ System.out.println(&quot;Client error&quot;); } } @OnError public void onError(Throwable t) throws Throwable { System.out.println(&quot;Client error = &quot;+t.getMessage()); } @OnOpen public void onOpen(@PathParam(&quot;username&quot;) String username, Session session) { HttpSession httpSession = null; if(session instanceof HttpSession){ httpSession = (HttpSession)session; httpSession.setAttribute(&quot;username&quot;, username); } System.out.println(&quot;Client connected&quot;); } @OnClose public void onClose() { System.out.println(&quot;Connection closed&quot;); }} chat.html里边的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Testing websockets&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;textarea name=&quot;text&quot; id=&quot;text&quot; rows=&quot;3&quot; cols=&quot;20&quot;&gt;&lt;/textarea&gt; &lt;input type=&quot;submit&quot; value=&quot;send&quot; onclick=&quot;start()&quot; /&gt; &lt;/div&gt; &lt;div id=&quot;messages&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var webSocket = new WebSocket( &apos;ws://local.moven.cn:8081/moven_im/chat/msw/lyh&apos;); webSocket.onerror = function(event) { onError(event) }; webSocket.onopen = function(event) { onOpen(event) }; webSocket.onmessage = function(event) { onMessage(event) }; function onMessage(event) { document.getElementById(&apos;messages&apos;).innerHTML += &apos;&lt;br /&gt;&apos; + event.data; } function onOpen(event) { document.getElementById(&apos;messages&apos;).innerHTML = &apos;Connection established&apos;; } function onError(event) { alert(event.data); } function start() { var text = document.getElementById(&apos;text&apos;).value; if(text){ webSocket.send(text); } else { alert(&quot;Message can&apos;t be null&quot;); } document.getElementById(&apos;text&apos;).value = &apos;&apos;; return false; } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; web.xml里边的代码12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:web=&quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.0&quot;&gt; &lt;display-name&gt;Simple web application&lt;/display-name&gt;&lt;/web-app&gt; pom.xml里边的代码12345678910111213141516171819202122232425262728293031323334&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.moven&lt;/groupId&gt; &lt;artifactId&gt;moven_im&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.7&lt;/source&gt; &lt;target&gt;1.7&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;version&gt;7.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;","link":"/2016/08/25/javaScript/web-socket/"},{"title":"你不知道的js（上）","text":"你不知道的js（上）LHS与RHS LHS可以理解为某变量被赋值，RHS可以理解为被调用 举个栗子1234function foo(a){ console.log(a); //2}foo(2) foo进行RHS foo的形参相当于a=2 所以a进行LHS console是RHS console里的a是RHS 理解作用于作用于嵌套 现在当前作用于找某变量，找不到时引擎会向外层嵌套的作用于中继续寻找，直到找到该变量，或抵达最外层的作用域（也就是全局作用于）为止。 注意一下代码12345function foo (a){ console.log(a + b); //4}var b = 2;foo(2); 123456function foo (a){ console.log(a + b); //NaN}foo(2);var b = 2; 12345function foo (a){ console.log(a + b); //NaN var b = 2}foo(2); 12345function foo (a){ console.log(a + b); //ReferenceError: b is not defined b = 2}foo(2);","link":"/2016/08/25/javaScript/you-dont-know-js/"},{"title":"thinkjs项目目录解析","text":"thinkjs项目目录解析目录 注：指定不同的模式创建的项目目录机构可能有细微的差别，但总体是类似的 nginx.confnginx 的配置文件，建议线上使用 nginx 做反向代理。 src源代码目录，使用 –es6 参数创建项目才有该目录。项目启动时会自动将 src 目录下的文件编译到 app 目录下。 如果没有使用 ES6 特性创建项目，则直接有 app/ 目录。 src/common通用模块目录，项目目录都是按模块来划分的，common 模块下存放一些通用的处理逻辑。 src/common/bootstrap项目启动目录，该目录下的文件会自动加载，无需手动 require 。 可以在这个目录下文件里定义一些全局函数、注册中间件等常用的功能。 定义全局函数123// src/common/bootstrap/fn.js global.formatDate = obj =&gt; { ...} 这里定义了一个全局函数 formatDate，那么项目里任何地方都可以直接使用该函数。 注册中间件123// src/common/bootstrap/middleware.js think.middleware(&quot;replace_image&quot;, http =&gt; { ...}); 这里定义了一个中间件 replace_image，那么就可以在配置文件 hook.js 里将该中间件注册进去了。 注：bootstrap 只能放在 common 模块里。 src/common/config配置文件，这里放一些通用的配置。 其中：路由配置、hook 配置、本地化配置等必须放在这里。123&quot;use strict&quot;; /** * config */ export default { //key: value }; src/common/controller控制器，放一些通用的控制器。其中 error.js 里错误处理的不同行为，项目里可以根据需要进行修改。 src/common/runtime项目运行时生成的一些目录，如：缓存文件目录，用户上传的文件临时存放的目录。 src/homehome 模块，项目默认模块。可以在 src/common/config/config.js 中修改配置 default_module 来重新定义默认模块。 src/home/logic逻辑处理。每个操作执行前可以先进行逻辑校验，可以包含：参数是否合法、提交的数据是否正常、当前用户是否已经登录、当前用户是否有权限等。这样可以降低 controller 里的 action 的复杂度。1234567891011&quot;use strict&quot;; /** * logic * @param {} [] * @return {} [] */ export default class extends think.logic.base { /** * index action logic * @return {} [] */ indexAction(){ }} src/home/controller控制器。一个 url 对应一个 controller 下的 action。123456&quot;use strict&quot;; import Base from &quot;./base.js&quot;; export default class extends Base { /** * index action * @return {Promise} [] */ indexAction(){ //auto render template file index_index.html return this.display(); }} src/home/model模型。数据库相关操作。 view视图目录，存放对应的模版文件。如果支持国际化和多主题，那么视图目录下需要有对应的子目录。 www项目的可访问根目录，nginx 里的根目录会配置到此目录下。 www/development.js开发模式下项目的入口文件，可以根据项目需要进行修改。www/production.js 为线上的入口文件。 入口文件的代码类似如下，可以根据项目需要进行修改。123456789var thinkjs = require(&quot;thinkjs&quot;); var path = require(&quot;path&quot;); var rootPath = path.dirname(__dirname); var instance = new thinkjs({ APP_PATH: rootPath + &quot;/app&quot;, ROOT_PATH: rootPath, RESOURCE_PATH: __dirname, env: &quot;development&quot; });instance.compile({retainLines: true, log: true});instance.run(); www/static存放一些静态资源文件。","link":"/2019/07/13/node/application/"},{"title":"node异常处理机制详解","text":"node异常处理机制详解 assert() assert.ok() assert.equal() assert.notEqual() assert.deepEqual() assert.notDeepEqual() assert.strictEqual() assert.notStrictEqual() assert.throws() assert.ifError() assert.fail() assert模块是Node的内置模块，主要用于断言。如果表达式不符合预期，就抛出一个错误。该模块提供11个方法，但只有少数几个是常用的。 1. assert()assert方法接受两个参数，当第一个参数对应的布尔值为true时，不会有任何提示，返回undefined。当第一个参数对应的布尔值为false时，会抛出一个错误，该错误的提示信息就是第二个参数设定的字符串。 123456789101112// 格式assert(value, message)// 例子var assert = require(&apos;assert&apos;);function add (a, b) { return a + b;}var expected = add(1,2);assert( expected === 3, &apos;预期1加2等于3&apos;); 上面代码不会有任何输出，因为assert方法的第一个参数是true。 12assert( expected === 4, &apos;预期1加2等于3&apos;)// AssertionError: 预期1加2等于3 上面代码会抛出一个错误，因为assert方法的第一个参数是false。 2. assert.ok()ok是assert方法的另一个名字，与assert方法完全一样。 3. assert.equal()equal方法接受三个参数，第一个参数是实际值，第二个是预期值，第三个是错误的提示信息。 1234567891011121314151617181920// 格式assert.equal(actual, expected, [message])assert.equal(true, value, message);// 等同于assert(value, message);// 例子var assert = require(&apos;assert&apos;);function add (a, b) { return a + b;}var expected = add(1,2);// 以下三句效果相同assert(expected == 3, &apos;预期1+2等于3&apos;);assert.ok(expected == 3, &apos;预期1+2等于3&apos;);assert.equal(expected, 3, &apos;预期1+2等于3&apos;); equal方法内部使用的是相等运算符（==），而不是严格运算符（===），进行比较运算。 4. assert.notEqual()notEqual方法的用法与equal方法类似，但只有在实际值等于预期值时，才会抛出错误。 12345678910111213141516// 格式assert.notEqual(actual, expected, [message])// 用法var assert = require(&apos;assert&apos;);function add (a, b) { return a + b;}var expected = add(1,2);// 以下三种写法效果相同assert(expected != 4, &apos;预期不等于4&apos;);assert.ok(expected != 4, &apos;预期不等于4&apos;);assert.notEqual(expected, 4, &apos;预期不等于4&apos;); notEqual方法内部使用不相等运算符（!=），而不是严格不相等运算符（!==），进行比较运算。 5. assert.deepEqual()deepEqual方法用来比较两个对象。只要它们的属性一一对应，且值都相等，就认为两个对象相等，否则抛出一个错误。 123456789101112131415// 格式assert.deepEqual(actual, expected, [message])// 例子var assert = require(&apos;assert&apos;);var list1 = [1, 2, 3, 4, 5];var list2 = [1, 2, 3, 4, 5];assert.deepEqual(list1, list2, &apos;预期两个数组应该有相同的属性&apos;);var person1 = { &quot;name&quot;:&quot;john&quot;, &quot;age&quot;:&quot;21&quot; };var person2 = { &quot;name&quot;:&quot;john&quot;, &quot;age&quot;:&quot;21&quot; };assert.deepEqual(person1, person2, &apos;预期两个对象应该有相同的属性&apos;); 6. assert.notDeepEqual()notDeepEqual方法与deepEqual方法正好相反，用来断言两个对象是否不相等。 12345678910111213141516// 格式assert.notDeepEqual(actual, expected, [message])// 例子var assert = require(&apos;assert&apos;);var list1 = [1, 2, ,3, 4, 5];var list2 = [1, 2, 3, 4, 5];assert.notDeepEqual(list1, list2, &apos;预期两个对象不相等&apos;);var person1 = { &quot;name&quot;:&quot;john&quot;, &quot;age&quot;:&quot;21&quot; };var person2 = { &quot;name&quot;:&quot;jane&quot;, &quot;age&quot;:&quot;19&quot; };// deepEqual checks the elements in the objects are identicalassert.notDeepEqual(person1, person2, &apos;预期两个对象不相等&apos;); 7. assert.strictEqual()strictEqual方法使用严格相等运算符（===），比较两个表达式。 12345678// 格式assert.strictEqual(actual, expected, [message])// 例子var assert = require(&apos;assert&apos;);assert.strictEqual(1, &apos;1&apos;, &apos;预期严格相等&apos;);// AssertionError: 预期严格相等 8. assert.notStrictEqual()assert.notStrictEqual方法使用严格不相等运算符（!==），比较两个表达式。 1234567// 格式assert.notStrictEqual(actual, expected, [message])// 例子var assert = require(&apos;assert&apos;);assert.notStrictEqual(1, true, &apos;预期严格不相等&apos;); 9. assert.throws()throws方法预期某个代码块会抛出一个错误，且抛出的错误符合指定的条件。 123456789101112131415161718192021222324252627282930313233// 格式assert.throws(block, [error], [message])// 例一，抛出的错误符合某个构造函数assert.throws( function() { throw new Error(&quot;Wrong value&quot;); }, Error, &apos;不符合预期的错误类型&apos;);// 例二、抛出错误的提示信息符合正则表达式assert.throws( function() { throw new Error(&quot;Wrong value&quot;); }, /value/, &apos;不符合预期的错误类型&apos;);// 例三、抛出的错误符合自定义函数的校验assert.throws( function() { throw new Error(&quot;Wrong value&quot;); }, function(err) { if ( (err instanceof Error) &amp;&amp; /value/.test(err) ) { return true; } }, &apos;不符合预期的错误类型&apos;); 10. assert.doesNotThrow()doesNotThrow方法与throws方法正好相反，预期某个代码块不抛出错误。 12345678910// 格式assert.doesNotThrow(block, [message])// 用法assert.doesNotThrow( function() { console.log(&quot;Nothing to see here&quot;); }, &apos;预期不抛出错误&apos;); 11. assert.ifError()ifError方法断言某个表达式是否false，如果该表达式对应的布尔值等于true，就抛出一个错误。它对于验证回调函数的第一个参数十分有用，如果该参数为true，就表示有错误。 123456789101112131415// 格式assert.ifError(value)// 用法function sayHello(name, callback) { var error = false; var str = &quot;Hello &quot;+name; callback(error, str);}// use the functionsayHello(&apos;World&apos;, function(err, value){ assert.ifError(err); // ...}) 12. assert.fail()fail方法用于抛出一个错误。 123456789101112// 格式assert.fail(actual, expected, message, operator)// 例子var assert = require(&apos;assert&apos;);assert.fail(21, 42, &apos;Test Failed&apos;, &apos;###&apos;)// AssertionError: Test Failedassert.fail(21, 21, &apos;Test Failed&apos;, &apos;###&apos;)// AssertionError: Test Failedassert.fail(21, 42, undefined, &apos;###&apos;)// AssertionError: 21 ### 42 该方法共有四个参数，但是不管参数是什么值，它总是抛出一个错误。如果message参数对应的布尔值不为false，抛出的错误信息就是message，否则错误信息就是“实际值 + 分隔符 + 预期值”。","link":"/2019/07/13/node/try-catch/"},{"title":"颜色转换","text":"常用的颜色模式 目前常用的颜色模式有 RGB，HSV，HLS，CMYK，这几种颜色分别在不同的领域使用，也有特定的应用场景。 RGB RGB色彩模式是工业界的一种颜色标准，是通过对红(R)、绿(G)、蓝(B)三个颜色通道的变化以及它们相互之间的叠加来得到各式各样的颜色的，RGB即是代表红、绿、蓝三个通道的颜色，这个标准几乎包括了人类视力所能感知的所有颜色，是目前运用最广的颜色系统之一。 HSV/HSL HSV(Hue, Saturation, Value)是根据颜色的直观特性由A. R. Smith在1978年创建的一种颜色空间, 也称六角锥体模型(Hexcone Model)。这个模型中颜色的参数分别是：色调（H），饱和度（S），明度（V）。HSL色彩模式是工业界的一种颜色标准，是通过对色相(H)、饱和度(S)、亮度(L)三个颜色通道的变化以及它们相互之间的叠加来得到各式各样的颜色的，HSL即是代表色相，饱和度，亮度三个通道的颜色，这个标准几乎包括了人类视力所能感知的所有颜色，是迄今运用最广的颜色系统之一。 颜色的互相转换颜色选择器的实现思路常用算法参考文章深入理解color model(颜色模型)","link":"/2019/07/12/knowledge/color/"},{"title":"nuxt服务端项目集成引入iView","text":"Nuxt.js 是什么？Nuxt.js 是一个基于 Vue.js 的通用应用框架。 通过对客户端/服务端基础架构的抽象组织，Nuxt.js 主要关注的是应用的 UI渲染。 我们的目标是创建一个灵活的应用框架，你可以基于它初始化新项目的基础结构代码，或者在已有 Node.js 项目中使用 Nuxt.js。 Nuxt.js 预设了利用Vue.js开发服务端渲染的应用所需要的各种配置。 除此之外，我们还提供了一种命令叫：nuxt generate，为基于 Vue.js 的应用提供生成对应的静态站点的功能。 我们相信这个命令所提供的功能，是向开发集成各种微服务（microservices）的 Web 应用迈开的新一步。 作为框架，Nuxt.js 为 客户端/服务端 这种典型的应用架构模式提供了许多有用的特性，例如异步数据加载、中间件支持、布局支持等。 Nuxt 项目–构建因为Nuxt是基于vue的通用应用框架所以构建Nuxt项目可以同vue-cil来构建 1. 安装vue-cil相信有vue使用经验的开发者对这款cil工具是非常熟悉的 1npm install --global vue-cli 2. 用vue-cil搭建项目12345$ vue init nuxt-community/starter-template nuxt //(你要构建的项目名称我的项目叫做nuxt)$ cd nuxt$ npm install 3. 接着通过以下命令启动项目1$ npm run dev 访问 http://localhost:3000 集成 iview UI框架12// 安装 iview$ npm install iview --save 在根目录的 plugins 中新建 iview.js12import iView from &apos;iview&apos;Vue.use(iView) 这里有个大坑因为Nuxt语法检测机制在Vue.use(iView)的后面要加一个回车要不会报一下错误，这个问题当时让我很郁闷 修改 nuxt.config.js在module.exports最后添加如下内容：12plugins: [ { src: &apos;~plugins/iview&apos;, ssr: false } ],css: [&apos;iview/dist/styles/iview.css&apos;], 在pages/index.vue,加入 Button 标签1&lt;Button type=&quot;primary&quot;&gt;Primary&lt;/Button&gt; 再次启动页面1$ npm run dev 效果页面如下： 大功告成 后续会添加nuxt的相关内容","link":"/2019/07/13/nuxt/init/"},{"title":"chrome扩展开发","text":"在平时的前端开发中chrome的扩展应用是非常常见的我平常应用的chrome扩展程序用Postman、React Developer Tools、Redux DevTools 等使用了这么长时间了扩展就想开发一款属于自己的chrome扩展，下面来介绍一下一个简单的扩展开发。 chrome扩展与chrome应用的区别Chrome应用更强调是独立的程序，你可以不打开Chrome浏览器而运行这些程序。同时这些程序可以调用更加底层的系统接口，比如串口、USB、本地文件读写等等。同时Chrome应用可以拥有样式更加自由的独立窗口，而Chrome扩展的界面只能限定在浏览器窗口中。 Chrome扩展是一系列文件的集合，这些文件包括HTML文件、CSS样式文件、JavaScript脚本文件、图片等静态文件以及manifest.json。个别扩展还会包含二进制文件，如DLL动态库和so动态库等，但这需要调用NPAPI，而Google出于安全性考虑已经决定逐渐淘汰NPAPI 一个简单的chrome扩展新建文件夹 my_chrome 为项目目录开发目录—— images—— js—— css—— index.html—— manifest.json 项目目录搭建完毕 manifest.json 文件12345678910111213141516171819{ &quot;manifest_version&quot;: 2, &quot;name&quot;: &quot;my_chrome&quot;,//扩展名称 &quot;version&quot;: &quot;1.0&quot;,//版本号 &quot;description&quot;: &quot;我的第一个Chrome扩展&quot;,//项目描述 &quot;icons&quot;: { //icons定义了扩展相关图标文件的位置 &quot;16&quot;: &quot;images/icon.png&quot;, &quot;48&quot;: &quot;images/icon.png&quot;, &quot;128&quot;: &quot;images/icon.png&quot; }, &quot;browser_action&quot;: { &quot;default_icon&quot;: { //定义了相应图标文件的位置 &quot;19&quot;: &quot;images/icon.png&quot;, &quot;38&quot;: &quot;images/icon.png&quot; }, &quot;default_title&quot;: &quot;我的时钟&quot;,//当用户鼠标悬停于扩展图标上所显示的文字 &quot;default_popup&quot;: &quot;index.html&quot; //当用户单击扩展图标时所显示页面的文件位置。 }} html的代码12345678910111213141516171819202122232425&lt;html&gt; &lt;head&gt; &lt;style&gt; * { margin: 0; padding: 0; } body { width: 200px; height: 100px; } div { line-height: 100px; font-size: 42px; text-align: center; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;clock_div&quot;&gt;&lt;/div&gt; &lt;script src=&quot;js/my_clock.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; js 代码12345678910111213function my_clock(el){ var today=new Date(); var h=today.getHours(); var m=today.getMinutes(); var s=today.getSeconds(); m=m&gt;=10?m:(&apos;0&apos;+m); s=s&gt;=10?s:(&apos;0&apos;+s); el.innerHTML = h+&quot;:&quot;+m+&quot;:&quot;+s; setTimeout(function(){my_clock(el)}, 1000);}var clock_div = document.getElementById(&apos;clock_div&apos;);my_clock(clock_div); 扩展导入 到这了一个简单的chrome扩展就完成了","link":"/2019/07/13/other/chrome/"},{"title":"CSS常见布局解决方案","text":"CSS常见布局解决方案水平居中布局 1.margin + 定宽12345678910&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .child { width: 100px; margin: 0 auto; }&lt;/style&gt; 2. table + margin12345678910&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .child { display: table; margin: 0 auto; }&lt;/style&gt; display: table 在表现上类似 block 元素，但是宽度为内容宽。 无需设置父元素样式 （支持 IE 8 及其以上版本）兼容 IE 8 一下版本需要调整为 table 3.inline-block + text-align123456789101112&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .child { display: inline-block; } .parent { text-align: center; }&lt;/style&gt; 兼容性佳（甚至可以兼容 IE 6 和 IE 7）4.absolute + margin-left 123456789101112131415&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt;.parent { position: relative; } .child { position: absolute; left: 50%; width: 100px; margin-left: -50px; /* width/2 */ }&lt;/style&gt; 宽度固定 相比于使用transform ，有兼容性更好 5. absolute + transform1234567891011121314&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent { position: relative; } .child { position: absolute; left: 50%; transform: translateX(-50%); }&lt;/style&gt; 绝对定位脱离文档流，不会对后续元素的布局造成影响。 transform 为 CSS3 属性，有兼容性问题 6. flex + justify-content12345678910&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent { display: flex; justify-content: center; }&lt;/style&gt; 只需设置父节点属性，无需设置子元素 flex有兼容性问题 垂直居中 1.table-cell + vertical-align12345678910&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent { display: table-cell; vertical-align: middle; }&lt;/style&gt; 兼容性好(IE 8以下版本需要调整页面结构至 table 2.absolute + transform1234567891011121314&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent { position: relative; } .child { position: absolute; top: 50%; transform: translateY(-50%); }&lt;/style&gt; 绝对定位脱离文档流，不会对后续元素的布局造成影响。但如果绝对定位元素是唯一的元素则父元素也会失去高度。 transform 为 CSS3 属性，有兼容性问题 3.flex + align-items12345678910&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent { display: flex; align-items: center; }&lt;/style&gt; 水平垂直居中 1. absolute + transform123456789101112131415&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent { position: relative; } .child { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); }&lt;/style&gt; 绝对定位脱离文档流，不会对后续元素的布局造成影响。 transform 为 CSS3 属性，有兼容性问题 2. inline-block + text-align + table-cell + vertical-align1234567891011121314&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent { text-align: center; display: table-cell; vertical-align: middle; } .child { display: inline-block; }&lt;/style&gt; 兼容性好 3. flex + justify-content + align-items1234567891011&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent { display: flex; justify-content: center; /* 水平居中 */ align-items: center; /*垂直居中*/ }&lt;/style&gt; 只需设置父节点属性，无需设置子元素 蛋疼的兼容性问题 一列定宽，一列自适应 1.float + margin1234567891011121314151617181920&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt; .left { float: left; width: 100px; } .right { margin-left: 100px /*间距可再加入 margin-left */ }&lt;/style&gt; IE 6 中会有3像素的 BUG，解决方法可以在 .left 加入 margin-left:-3px 当然也有解决这个小bug的方案如下：123456789101112131415161718192021222324252627&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right-fix&quot;&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt; .left { float: left; width: 100px; } .right-fix { float: right; width: 100%; margin-left: -100px; } .right { margin-left: 100px /*间距可再加入 margin-left */ }&lt;/style&gt; 此方法不会存在 IE 6 中3像素的 BUG，但 .left 不可选择， 需要设置 .left {position: relative} 来提高层级。 注意此方法增加了不必要的 HTML 文本结构。 2.float + overflow12345678910111213141516171819&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt; .left { float: left; width: 100px; } .right { overflow: hidden; }&lt;/style&gt; 设置 overflow: hidden 会触发 BFC 模式（Block Formatting Context）块级格式上下文。BFC是什么呢。用通俗的来讲就是，随便你在BFC 里面干啥，外面都不会受到影响 。此方法样式简单但不支持 IE 6 3.table12345678910111213141516171819202122232425&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent { display: table; width: 100%; table-layout: fixed; } .left { display: table-cell; width: 100px; } .right { display: table-cell; /*宽度为剩余宽度*/ }&lt;/style&gt; table 的显示特性为每列的单元格宽度和一定等与表格宽度。 table-layout: fixed 可加速渲染，也是设定布局优先。table-cell 中不可以设置 margin 但是可以通过 padding 来设置间距 4.flex12345678910111213141516171819202122&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent { display: flex; } .left { width: 100px; margin-left: 20px; } .right { flex: 1; }&lt;/style&gt; 低版本浏览器兼容问题 性能问题，只适合小范围布局 等分布局 1.float12345678910111213141516171819202122232425&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;column&quot;&gt; &lt;p&gt;1&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;column&quot;&gt; &lt;p&gt;2&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;column&quot;&gt; &lt;p&gt;3&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;column&quot;&gt; &lt;p&gt;4&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent { margin-left: -20px; } .column { float: left; width: 25%; padding-left: 20px; box-sizing: border-box; }&lt;/style&gt; 此方法可以完美兼容 IE8 以上版本 2.flex123456789101112131415161718192021222324252627&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;column&quot;&gt; &lt;p&gt;1&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;column&quot;&gt; &lt;p&gt;2&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;column&quot;&gt; &lt;p&gt;3&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;column&quot;&gt; &lt;p&gt;4&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent { display: flex; } .column { flex: 1; } .column+.column { /* 相邻兄弟选择器 */ margin-left: 20px; }&lt;/style&gt; 强大简单，有兼容问题 3.table1234567891011121314151617181920212223242526272829303132&lt;div class=&apos;parent-fix&apos;&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;column&quot;&gt; &lt;p&gt;1&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;column&quot;&gt; &lt;p&gt;2&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;column&quot;&gt; &lt;p&gt;3&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;column&quot;&gt; &lt;p&gt;4&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent-fix { margin-left: -20px; } .parent { display: table; width: 100%; /*可以布局优先，也可以单元格宽度平分在没有设置的情况下*/ table-layout: fixed; } .column { display: table-cell; padding-left: 20px; }&lt;/style&gt; 等高布局 1.table12345678910111213141516171819202122232425&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent { display: table; width: 100%; table-layout: fixed; } .left { display: table-cell; width: 100px; } .right { display: table-cell /*宽度为剩余宽度*/ }&lt;/style&gt; 2.flex12345678910111213141516171819202122&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent { display: flex; } .left { width: 100px; margin-left: 20px; } .right { flex: 1; }&lt;/style&gt; 注意这里实际上使用了 align-items: stretch，flex 默认的 align-items 的值为 stretch 3.float12345678910111213141516171819202122232425262728&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent { overflow: hidden; } .left, .right { padding-bottom: 9999px; margin-bottom: -9999px; } .left { float: left; width: 100px; margin-right: 20px; } .right { overflow: hidden; }&lt;/style&gt; 此方法为伪等高（只有背景显示高度相等），左右真实的高度其实不相等。 兼容性较好。到此，我们了解常见的布局解决方案，这些只是参考，一样的布局实现方式多种多样。主要就使用position、flex 、table（从很久很久以前起，我们就抛弃了table布局页面，但display: table;是异常强大）、float等属性目前flex兼容性较差 傲娇的程序员应该放弃太低版本的浏览器","link":"/2016/08/25/CSS/layout/"},{"title":"github上的协议知识普及","text":"github上的协议知识普及选择一分协议的好处 你的作品如果不是定性为全商业性质，可以考虑选择一分流行度比较高的开源协议。具体来说的话，你肯定希望作品能够被多数人分享查阅吧，不但提高自己业界的知名度，同时也方便了需要的人为开源做出了贡献。换句话说，你不分享出来的话你的作品的意义何在呢（当然，自己捣腾的私人东西还是自己保留吧）？可是一旦你把你的代码贴出来，这就表示任何人都可以看到并获取，之后发生的事情你无法控制，有的人或许稍微修改一下放进自己的代码中，有的把你的软件改个名字拿去贩卖，有的甚至会拿去把作者名字改为自己然后拿去找工作什么的，而不会有人知道这个作品的原作者，背后辛勤付出了的人。所以为了公开分享你的代码，同时又让你对代码保留一定权利，在作品中声明一个许可协议是非常有必要的，这是很多新人所忽略的问题，同时很多人在使用别人的劳动成果时也会忽视协议的存在，这样不好。所以你会看到我的博客里面时不时会给出连接指向来源页面，同时文末也会列出所有参考过的文章。我相信我做到了这点，别人在转载我的文章的时候，也可以做到这点，这样营造出来的氛围一定会非常和谐，互相尊重/Show Respect。 多说一句，一个事实让你了解国外开发者在尊重他人劳动成果方面做得是如何的到位，如果A的作品是因为B的作品的启发而来，A甚至都没有使用B任何一句代码，但A会在他的作品里面指明是受到了B的启发”Inspired by XXX link :http://www.blah.com&quot;。 当然有人会觉得，有了一分协议声明在那里，我就需要鸟你么，我拿来用了把作者名字去掉同时还要加上我的名字，你咬我？！这是后话，只是在利益很小的情况下，或者作者不知情的情况下，作者不会追究什么责任，但如果你的产品做成功了，那就不一定了。另外就是，有协议和没声明协议的裸代码是有非常重要区别的，一般作品当中没声明协议的默认为Copy right的，也就是版权保留。此种情况表明他人没有任何授权，不得复制分发修改使用等等，但一如上面所讨论的，这样的话还何来开源，何来分享呢。有了协议的声明，在未来你的维权上面会方便很多，让你的作品在分享的同时保留了自身的一些权利。 快速选择 目前流行的开源协议有很多，并且同一款协议有很多变种，比如你或许看到过’ CC Attribution-NoDerivs’,’ CC Attribution-NonCommercial’同属CC协议（后面会有介绍）。如此纷繁的协议该如何选择？协议太宽松会导致作者丧失对作品的很多权利，太严格又不便于使用者使用及作品的传播。所以除了协议多之外，你还要考虑你对作品想保留哪些权利，放开哪些限制。 如果你不想了解太多，只是想要一个简直直接的答案，下面给出的建议或许适合你。下方关于协议的选择及表格来自GitHub choosealicence项目。 简单宽松的协议 如果你只想要一个简单点的协议不想太麻烦的话。 MIT协议相对宽松但还是抓住了要点的。此协议允许别人以任何方式使用你的代码同时署名原作者，但原作者不承担代码使用后的风险，当然也没有技术支持的义务。jQuery和Rails就是MIT协议。 代码分享与促进如果你在乎作品的传播和别人的修改，希望别人也以相同的协议分享出来。 GPL（V2或V3）是一种版本自由的协议（可以参照copy right来理解，后者是版本保留，那copyleft便是版权自由，或者无版权，但无版权不代表你可以不遵守软件中声明的协议）。此协议要求代码分发者或者以此代码为基础开发出来的衍生作品需要以同样的协议来发布。此协议的版本3与版本2相近，只是多3中加了条对于不支持修改后代码运行的硬件的限制（没太明白此句话的内涵）。 各协议授权详情 下面是更多开源协议的一个表格任君选择，总有一款是你的菜。不过先来了解一些下方表格中出现的用词的解释：协议和版权信息(License and copyright notice)：在代码中保留作者提供的协议和版权信息声明变更(State Changes)：在代码中声明对原来代码的重大修改及变更公开源码(Disclose Source)：代码必需公开。如果是基于LGPL协议 下，则只需使用的开源代码公开，不必将整个软件源码公开库引用(Library usage)：该库可以用于商业软件中责任承担(Hold Liable)：代码的作者承担代码使用后的风险及产生的后果商标使用(Use Trademark)：可以使用作者的姓名，作品的Logo，或商标附加协议(Sublicensing)：允许在软件分发传播过程中附加上原来没有的协议条款等 协议 描述 要求 允许 禁止 Apache 一个较宽松且简明地指出了专利授权的协议。 ○协议和版权信息 ○声明变更 ○商用○分发○修改○专利授权○私用○附加协议 ○责任承担（禁止让作者承担责任，可以理解为免责○商标使用 GPL 此协议是应用最为广泛的开源协议，拥有较强的版权自由( copyleft )要求。衍生代码的分发需开源并且也要遵守此协议。此协议有许多变种，不同变种的要求略有不同 ○公开源码○协议和版权信息○声明变更 ○商用○分发○修改○专利授权○私用 ○责任承担○附加协议 MIT 宽松简单且精要的一个协议。在适当标明来源及免责的情况下，它允许你对代码进行任何形式的使用 ○协议和版权信息 ○商用○分发○修改○私用○附加协议 ○责任承担 Artistic Perl社区尤为钟爱此协议。要求更改后的软件不能影响原软件的使用。 ○协议和版权信息○声明变更 ○商用○分发○修改○私用○附加协议 ○责任承担○商标使用 BSD 较为宽松的协议，包含两个变种BSD 2-Clause 和BSD3-Clause，两者都与MIT协议只存在细微差异。 ○协议和版权信息 ○商用○分发○修改○私用○附加协议 ○责任承担 Eclipse 对商用非常友好的一种协议，可以用于软件的商业授权。包含对专利的优雅授权，并且也可以对相关代码应用商业协议。 ○公开源码○协议和版权信息 ○商用○分发○修改○专利授权○私用○附加协议 ○责任承担 LGPL 主要用于一些代码库。衍生代码可以以此协议发布（言下之意你可以用其他协议），但与此协议相关的代码必需遵循此协议 ○公开源码○库引用○协议和版权信息 ○商用○分发○修改○专利授权○私用○附加协议 ○责任承担 Mozilla Mozilla Public License(MPL 2.0)是由Mozilla基金创建维护的。此协议旨在较为宽松的BSD协议和更加互惠的GPL协议中寻找一个折衷点。 ○公开源码○协议和版权信息 ○商用○分发○修改○专利授权○私用○附加协议 ○责任承担○商标使用 No license 你保留所有权利，不允许他人分发，复制或者创造衍生物。当你将代码发表在一些网站上时需要遵守该网站的协议，此协议可能包含了一些对你劳动成果的授权许可。比如你将代码发布到GitHub，那么你就必需同意别人可以查看和Fork你的代码。 ○协议和版权信息 ○商用○私用 ○分发○修改○附加协议 Public domain dedication 在许多国家，默认版权归作者自动拥有，所以Unlicense协议提供了一种通用的模板，此协议表明你放弃版权，将劳动成果无私贡献出来。你将丧失对作品的全部权利，包括在MIT/X11中定义的无担保权利。 N/A ○商用○分发○修改○私用 ○责任承担","link":"/2019/07/13/IDE/agreement/"},{"title":"MobX入坑","text":"MobX入坑MobX 是一个简单、方便扩展、久经考验的状态管理解决方案。这个教程旨在十分钟内向你介绍 MobX 的一些重要概念。MobX 是一个独立的苦，不过大多数人都把它和 React 一起使用，所以本教程也就着眼于这个组合展开。 核心概念State 是每一个应用程序的核心部分，而使用一个不合规范的 State 则是让你的应用充满 bug 和失控的不二法门，或者就是局部变量环绕，让你的 state 失去了同步。有很多框架试图解决这个问题，比如使用不可变的 state，但是这样以来又带来了新的问题，比如数据必须规格化，完整性约束失效等等。 MobX 让整个事情又变简单了：它不允许产生失控的 state。它的理念也很简单：所有可以从 state 中派生的事物，都会自动的派生。 把 MobX 想象成 Excel 表格。 首先，有一个 state，它可以是一个object，array，primitives等等任何组成你程序的部分。你可以把这个想象成你应用程序的“单元格”。然后就是 derivations，一般它是指可以从 state 中直接计算的来的结果。比如未完成的任务的数量，这个比较简单，也可以稍复杂一些比如渲染你的任务显示的html。它类似于你的应用程序中的“公式和图表”。Reactions 和 derivations 很像，主要的区别在于 reactions 并不产生数据结果，而是自动完成一些任务，一般是和 I/O 相关的。他们保证了 DOM 和 网络请求会自动适时地出发。最后是 actions。Actions 指的是所有会改变 state 的事情，MobX 保证所有 actions 都会有对应的 derivations 和 reactions 相伴，保证同步。一个简单的 todo 的 state 理论说的够多的了，看一个例子也许会更明白一些。我们从一个简单的 todo 程序开始。 下面是一个简单直接的 TodoStore，没有鱼丸，没有粗面，没有 MobX …… JavaScript1234567891011121314151617181920212223242526class TodoStore { todos = []; get completedTodosCount() { return this.todos.filter( todo =&gt; todo.completed === true ).length; } report() { if (this.todos.length === 0) return &quot;&lt;none&gt;&quot;; return `Next todo: &quot;${this.todos[0].task}&quot;. ` + `Progress: ${this.completedTodosCount}/${this.todos.length}`; } addTodo(task) { this.todos.push({ task: task, completed: false, assignee: null }); }}const todoStore = new TodoStore(); 我们创建了一个 todoStore，它拥有一个 todos 集合。现在我们往这个 todoStore 里添加一些东西，为了明显起见，我们每修改一个地方，就调用todoStore.report。 1234567891011121314todoStore.addTodo(&quot;read MobX tutorial&quot;);console.log(todoStore.report());​todoStore.addTodo(&quot;try MobX&quot;);console.log(todoStore.report());​todoStore.todos[0].completed = true;console.log(todoStore.report());​todoStore.todos[1].task = &quot;try MobX in own project&quot;;console.log(todoStore.report());​todoStore.todos[0].task = &quot;grok MobX tutorial&quot;;console.log(todoStore.report()); 到现在为止，没有什么特别的。不过如果我们可以不再手动调用 report 方法，事情会不会更美好一些？我们只需要在想要的地方修改这个 state，所有的汇报都自动来做。 太巧了，这就是 MobX 能为你做的事情。自动执行只在 state 改变的时候触发，就好像 Excel 中的图表只在单元格数据改变时更新一样。为了达到这个目标，TodoStore 必须成为可观测的（observable）才行，让我们来改一些代码。 同时，completedTodosCount 属性应该被自动派生，使用 @observable 和 @computed 装饰器来做这些事情： JavaScript123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class ObservableTodoStore { @observable todos = []; @observable pendingRequests = 0; constructor() { mobx.autorun(() =&gt; console.log(this.report)); } @computed get completedTodosCount() { return this.todos.filter( todo =&gt; todo.completed === true ).length; } @computed get report() { if (this.todos.length === 0) return &quot;&lt;none&gt;&quot;; return `Next todo: &quot;${this.todos[0].task}&quot;. ` + `Progress: ${this.completedTodosCount}/${this.todos.length}`; } addTodo(task) { this.todos.push({ task: task, completed: false, assignee: null }); }}const observableTodoStore = new ObservableTodoStore();class ObservableTodoStore { @observable todos = []; @observable pendingRequests = 0; constructor() { mobx.autorun(() =&gt; console.log(this.report)); } @computed get completedTodosCount() { return this.todos.filter( todo =&gt; todo.completed === true ).length; } @computed get report() { if (this.todos.length === 0) return &quot;&lt;none&gt;&quot;; return `Next todo: &quot;${this.todos[0].task}&quot;. ` + `Progress: ${this.completedTodosCount}/${this.todos.length}`; } addTodo(task) { this.todos.push({ task: task, completed: false, assignee: null }); }}const observableTodoStore = new ObservableTodoStore(); 运行它，太棒了，我们每次赋值都能获得输出结果了。 有个 pendingRequests 暂时没用到，我们后面会用。另外这个教程都用了 ES6 的写法，不过 MobX 也支持 ES5 的写法。 在这个构造器中，我们使用autorun包裹了一个打出report的小函数。Autorun里的东西首先会运行一次，然后当其中的函数有observable的数据发生变化时，会再次运行。 这里我们使用了todos属性，每次todos变化了我们就打印出新的东西。 JavaScript12345observableTodoStore.addTodo(&quot;read MobX tutorial&quot;);observableTodoStore.addTodo(&quot;try MobX&quot;);observableTodoStore.todos[0].completed = true;observableTodoStore.todos[1].task = &quot;try MobX in own project&quot;;observableTodoStore.todos[0].task = &quot;grok MobX tutorial&quot;; （可以自己试试结果） 非常有趣是吧，report确实自己执行了，而且同步又精准。如果你仔细查看运行结果的话，你挥发性我们的第四句语句没有产生输出，因为我们修改了todos[1]的数据，而我们在report中指明的数据，并没有todos[1]的变化而发生变化。而第五句话修改了todos[0]的数据则输出了。这个例子很好的说明了，autorun不是简单的监视了todos，而是精确到了具体的一项。 让React更美好 好了，到目前未知，我们使report自动化了，是实话把react拉出来遛遛了。为了是的react 的组件可以识别mobx，我们需要使用mobx-react包来完成，使用autorun，自动的让组件和state同步，这个简直就和上面的让report自动输出一样简单。 下面是一个react 组件，唯一MobX出场的地方就是一个@observer修饰符，这已经足够了，你再也不用使用setState了，你也不需要指明这个组件需要关注state的哪个部分，也不许手动写什么高阶组件。一般来说，所有的部件都变成人工智能了，即使他被定义成一个木偶（纯展示）组件。 JavaScript12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061@observerclass TodoList extends React.Component { render() { const store = this.props.store; return ( &lt;div&gt; { store.report } &lt;ul&gt; { store.todos.map( (todo, idx) =&gt; &lt;TodoView todo={ todo } key={ idx } /&gt; ) } &lt;/ul&gt; { store.pendingRequests &gt; 0 ? &lt;marquee&gt;Loading...&lt;/marquee&gt; : null } &lt;button onClick={ this.onNewTodo }&gt;New Todo&lt;/button&gt; &lt;small&gt; (double-click a todo to edit)&lt;/small&gt; &lt;RenderCounter /&gt; &lt;/div&gt; ); }​ onNewTodo = () =&gt; { this.props.store.addTodo(prompt(&apos;Enter a new todo:&apos;,&apos;coffee plz&apos;)); }}​@observerclass TodoView extends React.Component { render() { const todo = this.props.todo; return ( &lt;li onDoubleClick={ this.onRename }&gt; &lt;input type=&apos;checkbox&apos; checked={ todo.completed } onChange={ this.onToggleCompleted } /&gt; { todo.task } { todo.assignee ? &lt;small&gt;{ todo.assignee.name }&lt;/small&gt; : null } &lt;RenderCounter /&gt; &lt;/li&gt; ); }​ onToggleCompleted = () =&gt; { const todo = this.props.todo; todo.completed = !todo.completed; }​ onRename = () =&gt; { const todo = this.props.todo; todo.task = prompt(&apos;Task name&apos;, todo.task) || todo.task; }}​ReactDOM.render( &lt;TodoList store={ observableTodoStore } /&gt;, document.getElementById(&apos;reactjs-app&apos;)); 执行下面的语句，我们会发现MobX帮我们把数据的更改反应到界面上去了。 JavaScript1234store.todos[0].completed = !store.todos[0].completed;store.todos[1].task = &quot;Random todo &quot; + Math.random();store.todos.push({ task: &quot;Find a fine cheese&quot;, completed: true });// etc etc.. add your own statements here... 使用引用（References) 到现在位置，我们已经使用 observable 创建了个数据类型了。也许你会想，MobX 能不能应付引用呢？在之前的例子里，你可能主意到了又一个 assignee 的属性，我们就在这里放另外的一个 store，然后把它赋值给 tasks。 JavaScript1234567var peopleStore = mobx.observable([ { name: &quot;Michel&quot; }, { name: &quot;Me&quot; }]);observableTodoStore.todos[0].assignee = peopleStore[0];observableTodoStore.todos[1].assignee = peopleStore[1];peopleStore[0].name = &quot;Michel Weststrate&quot;; 毫无疑问的，MobX 把着一切打理的井井有条。使用 MobX ，不需要规格话数据，不需要指明控件，事实上你的数据在哪里都无所谓。只要 observale 了，什么都好了。 总结 好了，仅仅依靠一些简单的修饰器，我们就让 react 程序如此生动有趣。最后总结一些： @observale 修饰器或者 observable 函数让对象可以被追踪；@computed 修饰器创造了自动运算的表达式；autorun 函数让依靠 observable 的函数自动执行，这个用来写 log，发请求很不错；@observer 修饰器让 React 组建自动起来，它会自动更新，即便是在一个很大的程序里也会工作的很好； 最后，MobX 不是一个状态容器 很多人把 MobX 当作另外一个 Redux，但是它仅仅是一个库，不是一个什么架构。上面的例子还是需要程序员自己去组织逻辑和store或者控制器什么的。","link":"/2019/07/13/React/mobx/"},{"title":"React Router使用教程","text":"React Router使用教程一、基本用法React Router 安装命令如下。 1$ npm install -S react-router 使用时，路由器 Router 就是React的一个组件。 12import { Router } from &apos;react-router&apos;;render(&lt;Router/&gt;, document.getElementById(&apos;app&apos;)); Router 组件本身只是一个容器，真正的路由要通过 Route 组件定义。 1234567import { Router, Route, hashHistory } from &apos;react-router&apos;;render(( &lt;Router history={hashHistory}&gt; &lt;Route path=&quot;/&quot; component={App}/&gt; &lt;/Router&gt;), document.getElementById(&apos;app&apos;)); 上面代码中，用户访问根路由 / （比如 http://www.example.com/ ），组件 APP 就会加载到 document.getElementById(‘app’) 。 你可能还注意到， Router 组件有一个参数 history ，它的值 hashHistory 表示，路由的切换由URL的hash变化决定，即URL的 # 部分发生变化。举例来说，用户访问 http://www.example.com/ ，实际会看到的是 http://www.example.com/#/ 。 Route 组件定义了URL路径与组件的对应关系。你可以同时使用多个 Route 组件。 12345&lt;Router history={hashHistory}&gt; &lt;Route path=&quot;/&quot; component={App}/&gt; &lt;Route path=&quot;/repos&quot; component={Repos}/&gt; &lt;Route path=&quot;/about&quot; component={About}/&gt;&lt;/Router&gt; 上面代码中，用户访问 /repos （比如 http://localhost:8080/#/repos ）时，加载 Repos 组件；访问 /about （ http://localhost:8080/#/about ）时，加载 About 组件。 二、嵌套路由Route 组件还可以嵌套。 123456&lt;Router history={hashHistory}&gt; &lt;Route path=&quot;/&quot; component={App}&gt; &lt;Route path=&quot;/repos&quot; component={Repos}/&gt; &lt;Route path=&quot;/about&quot; component={About}/&gt; &lt;/Route&gt;&lt;/Router&gt; 上面代码中，用户访问 /repos 时，会先加载 App 组件，然后在它的内部再加载 Repos 组件。 123&lt;App&gt; &lt;Repos/&gt;&lt;/App&gt; App 组件要写成下面的样子。 1234567export default React.createClass({ render() { return &lt;div&gt; {this.props.children} &lt;/div&gt; }}) 上面代码中， App 组件的 this.props.children 属性就是子组件。 子路由也可以不写在 Router 组件里面，单独传入 Router 组件的 routes 属性。 123456let routes = &lt;Route path=&quot;/&quot; component={App}&gt; &lt;Route path=&quot;/repos&quot; component={Repos}/&gt; &lt;Route path=&quot;/about&quot; component={About}/&gt;&lt;/Route&gt;;&lt;Router routes={routes} history={browserHistory}/&gt; 三、 path 属性Route 组件的 path 属性指定路由的匹配规则。这个属性是可以省略的，这样的话，不管路径是否匹配，总是会加载指定组件。 请看下面的例子。 123&lt;Route path=&quot;inbox&quot; component={Inbox}&gt; &lt;Route path=&quot;messages/:id&quot; component={Message} /&gt;&lt;/Route&gt; 上面代码中，当用户访问 /inbox/messages/:id 时，会加载下面的组件。 123&lt;Inbox&gt; &lt;Message/&gt;&lt;/Inbox&gt; 如果省略外层 Route 的 path 参数，写成下面的样子。 123&lt;Route component={Inbox}&gt; &lt;Route path=&quot;inbox/messages/:id&quot; component={Message} /&gt;&lt;/Route&gt; 现在用户访问 /inbox/messages/:id 时，组件加载还是原来的样子。 123&lt;Inbox&gt; &lt;Message/&gt;&lt;/Inbox&gt; 四、通配符path 属性可以使用通配符。 123456789101112131415161718192021&lt;Route path=&quot;/hello/:name&quot;&gt;// 匹配 /hello/michael// 匹配 /hello/ryan&lt;Route path=&quot;/hello(/:name)&quot;&gt;// 匹配 /hello// 匹配 /hello/michael// 匹配 /hello/ryan&lt;Route path=&quot;/files/*.*&quot;&gt;// 匹配 /files/hello.jpg// 匹配 /files/hello.html&lt;Route path=&quot;/files/*&quot;&gt;// 匹配 /files/// 匹配 /files/a// 匹配 /files/a/b&lt;Route path=&quot;/**/*.jpg&quot;&gt;// 匹配 /files/hello.jpg// 匹配 /files/path/to/file.jpg 通配符的规则如下。123456789101112131415（1） :paramName:paramName 匹配URL的一个部分，直到遇到下一个 / 、 ? 、 # 为止。这个路径参数可以通过 this.props.params.paramName 取出。（2） ()() 表示URL的这个部分是可选的。（3） ** 匹配任意字符，直到模式里面的下一个字符为止。匹配方式是非贪婪模式。（4） **** 匹配任意字符，直到下一个 / 、 ? 、 # 为止。匹配方式是贪婪模式。 path 属性也可以使用相对路径（不以 / 开头），匹配时就会相对于父组件的路径，可以参考上一节的例子。嵌套路由如果想摆脱这个规则，可以使用绝对路由。 路由匹配规则是从上到下执行，一旦发现匹配，就不再其余的规则了。 12&lt;Route path=&quot;/comments&quot; ... /&gt;&lt;Route path=&quot;/comments&quot; ... /&gt; 上面代码中，路径 /comments 同时匹配两个规则，第二个规则不会生效。 设置路径参数时，需要特别小心这一点。 1234&lt;Router&gt; &lt;Route path=&quot;/:userName/:id&quot; component={UserPage}/&gt; &lt;Route path=&quot;/about/me&quot; component={About}/&gt;&lt;/Router&gt; 上面代码中，用户访问 /about/me 时，不会触发第二个路由规则，因为它会匹配 /:userName/:id 这个规则。因此，带参数的路径一般要写在路由规则的底部。 此外，URL的查询字符串 /foo?bar=baz ，可以用 this.props.location.query.bar 获取。 五、IndexRoute 组件下面的例子，你会不会觉得有一点问题？ 123456&lt;Router&gt; &lt;Route path=&quot;/&quot; component={App}&gt; &lt;Route path=&quot;accounts&quot; component={Accounts}/&gt; &lt;Route path=&quot;statements&quot; component={Statements}/&gt; &lt;/Route&gt;&lt;/Router&gt; 上面代码中，访问根路径 / ，不会加载任何子组件。也就是说， App 组件的 this.props.children ，这时是 undefined 。 因此，通常会采用 {this.props.children || &lt;Home/&gt;} 这样的写法。这时， Home 明明是 Accounts 和 Statements 的同级组件，却没有写在 Route 中。 IndexRoute 就是解决这个问题，显式指定 Home 是根路由的子组件，即指定默认情况下加载的子组件。你可以把 IndexRoute 想象成某个路径的 index.html 。 1234567&lt;Router&gt; &lt;Route path=&quot;/&quot; component={App}&gt; &lt;IndexRoute component={Home}/&gt; &lt;Route path=&quot;accounts&quot; component={Accounts}/&gt; &lt;Route path=&quot;statements&quot; component={Statements}/&gt; &lt;/Route&gt;&lt;/Router&gt; 现在，用户访问 / 的时候，加载的组件结构如下。 123&lt;App&gt; &lt;Home/&gt;&lt;/App&gt; 这种组件结构就很清晰了： App 只包含下级组件的共有元素，本身的展示内容则由 Home 组件定义。这样有利于代码分离，也有利于使用React Router提供的各种API。 注意， IndexRoute 组件没有路径参数 path 。 六、Redirect 组件 组件用于路由的跳转，即用户访问一个路由，会自动跳转到另一个路由。 1234&lt;Route path=&quot;inbox&quot; component={Inbox}&gt; {/* 从 /inbox/messages/:id 跳转到 /messages/:id */} &lt;Redirect from=&quot;messages/:id&quot; to=&quot;/messages/:id&quot; /&gt;&lt;/Route&gt; 现在访问 /inbox/messages/5 ，会自动跳转到 /messages/5 。 七、IndexRedirect 组件IndexRedirect 组件用于访问根路由的时候，将用户重定向到某个子组件。 12345&lt;Route path=&quot;/&quot; component={App}&gt; &lt;IndexRedirect to=&quot;/welcome&quot; /&gt; &lt;Route path=&quot;welcome&quot; component={Welcome} /&gt; &lt;Route path=&quot;about&quot; component={About} /&gt;&lt;/Route&gt; 上面代码中，用户访问根路径时，将自动重定向到子组件 welcome 。 八、LinkLink 组件用于取代 a标签，生成一个链接，允许用户点击后跳转到另一个路由。它基本上就是 a标签的React 版本，可以接收 Router 的状态。 12345678render() { return &lt;div&gt; &lt;ul role=&quot;nav&quot;&gt; &lt;li&gt;&lt;Link to=&quot;/about&quot;&gt;About&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/repos&quot;&gt;Repos&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;} 如果希望当前的路由与其他路由有不同样式，这时可以使用 Link 组件的 activeStyle 属性。 12&lt;Link to=&quot;/about&quot; activeStyle={{color: &apos;red&apos;}}&gt;About&lt;/Link&gt;&lt;Link to=&quot;/repos&quot; activeStyle={{color: &apos;red&apos;}}&gt;Repos&lt;/Link&gt; 上面代码中，当前页面的链接会红色显示。 另一种做法是，使用 activeClassName 指定当前路由的 Class 。 12&lt;Link to=&quot;/about&quot; activeClassName=&quot;active&quot;&gt;About&lt;/Link&gt;&lt;Link to=&quot;/repos&quot; activeClassName=&quot;active&quot;&gt;Repos&lt;/Link&gt; 上面代码中，当前页面的链接的 class 会包含 active 。 在 Router 组件之外，导航到路由页面，可以使用浏览器的History API，像下面这样写。 12import { browserHistory } from &apos;react-router&apos;;browserHistory.push(&apos;/some/path&apos;); 九、IndexLink如果链接到根路由 / ，不要使用 Link 组件，而要使用 IndexLink 组件。 这是因为对于根路由来说， activeStyle 和 activeClassName 会失效，或者说总是生效，因为 / 会匹配任何子路由。而 IndexLink 组件会使用路径的精确匹配。123&lt;IndexLink to=&quot;/&quot; activeClassName=&quot;active&quot;&gt; Home&lt;/IndexLink&gt; 上面代码中，根路由只会在精确匹配时，才具有 activeClassName 。 另一种方法是使用 Link 组件的 onlyActiveOnIndex 属性，也能达到同样效果。 123&lt;Link to=&quot;/&quot; activeClassName=&quot;active&quot; onlyActiveOnIndex={true}&gt; Home&lt;/Link&gt; 实际上， IndexLink 就是对 Link 组件的 onlyActiveOnIndex 属性的包装。 十、histroy 属性Router 组件的 history 属性，用来监听浏览器地址栏的变化，并将URL解析成一个地址对象，供 React Router 匹配。 history 属性，一共可以设置三种值。123browserHistoryhashHistorycreateMemoryHistory 如果设为 hashHistory ，路由将通过URL的hash部分（ # ）切换，URL的形式类似 example.com/#/some/path 。 123456import { hashHistory } from &apos;react-router&apos;render( &lt;Router history={hashHistory} routes={routes} /&gt;, document.getElementById(&apos;app&apos;)) 如果设为 browserHistory ，浏览器的路由就不再通过 Hash 完成了，而显示正常的路径 example.com/some/path ，背后调用的是浏览器的History API。 123456import { browserHistory } from &apos;react-router&apos;render( &lt;Router history={browserHistory} routes={routes} /&gt;, document.getElementById(&apos;app&apos;)) 但是，这种情况需要对 服务器改造 。否则用户直接向服务器请求某个子路由，会显示网页找不到的404错误。 如果开发服务器使用的是 webpack-dev-server ，加上 –history-api-fallback 参数就可以了。 123456$ webpack-dev-server --inline --content-base . --history-api-fallbackcreateMemoryHistory 主要用于服务器渲染。它创建一个内存中的 history 对象，不与浏览器URL互动。const history = createMemoryHistory(location) 十一、表单处理Link 组件用于正常的用户点击跳转，但是有时还需要表单跳转、点击按钮跳转等操作。这些情况怎么跟React Router对接呢？ 下面是一个表单。 12345&lt;form onSubmit={this.handleSubmit}&gt; &lt;input type=&quot;text&quot; placeholder=&quot;userName&quot;/&gt; &lt;input type=&quot;text&quot; placeholder=&quot;repo&quot;/&gt; &lt;button type=&quot;submit&quot;&gt;Go&lt;/button&gt;&lt;/form&gt; 第一种方法是使用 browserHistory.push 12345678910import { browserHistory } from &apos;react-router&apos;// ... handleSubmit(event) { event.preventDefault() const userName = event.target.elements[0].value const repo = event.target.elements[1].value const path = `/repos/${userName}/${repo}` browserHistory.push(path) }, 第二种方法是使用 context 对象。 123456789101112export default React.createClass({ // ask for `router` from context contextTypes: { router: React.PropTypes.object }, handleSubmit(event) { // ... this.context.router.push(path) },}) 十二、路由的钩子每个路由都有 Enter 和 Leave 钩子，用户进入或离开该路由时触发。 1234&lt;Route path=&quot;about&quot; component={About} /&gt;&lt;Route path=&quot;inbox&quot; component={Inbox}&gt; &lt;Redirect from=&quot;messages/:id&quot; to=&quot;/messages/:id&quot; /&gt;&lt;/Route&gt; 上面的代码中，如果用户离开 /messages/:id ，进入 /about 时，会依次触发以下的钩子。 /messages/:id 的 onLeave/inbox 的 onLeave/about 的 onEnter下面是一个例子，使用 onEnter 钩子替代 组件。 12345678&lt;Route path=&quot;inbox&quot; component={Inbox}&gt; &lt;Route path=&quot;messages/:id&quot; onEnter={ ({params}, replace) =&gt; replace(`/messages/${params.id}`) } /&gt;&lt;/Route&gt; 下面是一个高级应用，当用户离开一个路径的时候，跳出一个提示框，要求用户确认是否离开。 1234567891011121314151617const Home = withRouter( React.createClass({ componentDidMount() { this.props.router.setRouteLeaveHook( this.props.route, this.routerWillLeave ) }, routerWillLeave(nextLocation) { // 返回 false 会继续停留当前页面， // 否则，返回一个字符串，会显示给用户，让其自己决定 if (!this.state.isSaved) return &apos;确认要离开？&apos;; }, })) 上面代码中， setRouteLeaveHook 方法为 Leave 钩子指定 routerWillLeave 函数。该方法如果返回 false ，将阻止路由的切换，否则就返回一个字符串，提示用户决定是否要切换。","link":"/2019/07/13/React/router/"},{"title":"Redux使用入门","text":"Redux使用入门参考网站 1. 前言随着WEB应用变得越来越复杂，再加上node前后端分离越来越流行，那么对数据流动的控制就显得越发重要。redux是在flux的基础上产生的，基本思想是保证数据的单向流动，同时便于控制、使用、测试。 redux不依赖于任意框架(库)，只要subscribe相应框架(库)的内部方法，就可以使用该应用框架保证数据流动的一致性。 那么如何使用redux呢？下面一步步进行解析，并带有源码说明，不仅做到 知其然 ，还要做到 知其所以然 。 2. 主干逻辑介绍(createStore)2.1 简单demo入门先来一个直观的认识：12345678910111213141516171819202122232425262728293031323334353637// 首先定义一个改变数据的plain函数，成为reducerfunction count (state, action) { var defaultState = { year: 2015, }; state = state || defaultState; switch (action.type) { case &apos;add&apos;: return { year: state.year + 1 }; case &apos;sub&apos;: return { year: state.year - 1 } default : return state; } }// store的创建var createStore = require(&apos;redux&apos;).createStore;var store = createStore(count);// store里面的数据发生改变时，触发的回调函数store.subscribe(function () { console.log(&apos;the year is: &apos;, store.getState().year);});// action: 触发state改变的唯一方法(按照redux的设计思路)var action1 = { type: &apos;add&apos; };var action2 = { type: &apos;add&apos; };var action3 = { type: &apos;sub&apos; };// 改变store里面的方法store.dispatch(action1); // &apos;the year is: 2016store.dispatch(action2); // &apos;the year is: 2017store.dispatch(action3); // &apos;the year is: 2016 2.2 挖掘createStore实现为了说明主要问题，仅列出其中的关键代码，全部代码，可以点击 这里 阅读。 a首先看createStore到底都返回的内容:123456789export default function createStore(reducer, initialState) { ... return { dispatch, subscribe, getState, replaceReducer }} 每个属性的含义是: - dispatch: 用于action的分发，改变store里面的state - subscribe: 注册listener，store里面state发生改变后，执行该listener - getState: 读取store里面的state - replaceReducer: 替换reducer，改变state修改的逻辑 b关键代码解析1234567891011121314151617181920212223242526272829303132333435363738394041424344454647export default function createStore(reducer, initialState) { // 这些都是闭包变量 var currentReducer = reducer var currentState = initialState var listeners = [] var isDispatching = false; // 返回当前的state function getState() { return currentState } // 注册listener，同时返回一个取消事件注册的方法 function subscribe(listener) { listeners.push(listener) var isSubscribed = true return function unsubscribe() { if (!isSubscribed) { return } isSubscribed = false var index = listeners.indexOf(listener) listeners.splice(index, 1) } } // 通过action该改变state，然后执行subscribe注册的方法 function dispatch(action) { try { isDispatching = true currentState = currentReducer(currentState, action) } finally { isDispatching = false } listeners.slice().forEach(listener =&gt; listener()) return action } // 替换reducer，修改state变化的逻辑 function replaceReducer(nextReducer) { currentReducer = nextReducer dispatch({ type: ActionTypes.INIT }) } // 初始化时，执行内部一个dispatch，得到初始state dispatch({ type: ActionTypes.INIT })} 如果还按照2.1的方式进行开发，那跟flux没有什么大的区别，需要手动解决很多问题，那redux如何将整个流程模板化(Boilerplate)呢? 3. 保证store的唯一性随着应用越来越大，一方面，不能把所有的数据都放到一个reducer里面，另一方面，为每个reducer创建一个store，后续store的维护就显得比较麻烦。如何将二者统一起来呢？ 3.1 demo入手通过combineReducers将多个reducer合并成一个rootReducer: // 创建两个reducer: count year function count (state, action) { state = state || {count: 1} switch (action.type) { default: return state; } } function year (state, action) { state = state || {year: 2015} switch (action.type) { default: return state; } }12345678910111213141516171819// 将多个reducer合并成一个var combineReducers = require(&apos;./&apos;).combineReducers;var rootReducer = combineReducers({ count: count, year: year,});// 创建store，跟2.1没有任何区别var createStore = require(&apos;./&apos;).createStore;var store = createStore(rootReducer);var util = require(&apos;util&apos;);console.log(util.inspect(store));//输出的结果，跟2.1的store在结构上不存在区别// { dispatch: [Function: dispatch],// subscribe: [Function: subscribe],// getState: [Function: getState],// replaceReducer: [Function: replaceReducer]// } 3.2 源码解析combineReducers12345678910111213141516171819// 高阶函数，最后返回一个reducerexport default function combineReducers(reducers) { // 提出不合法的reducers, finalReducers就是一个闭包变量 var finalReducers = pick(reducers, (val) =&gt; typeof val === &apos;function&apos;) // 将各个reducer的初始state均设置为undefined var defaultState = mapValues(finalReducers, () =&gt; undefined) // 一个总reducer，内部包含子reducer return function combination(state = defaultState, action) { var finalState = mapValues(finalReducers, (reducer, key) =&gt; { var previousStateForKey = state[key] var nextStateForKey = reducer(previousStateForKey, action) hasChanged = hasChanged || nextStateForKey !== previousStateForKey return nextStateForKey ); return hasChanged ? finalState : state }} 4. 自动实现dispatch4.1 demo介绍在2.1中，要执行state的改变，需要手动dispatch: var action = { type: ‘‘, payload: ‘‘};dispatch(action);手动dispatch就显得啰嗦了，那么如何自动完成呢?123var bindActionCreators = require(&apos;redux&apos;).bindActionCreators;// 可以在具体的应用框架隐式进行该过程(例如react-redux的connect组件中)bindActionCreators(action) 4.2 源码解析12345678910111213// 隐式实现dispatchfunction bindActionCreator(actionCreator, dispatch) { return (...args) =&gt; dispatch(actionCreator(...args))}export default function bindActionCreators(actionCreators, dispatch) { if (typeof actionCreators === &apos;function&apos;) { return bindActionCreator(actionCreators, dispatch) } return mapValues(actionCreators, actionCreator =&gt; bindAQctionCreator(actionCreator, dispatch) )} 5. 支持插件 - 对dispatch的改造5.1 插件使用demo一个action可以是同步的，也可能是异步的，这是两种不同的情况， dispatch执行的时机是不一样的:1234567891011121314151617// 同步的action creator, store可以默认实现dispatchfunction add() { return { tyle: &apos;add&apos; }}dispatch(add());// 异步的action creator，因为异步完成的时间不确定，只能手工dispatchfunction fetchDataAsync() { return function (dispatch) { requst(url).end(function (err, res) { if (err) return dispatch({ type: &apos;SET_ERR&apos;, payload: err}); if (res.status === &apos;success&apos;) { dispatch({ type: &apos;FETCH_SUCCESS&apos;, payload: res.data }); } }) }} 下面的问题就变成了，如何根据实际情况实现不同的dispatch方法，也即是根据需要实现不同的moddleware:1234567891011// 普通的dispatch创建方法var store = createStore(reducer, initialState);console.log(store.dispatch);// 定制化的dispatchvar applyMiddleware = require(&apos;redux&apos;).applyMiddleware;// 实现action异步的middlewarevar thunk = requre(&apos;redux-thunk&apos;);var store = applyMiddleware([thunk])(createStore);// 经过处理的dispatch方法console.log(store.dispatch); 5.2 源码解析123456789101112131415161718192021222324252627282930313233// next: 其实就是createStoreexport default function applyMiddleware(...middlewares) { return (next) =&gt; (reducer, initialState) =&gt; { var store = next(reducer, initialState) var dispatch = store.dispatch var chain = [] var middlewareAPI = { getState: store.getState, dispatch: (action) =&gt; dispatch(action) } chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) dispatch = compose(...chain)(store.dispatch) return { ...store, dispatch // 实现新的dispatch方法 } }}// 再看看redux-thunk的实现, next就是store里面的上一个dispatchfunction thunkMiddleware({ dispatch, getState }) { return function(next) { return function(action) { typeof action === &apos;function&apos; ? action(dispatch, getState) : next(action); } } return next =&gt; action =&gt; typeof action === &apos;function&apos; ? action(dispatch, getState) : next(action); } 6. 与react框架的结合####6.1 基本使用 目前已经有现成的工具 react-redux 来实现二者的结合:1234567891011121314151617181920212223242526var rootReducers = combineReducers(reducers);var store = createStore(rootReducers);var Provider = require(&apos;react-redux&apos;).Provider;// App 为上层的Componentclass App extend React.Component{ render() { return ( &lt;Provier store={store}&gt; &lt;Container /&gt; &lt;/Provider&gt; ); }}// Container作用: 1. 获取store中的数据; 2.将dispatch与actionCreator结合起来var connect = require(&apos;react-redux&apos;).connect;var actionCreators = require(&apos;...&apos;);// MyComponent是与redux无关的组件var MyComponent = require(&apos;...&apos;);function select(state) { return { count: state.count }}export default connect(select, actionCreators)(MyComponent) 6.2 Provider – 提供storeReact通过Context属性，可以将属性(props)直接给子孙component，无须通过props层层传递, Provider仅仅起到获得store，然后将其传递给子孙元素而已:123456789101112131415161718192021222324export default class Provider extends Component { getChildContext() { // getChildContext: 将store传递给子孙component return { store: this.store } } constructor(props, context) { super(props, context) this.store = props.store } componentWillReceiveProps(nextProps) { const { store } = this const { store: nextStore } = nextProps if (store !== nextStore) { warnAboutReceivingStore() } } render() { let { children } = this.props return Children.only(children) }} 6.3 connect – 获得store及dispatch(actionCreator)connect是一个高阶函数，首先传入mapStateToProps、mapDispatchToProps，然后返回一个生产 Component 的函数(wrapWithConnect)，然后再将真正的Component作为参数传入wrapWithConnect(MyComponent)，这样就生产出一个经过包裹的Connect组件，该组件具有如下特点: 通过this.context获取祖先Component的storeprops包括stateProps、dispatchProps、parentProps,合并在一起得到 nextState ，作为props传给真正的ComponentcomponentDidMount时，添加事件this.store.subscribe(this.handleChange)，实现页面交互shouldComponentUpdate时判断是否有避免进行渲染，提升页面性能，并得到nextStatecomponentWillUnmount时移除注册的事件this.handleChange在非生产环境下，带有热重载功能主要的代码逻辑:12345678910111213141516171819202122232425262728293031323334353637383940export default function connect(mapStateToProps, mapDispatchToProps, mergeProps, options = {}) { return function wrapWithConnect(WrappedComponent) { class Connect extends Component { constructor(props, context) { // 从祖先Component处获得store this.store = props.store || context.store this.stateProps = computeStateProps(this.store, props) this.dispatchProps = computeDispatchProps(this.store, props) this.state = { storeState: null } // 对stateProps、dispatchProps、parentProps进行合并 this.updateState() } shouldComponentUpdate(nextProps, nextState) { // 进行判断，当数据发生改变时，Component重新渲染 if (propsChanged || mapStateProducedChange || dispatchPropsChanged) { this.updateState(nextProps) return true } } componentDidMount() { // 改变Component的state this.store.subscribe(() = { this.setState({ storeState: this.store.getState() }) }) } render() { // 生成包裹组件Connect return ( &lt;WrappedComponent {...this.nextState} /&gt; ) } } Connect.contextTypes = { store: storeShape } return Connect; } } 7. redux与react-redux关系图","link":"/2019/07/13/React/redux/"},{"title":"webpack项目搭建","text":"webpack项目搭建什么是 webpack？webpack是近期最火的一款模块加载器兼打包工具，它能把各种资源，例如JS（含JSX）、coffee、样式（含less/sass）、图片等都作为模块来使用和处理。我们可以直接使用 require(XXX) 的形式来引入各模块，即使它们可能需要经过编译（比如JSX和sass），但我们无须在上面花费太多心思，因为 webpack 有着各种健全的加载器（loader）在默默处理这些事情，这块我们后续会提到。你可以不打算将其用在你的项目上，但没有理由不去掌握它，因为以近期 Github 上各大主流的（React相关）项目来说，它们仓库上所展示的示例已经是基于 webpack 来开发的，比如 React-Boostrap 和 Redux。webpack的官网是 http://webpack.github.io/ ，文档地址是 http://webpack.github.io/docs/ ，想对其进行更详细了解的可以点进去瞧一瞧。 webpack 的优势其优势主要可以归类为如下几个： webpack 是以 commonJS 的形式来书写脚本滴，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移。 能被模块化的不仅仅是 JS 了。 开发便捷，能替代部分 grunt/gulp 的工作，比如打包、压缩混淆、图片转base64等。 扩展性强，插件机制完善，特别是支持 React 热插拔（见 react-hot-loader ）的功能让人眼前一亮。我们谈谈第一点。以 AMD/CMD 模式来说，鉴于模块是异步加载的，所以我们常规需要使用 define 函数来帮我们搞回调：12345678define([&apos;package/lib&apos;], function(lib){ function foo(){ lib.log(&apos;hello world!&apos;); } return { foo: foo };}); 另外为了可以兼容 commonJS 的写法，我们也可以将 define 这么写：123456789101112define(function (require, exports, module){ var someModule = require(&quot;someModule&quot;); var anotherModule = require(&quot;anotherModule&quot;); someModule.doTehAwesome(); anotherModule.doMoarAwesome(); exports.asplode = function (){ someModule.doTehAwesome(); anotherModule.doMoarAwesome(); };}); 然而对 webpack 来说，我们可以直接在上面书写 commonJS 形式的语法，无须任何 define （毕竟最终模块都打包在一起，webpack 也会最终自动加上自己的加载器）： 12345678910var someModule = require(&quot;someModule&quot;); var anotherModule = require(&quot;anotherModule&quot;); someModule.doTehAwesome(); anotherModule.doMoarAwesome(); exports.asplode = function (){ someModule.doTehAwesome(); anotherModule.doMoarAwesome(); }; 这样撸码自然更简单，跟回调神马的说 byebye~不过即使你保留了之前 define 的写法也是可以滴，毕竟 webpack 的兼容性相当出色，方便你旧项目的模块直接迁移过来。 安装和配置一. 安装我们常规直接使用 npm 的形式来安装：1$ npm install webpack -g 当然如果常规项目还是把依赖写入 package.json 包去更人性化：12$ npm init$ npm install webpack --save-dev 二. 配置每个项目下都必须配置有一个 webpack.config.js ，它的作用如同常规的 gulpfile.js/Gruntfile.js ，就是一个配置项，告诉 webpack 它需要做什么。我们看看下方的示例：1234567891011121314151617181920212223242526272829303132333435var webpack = require(&apos;webpack&apos;);var commonsPlugin = new webpack.optimize.CommonsChunkPlugin(&apos;common.js&apos;);module.exports = { //插件项 plugins: [commonsPlugin], //页面入口文件配置 entry: { index : &apos;./src/js/page/index.js&apos; }, //入口文件输出配置 output: { path: &apos;dist/js/page&apos;, filename: &apos;[name].js&apos; }, module: { //加载器配置 loaders: [ { test: /\\.css$/, loader: &apos;style-loader!css-loader&apos; }, { test: /\\.js$/, loader: &apos;jsx-loader?harmony&apos; }, { test: /\\.scss$/, loader: &apos;style!css!sass?sourceMap&apos;}, { test: /\\.(png|jpg)$/, loader: &apos;url-loader?limit=8192&apos;} ] }, //其它解决方案配置 resolve: { root: &apos;E:/github/flux-example/src&apos;, //绝对路径 extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.json&apos;, &apos;.scss&apos;], alias: { AppStore : &apos;js/stores/AppStores.js&apos;, ActionType : &apos;js/actions/ActionType.js&apos;, AppAction : &apos;js/actions/AppAction.js&apos; } }}; ⑴ plugins 是插件项，这里我们使用了一个 CommonsChunkPlugin 的插件，它用于提取多个入口文件的公共脚本部分，然后生成一个 common.js 来方便多页面之间进行复用。⑵ entry 是页面入口文件配置，output 是对应输出项配置（即入口文件最终要生成什么名字的文件、存放到哪里），其语法大致为：1234567891011{ entry: { page1: &quot;./page1&quot;, //支持数组形式，将加载数组中的所有模块，但以最后一个模块作为输出 page2: [&quot;./entry1&quot;, &quot;./entry2&quot;] }, output: { path: &quot;dist/js/page&quot;, filename: &quot;[name].bundle.js&quot; }} 该段代码最终会生成一个 page1.bundle.js 和 page2.bundle.js，并存放到 ./dist/js/page 文件夹下。⑶ module.loaders 是最关键的一块配置。它告知 webpack 每一种文件都需要使用什么加载器来处理：12345678910111213module: { //加载器配置 loaders: [ //.css 文件使用 style-loader 和 css-loader 来处理 { test: /\\.css$/, loader: &apos;style-loader!css-loader&apos; }, //.js 文件使用 jsx-loader 来编译处理 { test: /\\.js$/, loader: &apos;jsx-loader?harmony&apos; }, //.scss 文件使用 style-loader、css-loader 和 sass-loader 来编译处理 { test: /\\.scss$/, loader: &apos;style!css!sass?sourceMap&apos;}, //图片文件使用 url-loader 来处理，小于8kb的直接转为base64 { test: /\\.(png|jpg)$/, loader: &apos;url-loader?limit=8192&apos;} ] } 如上，”-loader”其实是可以省略不写的，多个loader之间用“!”连接起来。注意所有的加载器都需要通过 npm 来加载，并建议查阅它们对应的 readme 来看看如何使用。拿最后一个 url-loader 来说，它会将样式中引用到的图片转为模块来处理，使用该加载器需要先进行安装：1npm install url-loader -save-dev 配置信息的参数“?limit=8192”表示将所有小于8kb的图片都转为base64形式（其实应该说超过8kb的才使用 url-loader 来映射到文件，否则转为data url形式）。⑷ 最后是 resolve 配置，这块很好理解，直接写注释了：123456789101112resolve: { //查找module的话从这里开始查找 root: &apos;E:/github/flux-example/src&apos;, //绝对路径 //自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名 extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.json&apos;, &apos;.scss&apos;], //模块别名定义，方便后续直接引用别名，无须多写长长的地址 alias: { AppStore : &apos;js/stores/AppStores.js&apos;,//后续直接 require(&apos;AppStore&apos;) 即可 ActionType : &apos;js/actions/ActionType.js&apos;, AppAction : &apos;js/actions/AppAction.js&apos; } } 关于 webpack.config.js 更详尽的配置可以参考这里。运行 webpackwebpack 的执行也很简单，直接执行1$ webpack --display-error-details 即可，后面的参数“–display-error-details”是推荐加上的，方便出错时能查阅更详尽的信息（比如 webpack 寻找模块的过程），从而更好定位到问题。其他主要的参数有：1234567$ webpack --config XXX.js //使用另一份配置文件（比如webpack.config2.js）来打包$ webpack --watch //监听变动并自动打包$ webpack -p //压缩混淆脚本，这个非常非常重要！$ webpack -d //生成map映射文件，告知哪些模块被最终打包到哪里了 其中的 -p 是很重要的参数，曾经一个未压缩的 700kb 的文件，压缩后直接降到 180kb（主要是样式这块一句就独占一行脚本，导致未压缩脚本变得很大）。 模块引入上面唠嗑了那么多配置和执行方法，下面开始说说寻常页面和脚本怎么使用呗。 一. HTML直接在页面引入 webpack 最终生成的页面脚本即可，不用再写什么 data-main 或 seajs.use 了：1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;dist/js/page/common.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;dist/js/page/index.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 可以看到我们连样式都不用引入，毕竟脚本执行时会动态生成并标签打到head里。 二. JS各脚本模块可以直接使用 commonJS 来书写，并可以直接引入未经编译的模块，比如 JSX、sass、coffee等（只要你在 webpack.config.js 里配置好了对应的加载器）。我们再看看编译前的页面入口文件（index.js）： 1234567891011121314151617181920212223require(&apos;../../css/reset.scss&apos;); //加载初始化样式require(&apos;../../css/allComponent.scss&apos;); //加载组件样式var React = require(&apos;react&apos;);var AppWrap = require(&apos;../component/AppWrap&apos;); //加载组件var createRedux = require(&apos;redux&apos;).createRedux;var Provider = require(&apos;redux/react&apos;).Provider;var stores = require(&apos;AppStore&apos;);var redux = createRedux(stores);var App = React.createClass({ render: function() { return ( &lt;Provider redux={redux}&gt; {function() { return &lt;AppWrap /&gt;; }} &lt;/Provider&gt; ); }});React.render( &lt;App /&gt;, document.body); 一切就是这么简单么么哒~ 后续各种有的没的，webpack 都会帮你进行处理。 其他至此我们已经基本上手了 webpack 的使用，下面是补充一些有用的技巧。 一. shimming在 AMD/CMD 中，我们需要对不符合规范的模块（比如一些直接返回全局变量的插件）进行 shim 处理，这时候我们需要使用 exports-loader 来帮忙：1{ test: require.resolve(&quot;./src/js/tool/swipe.js&quot;), loader: &quot;exports?swipe&quot;} 之后在脚本中需要引用该模块的时候，这么简单地来使用就可以了：12require(&apos;./tool/swipe.js&apos;);swipe(); 二. 自定义公共模块提取在文章开始我们使用了 CommonsChunkPlugin 插件来提取多个页面之间的公共模块，并将该模块打包为 common.js 。但有时候我们希望能更加个性化一些，我们可以这样配置：1234567891011121314151617181920212223var CommonsChunkPlugin = require(&quot;webpack/lib/optimize/CommonsChunkPlugin&quot;);module.exports = { entry: { p1: &quot;./page1&quot;, p2: &quot;./page2&quot;, p3: &quot;./page3&quot;, ap1: &quot;./admin/page1&quot;, ap2: &quot;./admin/page2&quot; }, output: { filename: &quot;[name].js&quot; }, plugins: [ new CommonsChunkPlugin(&quot;admin-commons.js&quot;, [&quot;ap1&quot;, &quot;ap2&quot;]), new CommonsChunkPlugin(&quot;commons.js&quot;, [&quot;p1&quot;, &quot;p2&quot;, &quot;admin-commons.js&quot;]) ]};// &lt;script&gt;s required:// page1.html: commons.js, p1.js// page2.html: commons.js, p2.js// page3.html: p3.js// admin-page1.html: commons.js, admin-commons.js, ap1.js// admin-page2.html: commons.js, admin-commons.js, ap2.js 三. 独立打包样式文件有时候可能希望项目的样式能不要被打包到脚本中，而是独立出来作为.css，然后在页面中以标签引入。这时候我们需要 extract-text-webpack-plugin 来帮忙：12345678910var webpack = require(&apos;webpack&apos;); var commonsPlugin = new webpack.optimize.CommonsChunkPlugin(&apos;common.js&apos;); var ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;); module.exports = { plugins: [commonsPlugin, new ExtractTextPlugin(&quot;[name].css&quot;)], entry: { //...省略其它配置 } } 最终 webpack 执行后会乖乖地把样式文件提取出来： 四. 使用CDN/远程文件有时候我们希望某些模块走CDN并以的形式挂载到页面上来加载，但又希望能在 webpack 的模块中使用上。这时候我们可以在配置文件里使用 externals 属性来帮忙：1234567{ externals: { // require(&quot;jquery&quot;) 是引用自外部模块的 // 对应全局变量 jQuery &quot;jquery&quot;: &quot;jQuery&quot; }} 需要留意的是，得确保 CDN 文件必须在 webpack 打包文件引入之前先引入。我们倒也可以使用 script.js 在脚本中来加载我们的模块：1234var $script = require(&quot;scriptjs&quot;);$script(&quot;//ajax.googleapis.com/ajax/libs/jquery/2.0.0/jquery.min.js&quot;, function() { $(&apos;body&apos;).html(&apos;It works!&apos;)}); 五. 与 grunt/gulp 配合以 gulp 为示例，我们可以这样混搭：123456789101112gulp.task(&quot;webpack&quot;, function(callback) { // run webpack webpack({ // configuration }, function(err, stats) { if(err) throw new gutil.PluginError(&quot;webpack&quot;, err); gutil.log(&quot;[webpack]&quot;, stats.toString({ // output options })); callback(); });}); 当然我们只需要把配置写到 webpack({ … }) 中去即可，无须再写 webpack.config.js 了。更多参照信息请参阅：grunt配置 / gulp配置 。 六. React 相关⑴ 推荐使用 npm install react 的形式来安装并引用 React 模块，而不是直接使用编译后的 react.js，这样最终编译出来的 React 部分的脚本会减少 10-20 kb左右的大小。⑵ react-hot-loader 是一款非常好用的 React 热插拔的加载插件，通过它可以实现修改-运行同步的效果，配合 webpack-dev-server 使用更佳！","link":"/2019/07/13/React/webpack/"},{"title":"this","text":"javaScript的thisthis的常见绑定形式1.默认绑定2.隐式绑定3.显示绑定4.new绑定 判断this 现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条规则。可以按照下面的顺序来进行判断: 函数是否在new中调用(new绑定)?如果是的话this绑定的是新创建的对象。 var bar = new foo() 函数是否通过call、apply(显式绑定)或者硬绑定调用?如果是的话，this绑定的是 指定的对象。 var bar = foo.call(obj2) 函数是否在某个上下文对象中调用(隐式绑定)?如果是的话，this 绑定的是那个上 下文对象。 var bar = obj1.foo() 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到 全局对象。 var bar = foo() 关于call、apply、bind的区别： |函数|参数|返回| |:—–:|:—–:|:—–:| |call|第一个参数是context,后边可传多个参数|立即调用| |apply|第一个参数是context,后边是一个数组|立即调用| |bind|第一个参数是context,后边可传多个参数|返回对应函数| 在弄清楚这些绑定之前来弄清楚几个概念调用栈和调用位置下面我们来看看到底什么是调用栈和调用位置: 123456789101112131415function baz() {// 当前调用栈是:baz// 因此，当前调用位置是全局作用域 console.log( &quot;baz&quot; );bar(); // &lt;-- bar 的调用位置 }function bar() {// 当前调用栈是 baz -&gt; bar// 因此，当前调用位置在 baz 中 console.log( &quot;bar&quot; );foo(); // &lt;-- foo 的调用位置 }function foo() {// 当前调用栈是 baz -&gt; bar -&gt; foo // 因此，当前调用位置在 bar 中 console.log( &quot;foo&quot; ); }baz(); // &lt;-- baz 的调用位置 上面的代码让我们初步明白了调用栈，和调用位置 默认绑定(指绑定全局变量)思考下面的代码12345function foo() { console.log( this.a );}var a = 2;foo(); // 2 上面函数的当前当前调用位置是全局作用域，所以this默认绑定的是window如果使用严格模式(strict mode)，那么全局对象将无法使用默认绑定，因此 this 会绑定 到 undefined:12345function foo() { &quot;use strict&quot;; console.log( this.a ); }var a = 2;foo(); // TypeError: this is undefined 隐式绑定在一些复杂的结构中我们经常会碰到隐式绑定先来看下面的代码：12345678function foo() { console.log( this.a );}var obj = { a: 2, foo: foo};obj.foo(); // 2 foo函数绑定在了obj下边的foo属性上边，所以他的当前调用位置在obj中所以this指向obj。 对象属性引用链中只有最顶层或者说最后一层会影响调用位置123456789101112function foo() { console.log( this.a );}var obj2 = { a: 42, foo: foo};var obj1 = { a: 2, obj2: obj2};obj1.obj2.foo(); // 42 隐式丢失看下面的例子：123456789function foo() { console.log( this.a );}var obj = { a: 2, foo: foo};var bar = obj.foo; // 函数别名!var a = &quot;oops, global&quot;; // a 是全局对象的属性 bar(); // &quot;oops, global&quot; 是不是结果让人诧异虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是 foo 函数本身，因此此时的 bar() 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。（这是你不知道的JavaScript上中的解释，但是我感觉没有说服力，后面会查明真象） 以形参传入其实就是隐式赋值1234567891011121314function foo() { console.log( this.a );}function doFoo(fn) { // fn 其实引用的是 foo fn(); // &lt;-- 调用位置!}var obj = { a: 2, foo: foo};var a = &quot;oops, global&quot;; // a 是全局对象的属性doFoo( obj.foo ); // &quot;oops, global&quot; 如果把函数传入语言内置的函数而不是传入你自己声明的函数，也会隐式赋值 1234567function foo() { console.log( this.a );}var obj = { a: 2,foo: foo };var a = &quot;oops, global&quot;; // a 是全局对象的属性setTimeout( obj.foo, 100 ); // &quot;oops, global&quot; 通过上面的代码可以看出来不做显示绑定还是比较危险的而且隐式绑定还是很危险的 显式绑定 硬绑定（常用的是call，apply，bind）三种方式的使用 call 12345678910111213function foo() { console.log( this.a );}var obj = { a:2};var bar = function() { foo.call( obj );}; bar(); // 2 setTimeout( bar, 100 ); // 2// 硬绑定的 bar 不可能再修改它的this bar.call( window ); // 2 apply 123456789101112function foo(something) { console.log( this.a, something ); return this.a + something;}var obj = { a:2};var bar = function() { return foo.apply( obj, arguments );};var b = bar( 3 ); // 2 3console.log( b ); // 5 另一种使用方法是创建一个 i 可以重复使用的辅助函数:12345678910111213141516function foo(something) { console.log( this.a, something ); return this.a + something;}// 简单的辅助绑定函数function bind(fn, obj) { return function() { return fn.apply( obj, arguments ); };}var obj = { a:2};var bar = bind( foo, obj );var b = bar( 3 ); // 2 3console.log( b ); // 5 bind 在ES5中内置了bind方法 12345678910function foo(something) { console.log( this.a, something ); return this.a + something;}var obj = { a:2};var bar = foo.bind( obj );var b = bar( 3 ); // 2 3console.log( b ); // 5 这里说明一下bind返回的是方法名要想运行样加();比如foo.bind( obj )();这才是运行状态；(bind(..) 会返回一个硬编码的新函数，它会把参数设置为 this 的上下文并调用原始函数)你不知道的JavaScript中的解释 API调用的“上下文” 123456789function foo(el) { console.log( el, this.id );}var obj = { id: &quot;awesome&quot;};// 调用 foo(..) 时把 this 绑定到 obj[1, 2, 3].forEach( foo, obj );// 1 awesome 2 awesome 3 awesome 有没有一丝懵逼，看解释第三方库的许多函数，以及 JavaScript 语言和宿主环境中许多新的内置函数，都提供了一 个可选的参数，通常被称为“上下文”(context)，其作用和 bind(..) 一样，确保你的回调 函数使用指定的 this。这些函数实际上就是通过 call(..) 或者 apply(..) 实现了显式绑定，这样你可以少些一些 代码。 ###new绑定 在 JavaScript 中，构造函数只是一些 使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上， 它们甚至都不能说是一种特殊的函数类型，它们只是被 new 操作符调用的普通函数而已。使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。 创建(或者说构造)一个全新的对象。 这个新对象会被执行[[原型]]连接。 这个新对象会绑定到函数调用的this。 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。思考下面的代码:12345function foo(a) { this.a = a;}var bar = new foo(2);console.log( bar.a ); // 2 使用 new 来调用 foo(..) 时，我们会构造一个新对象并把它绑定到 foo(..) 调用中的 this 上。new 是最后一种可以影响函数调用时 this 绑定行为的方法，我们称之为 new 绑定。 ###优先级1.先比较一下隐式绑定和显示绑定 看下面代码 12345678910111213141516function foo() { console.log( this.a );}var obj1 = { a: 2, foo: foo};var obj2 = { a: 3, foo: foo};obj1.foo(); // 2obj2.foo(); // 3obj1.foo.call( obj2 ); // 3obj2.foo.call( obj1 ); // 2 可以明显的看到显示绑定比隐式绑定的优先级高 2.现在比较一下new 绑定和隐式绑定看如下代码1234567891011121314function foo(something) { this.a = something;}var obj1 = { foo: foo};var obj2 = {};obj1.foo( 2 );console.log( obj1.a ); // 2obj1.foo.call( obj2, 3 );console.log( obj2.a ); // 3var bar = new obj1.foo( 4 );console.log( obj1.a ); // 2console.log( bar.a ); // 4 可以看到 new 绑定比隐式绑定优先级高3.new 绑定和显式绑定在看代码之前先回忆一下硬绑定是如何工作的。Function.prototype.bind(..) 会创建一个 新的包装函数，这个函数会忽略它当前的 this 绑定(无论绑定的对象是什么)，并把我们 提供的对象绑定到 this 上。看下面的代码123456789function foo(something) { this.a = something;}var obj1 = {};var bar = foo.bind( obj1 );bar( 2 );console.log( obj1.a ); // 2var baz = new bar(3);console.log( obj1.a ); // 2console.log( baz.a ); // 3 出乎意料! bar 被硬绑定到 obj1 上，但是 new修改为 3。相反，new 修改了硬绑定(到 obj1 的)调用 bar(..) 中的 this。因为使用了 new 绑定，我们得到了一个名字为 baz 的新对象，并且 baz.a 的值是 3。ES5 中内置的 Function.prototype.bind(..) 更加复杂。下面是 MDN 提供的一种bind(..) 实现12345678910111213141516171819202122232425if (!Function.prototype.bind) { Function.prototype.bind = function(oThis) { if (typeof this !== &quot;function&quot;) { // 与 ECMAScript 5 最接近的 // 内部 IsCallable 函数 throw new TypeError(&quot;Function.prototype.bind - what is trying &quot; +&quot;to be bound is not callable&quot;); } var aArgs = Array.prototype.slice.call( arguments, 1 ), fToBind = this, fNOP = function(){}, fBound = function(){ return fToBind.apply( ( this instanceof fNOP &amp;&amp; oThis ? this : oThis ), aArgs.concat( Array.prototype.slice.call( arguments ) ); }; fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound; };} 这种 bind(..) 是一种 polyfill 代码(polyfill 就是我们常说的刮墙用的腻 子，polyfill 代码主要用于旧浏览器的兼容，比如说在旧的浏览器中并没 有内置 bind 函数，因此可以使用 polyfill 代码在旧浏览器中实现新的功 能)，对于 new 使用的硬绑定函数来说，这段 polyfill 代码和 ES5 内置的 bind(..) 函数并不完全相同(后面会介绍为什么要在 new 中使用硬绑定函 数)。由于 polyfill 并不是内置函数，所以无法创建一个不包含 .prototype 的函数，因此会具有一些副作用。如果你要在 new 中使用硬绑定函数并且依 赖 polyfill 代码的话，一定要非常小心。 ###绑定例外 ####1.把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind看下面代码12345function foo() { console.log( this.a );}var a = 2;foo.call( null ); // 2 应用场景使用 apply(..) 来“展开”一个数组12345678function foo(a,b) { console.log( &quot;a:&quot; + a + &quot;, b:&quot; + b );}// 把数组“展开”成参数foo.apply( null, [2, 3] ); // a:2, b:3// 使用 bind(..) 进行柯里化var bar = foo.bind( null, 2 );bar( 3 ); // a:2, b:3 ####2.间接引用另一个需要注意的是，你有可能(有意或者无意地)创建一个函数的“间接引用”，在这 种情况下，调用这个函数会应用默认绑定规则。 间接引用最容易在赋值时发生:1234567891011function foo() { console.log( this.a );}var a = 2;var o = { a: 3, foo: foo };var p = { a: 4 };o.foo(); // 3(p.foo = o.foo)(); // 2 赋值表达式 p.foo = o.foo 的返回值是目标函数的引用，因此调用位置是 foo() 而不是 p.foo() 或者 o.foo()。根据我们之前说过的，这里会应用默认绑定。注意:对于默认绑定来说，决定 this 绑定对象的并不是调用位置是否处于严格模式，而是 函数体是否处于严格模式。如果函数体处于严格模式，this 会被绑定到 undefined，否则 this 会被绑定到全局对象。 ####3.软绑定之前我们已经看到过，硬绑定这种方式可以把 this 强制绑定到指定的对象(除了使用 new 时)，防止函数调用应用默认绑定规则。问题在于，硬绑定会大大降低函数的灵活性，使 用硬绑定之后就无法使用隐式绑定或者显式绑定来修改 this。如果可以给默认绑定指定一个全局对象和 undefined 以外的值，那就可以实现和硬绑定相 同的效果，同时保留隐式绑定或者显式绑定修改 this 的能力。可以通过一种被称为软绑定的方法来实现我们想要的效果:123456789101112131415if (!Function.prototype.softBind) { Function.prototype.softBind = function(obj) { var fn = this; // 捕获所有 curried 参数 var curried = [].slice.call( arguments, 1 ); var bound = function() { return fn.apply( (!this || this === (window || global)) ? obj : this; curried.concat.apply( curried, arguments ); }; bound.prototype = Object.create( fn.prototype ); return bound; };}除了软绑定之外，softBind(..) 的其他原理和 ES5 内置的 bind(..) 类似。它会对指定的函 数进行封装，首先检查调用时的 this，如果 this 绑定到全局对象或者 undefined，那就把 指定的默认对象 obj 绑定到 this，否则不会修改 this。此外，这段代码还支持可选的柯里化 下面我们看看 softBind 是否实现了软绑定功能:12345678910111213function foo() { console.log(&quot;name: &quot; + this.name);}var obj = { name: &quot;obj&quot; }, obj2 = { name: &quot;obj2&quot; }, obj3 = { name: &quot;obj3&quot; };var fooOBJ = foo.softBind( obj ); fooOBJ(); // name: obj obj2.foo = foo.softBind(obj); obj2.foo(); // name: obj2 &lt;---- 看!!! fooOBJ.call( obj3 ); // name: obj3 &lt;---- 看! setTimeout( obj2.foo, 10 ); // name: obj &lt;---- 应用了软绑定 可以看到，软绑定版本的 foo() 可以手动将 this 绑定到 obj2 或者 obj3 上，但如果应用默认绑定，则会将 this 绑定到 obj。 ###this词法（箭头函数没有执行上下为this指向父级）箭头函数不使用 this 的四种标准规则，而是根据外层(函数或者全局)作用域来决定 this看下面的代码123456789101112131415function foo() {// 返回一个箭头函数 return (a) =&gt; { //this 继承自 foo() console.log( this.a ); };}var obj1 = { a:2};var obj2 = { a:3};var bar = foo.call( obj1 );bar.call( obj2 ); // 2, 不是 3 ! 箭头函数最常用于回调函数中，例如事件处理器或者定时器:12345678910function foo() { setTimeout(() =&gt; { // 这里的 this 在此法上继承自 foo() console.log( this.a ); },100);}var obj = { a:2 };foo.call( obj ); // 2 上面代码不用箭头函数的写法12345678910function foo() {var self = this; // lexical capture of this setTimeout( function(){ console.log( self.a ); }, 100 );}var obj = { a: 2};foo.call( obj ); // 2","link":"/2016/08/25/javaScript/this/"},{"title":"Array.prototype.slice应用和原理探析","text":"Array.prototype.slice应用和原理探析问题由来Array.prototype.slice常见于两种调用场景： 一是对函数arguments对象的转换Array.prototype.slice.call(arguments) 二是类似jQuery原型对象的定义中toArray: function() {return slice.call( this, 0 );}, 有必要探究一番其使用方式和内部原理。 问题拆解Array.prototype.slice作为Array.prototype对象的一个方法，对其调用在API中有详细说明，并不费解，对Array.prototype.slice的疑问可拆解为两个方面：一是该函数究竟返回什么对象？二是该函数可应用于什么对象？即非数组对象需要满足什么条件才能借用(复用)该函数？ 该函数究竟返回什么对象为了探究返回对象的类型信息，写一个简单的对象工具集合：123456789var objs = { &quot;descType&quot;:function(o){ console.info(o); console.info(&quot;typeof o:&quot; + (typeof o)); console.info(&quot;o.constructor:&quot; + (o.constructor)); console.info(&quot;o instanceof Object:&quot; + (o instanceof Object)); console.info(&quot;o instanceof Array:&quot; + (o instanceof Array)); } }; 然后测试几个简单的例子：123456var v = [&apos;a&apos;,true,9].slice(0); objs.descType(v);// typeof o:object// o.constructor:function Array() { [native code] }// o instanceof Object:true// o instanceof Array:true 数组对象自身上调用slice方法当然不必再使用“var v = Array.prototype.slice.call([‘a’,true,9]);”这种方法，虽然是可以这样用的，结果表明返回的对象的确是Array类型的对象。 该函数可应用于什么对象1 既然该方法是作为Array.prototype的方法，那么数组对象本身当然可以调用该方法。 2 Arguments类型的对象可正确调用该函数。 同样用一个简单的例子测试下arguments对象借用该函数后的对象类型。12345678910111213141516171819function f() { objs.descType(arguments); var newArg = Array.prototype.slice.call(arguments, 0); objs.descType(newArg); } f(&apos;aa&apos;,&apos;bb&apos;,&apos;cc&apos;);// [&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;] // typeof o:object /// o.constructor:function Object() { [native code] } // o instanceof Object:true // o instanceof Array:false // [&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;] // typeof o:object // o.constructor:function Array() { [native code] } // o instanceof Object:true // o instanceof Array:true 可以看到arguments对象本身并不是Array类型的–o instanceof Array:false，进一步展开该对象细节，可以看到其属性列表如下： 123456[&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;] 0:&quot;aa&quot; 1:&quot;bb&quot; 2:&quot;cc&quot; callee:function f() length:3 有length属性，有’0’,’1’,’2’属性，有’callee’属性，是一个Arguments类型的一个对象实例。而经过Array.prototype.slice.call调用后返回的对象就是一个真真正正的Array对象： 12345[&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;] 0:&quot;aa&quot; 1:&quot;bb&quot; 2:&quot;cc&quot; length:3 这说明arguments对象和转换后的array对象非常类似–不仅属性类似，连用法也类似，比如arguments对象也支持[]运算符调用其属性值(其实本质是对象元素访问的通用语法，只不过属性名刚好为转换为字符串的整数而已)。所以结论是在js语言中，对arguments对象调用Array.prototype.slice.call(arguments, 0)纯属“闲的蛋疼”的做法(除非设计的函数用法非常的动态，比如需要对参数做shift等之类的数组操作)。 那么除了arguments对象之外，其他类型的对象可以借用Array.prototype.slice函数么？继续简单的测试几个例子：1234567objs.descType(Array.prototype.slice.call(true,0)); objs.descType(Array.prototype.slice.call(&apos;abc&apos;,0)); objs.descType(Array.prototype.slice.call(256,0)); objs.descType(Array.prototype.slice.call({},0)); objs.descType(Array.prototype.slice.call(undefined,0)); objs.descType(Array.prototype.slice.call(null,0)); objs.descType(Array.prototype.slice.call(NaN,0)); 对undefined和null调用slice抛出异常，这是预期的行为，对NaN/true/256/{}返回一个空数组对象，对字符串’abc’返回一个数组：[“a”, “b”, “c”]，现在的重点是对对象调用的探究，传入一个初始化为空的对象直接量返回的是一个空数组对象，而上面测试在arguments对象上调用slice返回一个正常的数组–两者有何区别？ 一个很容易联想的点子是该调用对象应该具备length属性才可以被slice正确处理，测试一下：1objs.descType(Array.prototype.slice.call({&apos;length&apos;:5},0)); 结果果然是一个length值为5的数组对象，但其中5个元素值都为undefined。那么更进一步的想法应该是：调用对象除了有length属性之外，是不是也应该有索引属性名？即自动转换为字符类型的整数数字属性名？再试一下：1objs.descType(Array.prototype.slice.call({&apos;length&apos;:5,&apos;0&apos;:&apos;gebilaowang&apos;,&apos;1&apos;:&apos;ximenqin&apos;},0)); ok，大功告成，结果果然是预期数组：[“gebilaowang”,”ximenqin”,undefined,undefined,undefined]。因此结论是：只有具备”可转换为数值型的length属性”并且同时具备”索引属性”的对象才可以正确被slice函数处理(返回或者说转换为预期数组)，这种类型的对象经过查阅果然有一种专属称谓–Array-like Object。 3 Array-like对象可正确调用该函数。现在来探究jQuery中对Array.prototype.slice方法的使用场景，jQuery对各种原型方法的应用当然是非常牛逼的甚至达到炉火纯青的境界，其实jQuery对象本身就是一个Array-like对象，因为其有length属性，也有索引属性，分析其初始化构造函数(1.6.1版本)即可明白(特别注意对this.length和this[index]属性的设置)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109jQuery.prototype.init: function( selector, context, rootjQuery ) { var match, elem, ret, doc; // Handle $(&quot;&quot;), $(null), or $(undefined) if ( !selector ) { return this; } // Handle $(DOMElement) if ( selector.nodeType ) { this.context = this[0] = selector; this.length = 1; return this; } // The body element only exists once, optimize finding it if ( selector === &quot;body&quot; &amp;&amp; !context &amp;&amp; document.body ) { this.context = document; this[0] = document.body; this.selector = selector; this.length = 1; return this; } // Handle HTML strings if ( typeof selector === &quot;string&quot; ) { // Are we dealing with HTML string or an ID? if ( selector.charAt(0) === &quot;&lt;&quot; &amp;&amp; selector.charAt( selector.length - 1 ) === &quot;&gt;&quot; &amp;&amp; selector.length &gt;= 3 ) { // Assume that strings that start and end with &lt;&gt; are HTML and skip the regex check match = [ null, selector, null ]; } else { match = quickExpr.exec( selector ); } // Verify a match, and that no context was specified for #id if ( match &amp;&amp; (match[1] || !context) ) { // HANDLE: $(html) -&gt; $(array) if ( match[1] ) { context = context instanceof jQuery ? context[0] : context; doc = (context ? context.ownerDocument || context : document); // If a single string is passed in and it&apos;s a single tag // just do a createElement and skip the rest ret = rsingleTag.exec( selector ); if ( ret ) { if ( jQuery.isPlainObject( context ) ) { selector = [ document.createElement( ret[1] ) ]; jQuery.fn.attr.call( selector, context, true ); } else { selector = [ doc.createElement( ret[1] ) ]; } } else { ret = jQuery.buildFragment( [ match[1] ], [ doc ] ); selector = (ret.cacheable ? jQuery.clone(ret.fragment) : ret.fragment).childNodes; } return jQuery.merge( this, selector ); // HANDLE: $(&quot;#id&quot;) } else { elem = document.getElementById( match[2] ); // Check parentNode to catch when Blackberry 4.6 returns // nodes that are no longer in the document #6963 if ( elem &amp;&amp; elem.parentNode ) { // Handle the case where IE and Opera return items // by name instead of ID if ( elem.id !== match[2] ) { return rootjQuery.find( selector ); } // Otherwise, we inject the element directly into the jQuery object this.length = 1; this[0] = elem; } this.context = document; this.selector = selector; return this; } // HANDLE: $(expr, $(...)) } else if ( !context || context.jquery ) { return (context || rootjQuery).find( selector ); // HANDLE: $(expr, context) // (which is just equivalent to: $(context).find(expr) } else { return this.constructor( context ).find( selector ); } // HANDLE: $(function) // Shortcut for document ready } else if ( jQuery.isFunction( selector ) ) { return rootjQuery.ready( selector ); } if (selector.selector !== undefined) { this.selector = selector.selector; this.context = selector.context; } return jQuery.makeArray( selector, this ); }, 这是分析并理解jQuery背后原理的最基础最前提的一步。 原理探析123456789function slice(start, end) { var startToUse = start || 0, endToUse = end || ToUint32(this.length), result = []; for(var i = startToUse; i &lt; endToUse; i++) { result.push(this[i]); } return result; }","link":"/2016/08/25/javaScript/slice/"},{"title":"路由实现原理解析","text":"路由实现原理解析原文地址 在单页应用上，前端路由并不陌生。很多前端框架也会有独立开发或推荐配套使用的路由系统。那么，当我们在谈前端路由的时候，还可以谈些什么？本文将简要分析并实现一个的前端路由，并对 react-router 进行分析。 一个极简前端路由实现说一下前端路由实现的简要原理，以 hash 形式（也可以使用 History API 来处理）为例，当 url 的 hash 发生变化时，触发 hashchange 注册的回调，回调中去进行不同的操作，进行不同的内容的展示。直接看代码或许更直观。1234567891011121314151617function Router() { this.routes = {}; this.currentUrl = &apos;&apos;;}Router.prototype.route = function(path, callback) { this.routes[path] = callback || function(){};};Router.prototype.refresh = function() { this.currentUrl = location.hash.slice(1) || &apos;/&apos;; this.routes[this.currentUrl]();};Router.prototype.init = function() { window.addEventListener(&apos;load&apos;, this.refresh.bind(this), false); window.addEventListener(&apos;hashchange&apos;, this.refresh.bind(this), false);}window.Router = new Router();window.Router.init(); 上面路由系统 Router 对象实现，主要提供三个方法123456789101112131415161718192021222324init 监听浏览器 url hash 更新事件route 存储路由更新时的回调到回调数组routes中，回调函数将负责对页面的更新refresh 执行当前url对应的回调函数，更新页面Router 调用方式以及呈现效果如下：点击触发 url 的 hash 改变，并对应地更新内容（这里为 body 背景色）&lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#/&quot;&gt;turn white&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#/blue&quot;&gt;turn blue&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#/green&quot;&gt;turn green&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;var content = document.querySelector(&apos;body&apos;);// change Page anythingfunction changeBgColor(color) { content.style.backgroundColor = color;}Router.route(&apos;/&apos;, function() { changeBgColor(&apos;white&apos;);});Router.route(&apos;/blue&apos;, function() { changeBgColor(&apos;blue&apos;);});Router.route(&apos;/green&apos;, function() { changeBgColor(&apos;green&apos;);}); 以上为一个前端路由的简单实现，点击查看完整代码，虽然简单，但实际上很多路由系统的根基都立于此，其他路由系统主要是对自身使用的框架机制的进行配套及优化，如与 react 配套的 react-router。 react-router 分析react-router 与 history 结合形式 react-router 是基于 history 模块提供的 api 进行开发的，结合的形式本文记为 包装方式。所以在开始对其分析之前，先举一个简单的例子来说明如何进行对象的包装。1234567891011121314151617181920212223242526272829303132333435363738// 原对象var historyModule = { listener: [], listen: function (listener) { this.listener.push(listener); console.log(&apos;historyModule listen..&apos;) }, updateLocation: function(){ this.listener.forEach(function(listener){ listener(&apos;new localtion&apos;); }) }}// Router 将使用 historyModule 对象，并对其包装var Router = { source: {}, init: function(source){ this.source = source; }, // 对 historyModule的listen进行了一层包装 listen: function(listener) { return this.source.listen(function(location){ console.log(&apos;Router listen tirgger.&apos;); listener(location); }) }}// 将 historyModule 注入进 Router 中Router.init(historyModule);// Router 注册监听Router.listen(function(location){ console.log(location + &apos;-&gt; Router setState.&apos;);})// historyModule 触发回调historyModule.updateLocation();返回：22 可看到 historyModule 中含有机制：historyModule.updateLocation() -&gt; listener( )，Router 通过对其进行包装开发，针对 historyModule 的机制对 Router 也起到了作用，即historyModule.updateLocation() 将触发 Router.listen 中的回调函数 。点击查看完整代码这种包装形式能够充分利用原对象（historyModule ）的内部机制，减少开发成本，也更好的分离包装函数（Router）的逻辑，减少对原对象的影响。 react-router 使用方式react-router 以 react component 的组件方式提供 API， 包含 Router，Route，Redirect，Link 等等，这样能够充分利用 react component 提供的生命周期特性，同时也让定义路由跟写 react component 达到统一，如下1234567891011render(( &lt;Router history={browserHistory}&gt; &lt;Route path=&quot;/&quot; component={App}&gt; &lt;Route path=&quot;about&quot; component={About}/&gt; &lt;Route path=&quot;users&quot; component={Users}&gt; &lt;Route path=&quot;/user/:userId&quot; component={User}/&gt; &lt;/Route&gt; &lt;Route path=&quot;*&quot; component={NoMatch}/&gt; &lt;/Route&gt; &lt;/Router&gt;), document.body) 就这样，声明了一份含有 path to component 的各个映射的路由表。react-router 还提供的 Link 组件（如下），作为提供更新 url 的途径，触发 Link 后最终将通过如上面定义的路由表进行匹配，并拿到对应的 component 及 state 进行 render 渲染页面。1&lt;Link to={`/user/89757`}&gt;&apos;joey&apos;&lt;/Link&gt; 这里不细讲 react-router 的使用，详情可见：https://github.com/reactjs/react-router 从点击 Link 到 render 对应 component ，路由中发生了什么 为何能够触发 render component ？ 主要是因为触发了 react setState 的方法从而能够触发 render component。从顶层组件 Router 出发（下面代码从 react-router/Router 中摘取），可看到 Router 在 react component 生命周期之组件被挂载前 componentWillMount 中使用 this.history.listen 去注册了 url 更新的回调函数。回调函数将在 url 更新时触发，回调中的 setState 起到 render 了新的 component 的作用。1234567891011121314Router.prototype.componentWillMount = function componentWillMount() { // .. 省略其他 var createHistory = this.props.history; this.history = _useRoutes2[&apos;default&apos;](createHistory)({ routes: _RouteUtils.createRoutes(routes || children), parseQueryString: parseQueryString, stringifyQuery: stringifyQuery }); this._unlisten = this.history.listen(function (error, state) { _this.setState(state, _this.props.onUpdate); }); }; 上面的 _useRoutes2 对 history 操作便是对其做一层包装，所以调用的 this.history 实际为包装以后的对象，该对象含有 _useRoutes2 中的 listen 方法，如下12345678function listen(listener) { return history.listen(function (location) { // .. 省略其他 match(location, function (error, redirectLocation, nextState) { listener(null, nextState); }); });} 可看到，上面代码中，主要分为两部分 使用了 history 模块的 listen 注册了一个含有 setState 的回调函数（这样就能使用 history 模块中的机制）回调中的 match 方法为 react-router 所特有，match 函数根据当前 location 以及前面写的 Route 路由表匹配出对应的路由子集得到新的路由状态值 state，具体实现可见 react-router/matchRoutes ，再根据 state 得到对应的 component ，最终执行了 match 中的回调 listener(null, nextState) ，即执行了 Router 中的监听回调（setState），从而更新了展示。以上，为起始注册的监听，及回调的作用。 如何触发监听的回调函数的执行？ 这里还得从如何更新 url 说起。一般来说，url 更新主要有两种方式：简单的 hash 更新或使用 history api 进行地址更新。在 react-router 中，其提供了 Link 组件，该组件能在 render 中使用，最终会表现为 a 标签，并将 Link 中的各个参数组合放它的 href 属性中。可以从 react-router/ Link 中看到，对该组件的点击事件进行了阻止了浏览器的默认跳转行为，而改用 history 模块的 pushState 方法去触发 url 更新。1234567891011121314151617Link.prototype.render = function render() { // .. 省略其他 props.onClick = function (e) { return _this.handleClick(e); }; if (history) { // .. 省略其他 props.href = history.createHref(to, query); } return _react2[&apos;default&apos;].createElement(&apos;a&apos;, props);};Link.prototype.handleClick = function handleClick(event) { // .. 省略其他 event.preventDefault(); this.context.history.pushState(this.props.state, this.props.to, this.props.query);}; 对 history 模块的 pushState 方法对 url 的更新形式，同样分为两种，分别在 history/createBrowserHistory 及 history/createHashHistory 各自的 finishTransition 中，如 history/createBrowserHistory 中使用的是 window.history.replaceState(historyState, null, path); 而 history/createHashHistory 则使用 window.location.hash = url，调用哪个是根据我们一开始创建 history 的方式。 更新 url 的显示是一部分，另一部分是根据 url 去更新展示，也就是触发前面的监听。这是在前面 finishTransition 更新 url 之后实现的，调用的是 history/createHistory 中的 updateLocation 方法，changeListeners 中为 history/createHistory 中的 listen 中所添加的，如下1234567891011function updateLocation(newLocation) { // 示意代码 location = newLocation; changeListeners.forEach(function (listener) { listener(location); });}function listen(listener) { // 示意代码 changeListeners.push(listener);} ###总结 可以将以上 react-router 的整个包装闭环总结为 回调函数：含有能够更新 react UI 的 react setState 方法。注册回调：在 Router componentWillMount 中使用 history.listen 注册的回调函数，最终放在 history 模块的 回调函数数组 changeListeners 中。触发回调：Link 点击触发 history 中回调函数数组 changeListeners 的执行，从而触发原来 listen 中的 setState 方法，更新了页面至于前进与后退的实现，是通过监听 popstate 以及 hashchange 的事件，当前进或后退 url 更新时，触发这两个事件的回调函数，回调的执行方式 Link 大致相同，最终同样更新了 UI ，这里就不再说明。 react-router 主要是利用底层 history 模块的机制，通过结合 react 的架构机制做一层包装，实际自身的内容并不多，但其包装的思想笔者认为很值得学习，有兴趣的建议阅读下源码，相信会有其他收获。","link":"/2016/08/25/javaScript/router/"},{"title":"packagejson文件详解","text":"packagejson文件详解目录 123456789101112131. 概述2. scripts字段3. dependencies字段，devDependencies字段4. peerDependencies5. bin字段6. main字段7. config 字段8. 其他9. browser字段10. engines 字段11. man字段12. preferGlobal字段13. style字段 1. 概述每个项目的根目录下面，一般都有一个package.json文件，定义了这个项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等元数据）。npm install命令根据这个配置文件，自动下载所需的模块，也就是配置项目所需的运行和开发环境。 下面是一个最简单的package.json文件，只定义两项元数据：项目名称和项目版本。1234{ &quot;name&quot; : &quot;xxx&quot;, &quot;version&quot; : &quot;0.0.0&quot;,} package.json文件就是一个JSON对象，该对象的每一个成员就是当前项目的一项设置。比如name就是项目名称，version是版本（遵守“大版本.次要版本.小版本”的格式）。 下面是一个更完整的package.json文件。1234567891011121314151617181920212223242526272829303132333435{ &quot;name&quot;: &quot;Hello World&quot;, &quot;version&quot;: &quot;0.0.1&quot;, &quot;author&quot;: &quot;张三&quot;, &quot;description&quot;: &quot;第一个node.js程序&quot;, &quot;keywords&quot;:[&quot;node.js&quot;,&quot;javascript&quot;], &quot;repository&quot;: { &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;https://path/to/url&quot; }, &quot;license&quot;:&quot;MIT&quot;, &quot;engines&quot;: {&quot;node&quot;: &quot;0.10.x&quot;}, &quot;bugs&quot;:{&quot;url&quot;:&quot;http://path/to/bug&quot;,&quot;email&quot;:&quot;bug@example.com&quot;}, &quot;contributors&quot;:[{&quot;name&quot;:&quot;李四&quot;,&quot;email&quot;:&quot;lisi@example.com&quot;}], &quot;scripts&quot;: { &quot;start&quot;: &quot;node index.js&quot; }, &quot;dependencies&quot;: { &quot;express&quot;: &quot;latest&quot;, &quot;mongoose&quot;: &quot;~3.8.3&quot;, &quot;handlebars-runtime&quot;: &quot;~1.0.12&quot;, &quot;express3-handlebars&quot;: &quot;~0.5.0&quot;, &quot;MD5&quot;: &quot;~1.2.0&quot; }, &quot;devDependencies&quot;: { &quot;bower&quot;: &quot;~1.2.8&quot;, &quot;grunt&quot;: &quot;~0.4.1&quot;, &quot;grunt-contrib-concat&quot;: &quot;~0.3.0&quot;, &quot;grunt-contrib-jshint&quot;: &quot;~0.7.2&quot;, &quot;grunt-contrib-uglify&quot;: &quot;~0.2.7&quot;, &quot;grunt-contrib-clean&quot;: &quot;~0.5.0&quot;, &quot;browserify&quot;: &quot;2.36.1&quot;, &quot;grunt-browserify&quot;: &quot;~1.3.0&quot;, }} 下面详细解释package.json文件的各个字段。 2. scripts字段scripts指定了运行脚本命令的npm命令行缩写，比如start指定了运行npm run start时，所要执行的命令。 下面的设置指定了npm run preinstall、npm run postinstall、npm run start、npm run test时，所要执行的命令。 123456&quot;scripts&quot;: { &quot;preinstall&quot;: &quot;echo here it comes!&quot;, &quot;postinstall&quot;: &quot;echo there it goes!&quot;, &quot;start&quot;: &quot;node index.js&quot;, &quot;test&quot;: &quot;tap test/*.js&quot;} 3. dependencies字段，devDependencies字段dependencies字段指定了项目运行所依赖的模块，devDependencies指定项目开发所需要的模块。 它们都指向一个对象。该对象的各个成员，分别由模块名和对应的版本要求组成，表示依赖的模块及其版本范围。 123456{ &quot;devDependencies&quot;: { &quot;browserify&quot;: &quot;~13.0.0&quot;, &quot;karma-browserify&quot;: &quot;~5.0.1&quot; }} 对应的版本可以加上各种限定，主要有以下几种 指定版本：比如1.2.2，遵循“大版本.次要版本.小版本”的格式规定，安装时只安装指定版本。波浪号（tilde）+指定版本：比如~1.2.2，表示安装1.2.x的最新版本（不低于1.2.2），但是不安装1.3.x，也就是说安装时不改变大版本号和次要版本号。插入号（caret）+指定版本：比如ˆ1.2.2，表示安装1.x.x的最新版本（不低于1.2.2），但是不安装2.x.x，也就是说安装时不改变大版本号。需要注意的是，如果大版本号为0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。latest：安装最新版本。 package.json文件可以手工编写，也可以使用npm init命令自动生成。 1$ npm init 这个命令采用互动方式，要求用户回答一些问题，然后在当前目录生成一个基本的package.json文件。所有问题之中，只有项目名称（name）和项目版本（version）是必填的，其他都是选填的。 有了package.json文件，直接使用npm install命令，就会在当前目录中安装所需要的模块。 1$ npm install 如果一个模块不在package.json文件之中，可以单独安装这个模块，并使用相应的参数，将其写入package.json文件之中。 12$ npm install express --save$ npm install express --save-dev 上面代码表示单独安装express模块，–save参数表示将该模块写入dependencies属性，–save-dev表示将该模块写入devDependencies属性。 4. peerDependencies有时，你的项目和所依赖的模块，都会同时依赖另一个模块，但是所依赖的版本不一样。比如，你的项目依赖A模块和B模块的1.0版，而A模块本身又依赖B模块的2.0版。 大多数情况下，这不构成问题，B模块的两个版本可以并存，同时运行。但是，有一种情况，会出现问题，就是这种依赖关系将暴露给用户。 最典型的场景就是插件，比如A模块是B模块的插件。用户安装的B模块是1.0版本，但是A插件只能和2.0版本的B模块一起使用。这时，用户要是将1.0版本的B的实例传给A，就会出现问题。因此，需要一种机制，在模板安装的时候提醒用户，如果A和B一起安装，那么B必须是2.0模块。 peerDependencies字段，就是用来供插件指定其所需要的主工具的版本。 123456{ &quot;name&quot;: &quot;chai-as-promised&quot;, &quot;peerDependencies&quot;: { &quot;chai&quot;: &quot;1.x&quot; }} 上面代码指定，安装chai-as-promised模块时，主程序chai必须一起安装，而且chai的版本必须是1.x。如果你的项目指定的依赖是chai的2.0版本，就会报错。 注意，从npm 3.0版开始，peerDependencies不再会默认安装了。 5. bin字段bin项用来指定各个内部命令对应的可执行文件的位置。 123&quot;bin&quot;: { &quot;someTool&quot;: &quot;./bin/someTool.js&quot;} 上面代码指定，someTool 命令对应的可执行文件为 bin 子目录下的 someTool.js。Npm会寻找这个文件，在node_modules/.bin/目录下建立符号链接。在上面的例子中，someTool.js会建立符号链接npm_modules/.bin/someTool。由于node_modules/.bin/目录会在运行时加入系统的PATH变量，因此在运行npm时，就可以不带路径，直接通过命令来调用这些脚本。 因此，像下面这样的写法可以采用简写。 123456789scripts: { start: &apos;./node_modules/someTool/someTool.js build&apos;}// 简写为scripts: { start: &apos;someTool build&apos;} 所有node_modules/.bin/目录下的命令，都可以用npm run [命令]的格式运行。在命令行下，键入npm run，然后按tab键，就会显示所有可以使用的命令。 6. main字段main字段指定了加载的入口文件，require(‘moduleName’)就会加载这个文件。这个字段的默认值是模块根目录下面的index.js。 7. config 字段config字段用于添加命令行的环境变量。 下面是一个package.json文件。 12345{ &quot;name&quot; : &quot;foo&quot;, &quot;config&quot; : { &quot;port&quot; : &quot;8080&quot; }, &quot;scripts&quot; : { &quot;start&quot; : &quot;node server.js&quot; }} 然后，在server.js脚本就可以引用config字段的值。 123http .createServer(...) .listen(process.env.npm_package_config_port) 用户执行npm run start命令时，这个脚本就可以得到值。 1$ npm run start 用户可以改变这个值。 1$ npm config set foo:port 80 8. 其他8.1 browser字段browser指定该模板供浏览器使用的版本。Browserify这样的浏览器打包工具，通过它就知道该打包那个文件。123&quot;browser&quot;: { &quot;tipso&quot;: &quot;./node_modules/tipso/src/tipso.js&quot;}, 8.1 engines 字段engines字段指明了该模块运行的平台，比如 Node 的某个版本或者浏览器。 1{ &quot;engines&quot; : { &quot;node&quot; : &quot;&gt;=0.10.3 &lt;0.12&quot; } } 该字段也可以指定适用的npm版本。 1{ &quot;engines&quot; : { &quot;npm&quot; : &quot;~1.0.20&quot; } } 8.3 man字段man用来指定当前模块的man文档的位置。 1&quot;man&quot; :[ &quot;./doc/calc.1&quot; ] 8.4 preferGlobal字段preferGlobal的值是布尔值，表示当用户不将该模块安装为全局模块时（即不用–global参数），要不要显示警告，表示该模块的本意就是安装为全局模块。 8.5 style字段style指定供浏览器使用时，样式文件所在的位置。样式文件打包工具parcelify，通过它知道样式文件的打包位置。 123&quot;style&quot;: [ &quot;./node_modules/tipso/src/tipso.css&quot;]","link":"/2019/07/13/node/packagejson/"},{"title":"自定义命令行配置","text":"平常在开发的时候因为项目多集合项目之间频繁切换非常浪费时间，因为启动项目是命令行所以想配置一个自定义命令来快速的进行项目切换和编辑器打开以及启动。 mac下自定义命令的配置在命令行里用 VSCode 打开 .zshrc 文件如图：上图是我自定的自定义命令 window 下自定义命令","link":"/2019/07/13/other/cmd/"},{"title":"Vue项目搭建","text":"Vue项目搭建Vue项目搭建非常简单这里就只说一下命令操作12345678# 全局安装 vue-cli$ npm install --global vue-cli# 创建一个基于 webpack 模板的新项目$ vue init webpack my-project# 安装依赖，走你$ cd my-project$ npm install$ npm run dev Vue项目搭建原文地址","link":"/2019/07/13/vue/start/"},{"title":"vue生命周期","text":"vue生命周期下面的表格是1.0+版本与2.0+版本的对比 vue1.0+ vue2.0 解释 init beforeCreate 组件实例刚被创建，组件属性计算之前，如data属性 created created 组件实例创建完成，属性已绑定，但DOM还没生成,$el属性还不存在 beforeCompile beforeMount 模板编译/挂载之前 compiled mounted 模板编译/挂载之后 ready mounted 模板编译/挂载之后 - beforeUpdate 组件更新之前 - updated 组件更新之后 - activated for keep-alive，组件被激活时调用 - deactivated for keep-alive，组件被移除时调用 activated - 不做解释 detached - 不做解释 beforeDestroy beforeDestroy 组件销毁前调用 destroyed destroyed 组件销毁后调用 用代码说清这些1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.jsdelivr.net/vue/2.1.3/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;p&gt;{{ message }}&lt;/p&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var app = new Vue({ el: &apos;#app&apos;, data: { message : &quot;xuxiao is boy&quot; }, beforeCreate: function () { console.group(&apos;beforeCreate 创建前状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot; , &quot;el : &quot; + this.$el); //undefined console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); //undefined console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message) }, created: function () { console.group(&apos;created 创建完毕状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); //undefined console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); //已被初始化 console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); //已被初始化 }, beforeMount: function () { console.group(&apos;beforeMount 挂载前状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + (this.$el)); //已被初始化 console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); //已被初始化 console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); //已被初始化 }, mounted: function () { console.group(&apos;mounted 挂载结束状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); //已被初始化 console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); //已被初始化 console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); //已被初始化 }, beforeUpdate: function () { console.group(&apos;beforeUpdate 更新前状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); }, updated: function () { console.group(&apos;updated 更新完成状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); }, beforeDestroy: function () { console.group(&apos;beforeDestroy 销毁前状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); }, destroyed: function () { console.group(&apos;destroyed 销毁完成状态===============》&apos;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message) } })&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 附一张图后面慢慢理解","link":"/2019/07/13/vue/lifecyce/"},{"title":"vue-router","text":"vue-router Vue.js的一大特色就是构建单页面应用十分方便，既然要方便构建单页面应用那么自然少不了路由，vue-router就是vue官方提供的一个路由框架。总体来说，vue-router设计得简单好用，下面就来聊聊我实际用到过的一些方法，文章没有提到的可以去查看官方文档。vue-router的安装这里就不提了，相信会来看这篇博客同学，这些基本能力都是有的。 先上例子12345678910111213141516171819202122232425262728293031323334353637383940&lt;!-- html部分，省略head --&gt;&lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;content&quot;&gt; &lt;router-link to=&quot;/goods&quot;&gt;商品&lt;/router-link&gt; &lt;router-link to=&quot;/ratings&quot;&gt;评论&lt;/router-link&gt; &lt;router-link to=&quot;/seller&quot;&gt;商家&lt;/router-link&gt; &lt;/div&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;script src=&quot;path-to-vue&quot;&gt;&lt;/script&gt;&lt;script src=&quot;path-to-vue-router&quot;&gt;&lt;/script&gt;// 首先定义或者引入路由的组件// 方法一：直接定义路由组件const goods = { template: &apos;&lt;p&gt;goods&lt;/p&gt;&apos; };const ratings = { template: &apos;&lt;p&gt;ratings&lt;/p&gt;&apos; };const seller = { template: &apos;&lt;p&gt;seller&lt;/p&gt;&apos; };// 方法二：import引入路由组件import goods from &apos;components/goods/goods&apos;;import ratings from &apos;components/ratings/ratings&apos;;import seller from &apos;components/seller/seller&apos;;// 然后定义路由(routes)，components还可以是Vue.extend()创建的const routes = [ { path: &apos;/goods&apos;, component: goods }, { path: &apos;/ratings&apos;, component: ratings }, { path: &apos;/seller&apos;, component: seller }];// 接着创建路由实例const router = new VueRouter({ // ES6缩写语法，相当于routes:routes routes });// 最后创建vue实例并挂载const app = new Vue({ el: &apos;#app&apos;, router});// 或者const app = new Vue({ router}).$mount(&apos;#app&apos;) 到这里就可以用vue-router轻松搭建一个单页面应用了。我一般都是使用模块化编程的形式，用.vue单文件，不知道在模块化编程里怎么加载vue-router的可以参考我的某个项目源码。 router-link和router-view看了上面的例子，一定对router-link和router-view很感兴趣。 router-link从上面例子中的书写形式就可以看出，router-link是一个组件，它默认会被渲染成一个带有链接的a标签，通过to属性指定链接地址。注意：被选中的router-link将自动添加一个class属性值.router-link-active。 router-link属性配置to这是一个必须设置的属性，否则路由无法生效。它表示路由的链接，可以是一个字符串也可以是一个描述目标位置的对象。12&lt;router-link to=&quot;goods&quot;&gt;&lt;/router-link&gt;&lt;router-link to=&quot;{path=&apos;goods&apos;}&quot;&gt;&lt;/router-link&gt; replace一个布尔类型，默认为false。如果replace设置为true，那么导航不会留下history记录，点击浏览器回退按钮不会再回到这个路由。1&lt;router-link to=&quot;goods&quot; replace&gt;&lt;/router-link&gt; tagrouter-link默认渲染成a标签，也有方法让它渲染成其他标签，tag属性就用来设置router-link渲染成什么标签的。12&lt;!-- 渲染成li标签 --&gt;&lt;router-link to=&quot;goods&quot; tag=&quot;li&quot;&gt;&lt;/router-link&gt; active-class上面说了被选中的router-link将自动添加一个class属性值.router-link-active，这个属性就是来修改这个class值的。 router-view这个组件十分关键，它就是用来渲染匹配到的路由的。可以给router-view组件设置transition过渡，具体用法见Vue2.0 Transition常见用法全解惑。还可以配合使用，keep-alive可以缓存数据，这样不至于重新渲染路由组件的时候，之前那个路由组件的数据被清除了。比如对当前的路由组件a进行了一些DOM操作之后，点击进入另一个路由组件b，再回到路由组件a的时候之前的DOM操作还保存在，如果不加keep-alive再回到路由组件a时，之前的DOM操作就没有了，得重新进行。如果你的应用里有一个购物车组件，就需要用到keep-alive。12345&lt;transition&gt; &lt;keep-alive&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt;&lt;/transition&gt; 一些小需求怎么实现不同路由不同页面标题多页面应用我们可以给每一个页面都设置一个不同的标题，但是如果是单页面应用的路由呢？其实也是可以实现的，实现的方法不止一种，我之前用的是结合命名路由和导航钩子函数的方法。如下：1234567891011121314// 定义路由的时候如下定义，name也可为中文const routes = [ { path: &apos;/goods&apos;, component: goods, name: &apos;goods&apos; }, { path: &apos;/ratings&apos;, component: ratings, name: &apos;ratings&apos; }, { path: &apos;/seller&apos;, component: seller, name: &apos;seller&apos; }];// 创建路由实例const router = new VueRouter({ routes: routes})// 关键在这里，设置afterEach钩子函数router.afterEach((to, from, next) =&gt; { document.title = to.name;}) 命名路由既然用到了命名路由，这里就提一下吧。命名路由就是用一个名称来标识一个路由，在定义路由的时候设置一个name属性即可。在router-link中也可以用路由的名字来链接到一个路由。1&lt;router-link :to=&quot;{ name: &apos;seller&apos;}&quot;&gt;seller&lt;/router-link&gt; 导航钩子这个我还没怎么用过，它主要是用来拦截导航的，想使用的参考官方文档吧。 怎么刚进入应用就渲染某个路由组件刚进入应用都是进入到“/”这个路由的，如果想直接进入到“/goods”怎么办，这里提供两种方法。一种是利用重定向，另一种是利用vue-router的导航式编程。 重定向123const routes = [ { path: &apos;/&apos;, redirect: &apos;/goods&apos;}] 是不是很简单呢？重定向的目标也可以是一个命名的路由。123const routes = [ { path: &apos;/&apos;, redirect: { name: &apos;goods&apos; }}] 导航式编程利用vue-router的导航式编程的router.push方法也可以实现上面的需求。12// 在创建vue实例并挂载后调用router.push(&apos;/goods&apos;) router.push方法就是用来动态导航到不同的链接的。它会向history栈添加一个新的记录，点击等同于调用router.push(…)。 vue-router中还有router.replace方法和router.go方法，概念及用法可参考https://router.vuejs.org/zh-cn。","link":"/2019/07/13/vue/router/"},{"title":"移动端事件——Touch事件","text":"移动端事件——Touch事件Touch事件触摸事件包含4个接口TouchEvent代表当触摸行为在平面上变化的时候发生的事件. Touch代表用户与触摸平面间的一个接触点. TouchList代表一系列的Touch; 一般在用户多个手指同时接触触控平面时使用这个接口. DocumentTouchDocumentTouch 接口提供了一个便利的方法来创建 Touch 和 TouchList 对象, 可是它将被移除。 但这个方法将会继续在Document 接口中存在. TouchEventTouchEvent 是一类描述手指在触摸平面（触摸屏、触摸板等）的状态变化的事件。这类事件用于描述一个或多个触点，使开发者可以检测触点的移动，触点的增加和减少，等等。 构造函数TouchEvent()创建一个TouchEvent对象。1var event = new TouchEvent(typeArg, touchEventInit); typeArg 用字符串来代表事件的名称。 touchEventInit 是一个TouchEventInit 字典，它拥有以下属性： “touches”,可选的,默认为[], TouchList类型（包含了一系列Touch对象的数组），当前位于屏幕上的所有手指的列表。 “targetTouches”,与touches类似，但是增加了个过滤条件，要与第一个手指点的地方（同一个节点内）相同。 “changedTouches”,可选的,默认为[],在touchstart中：列出在此次事件中新增加的触点。如果同时放下一根或两根手指，那么将与touches相同，但如果先放一根，在放第二根，那就会不同。在touchmove中：列出和上一次事件相比较，发生了变化的触点。在touchend中：列出离开触摸平面的触点（这些触点对应已经不接触触摸平面的手指）。 “ctrlKey”, 可选的,默认为false,布尔类型,表明按下了ctrl键。 “shiftKey”,可选的,默认为false,布尔类型,表明按下了shift键。 “altKey”,可选的,默认为false,布尔类型,表明按下了alt键。 “metaKey”,可选的,默认为false,布尔型,表明按下了meta键。 属性列表TouchEvnt.altKey 只读布尔值，指明触摸事件触发时，键盘 alt 键是否被按下。 TouchEvent.changedTouches 只读一个 TouchList 对象，包含了代表所有从上一次触摸事件到此次事件过程中，状态发生了改变的触点的 Touch 对象。 TouchEvent.ctrlKey 只读布尔值，指明触摸事件触发时，键盘 ctrl 键是否被按下。 TouchEvent.metaKey 只读布尔值，指明触摸事件触发时，键盘 meta 键 （Wikipedia - meta Key）是否被按下。 TouchEvent.shiftKey 只读布尔值，指明触摸事件触发时，键盘 shift 键是否被按下。 TouchEvent.targetTouches 只读一个 TouchList 对象，是包含了如下触点的 Touch 对象：触摸起始于当前事件的目标 element 上，并且仍然没有离开触摸平面的触点。 TouchEvent.touches 只读一 个 TouchList 对象，包含了所有当前接触触摸平面的触点的 Touch 对象，无论它们的起始于哪个 element 上，也无论它们状态是否发生了变化。 触摸事件的类型 （基本事件）为了区别触摸相关的状态改变，存在多种类型的触摸事 注意: 在很多情况下，触摸事件和鼠标事件会同时被触发（目的是让没有对触摸设备优化的代码仍然可以在触摸设备上正常工作）。如果你使用了触摸事件，可以调用 event.preventDefault() 来阻止鼠标事件被触发。 touchstart：当手指放在屏幕上触发 当用户在触摸平面上放置了一个触点时触发。事件的目标 element 将是触点位置上的那个目标 element touchmove：当手指在屏幕上滑动时，连续地触发 当用户在触摸平面上移动触点时触发。事件的目标 element 和这个 touchmove 事件对应的 touchstart 事件的目标 element 相同，哪怕当 touchmove 事件触发时，触点已经移出了该 element 。 当触点的半径、旋转角度以及压力大小发生变化时，也将触发此事件。 注意: 不同浏览器上 touchmove 事件的触发频率并不相同。这个触发频率还和硬件设备的性能有关。因此决不能让程序的运作依赖于某个特定的触发频率 touchend：当手指从屏幕上离开时触发 当一个触点被用户从触摸平面上移除（当用户将一个手指离开触摸平面）时触发。当触点移出触摸平面的边界时也将触发。例如用户将手指划出屏幕边缘。 事件的目标 element 和这个 touchend 事件对应的 touchstart 事件的目标 element 相同，哪怕 touchend 事件触发时，触点已经移出了该 element 。 已经被从触摸平面上移除的触点，可以在 changedTouches 属性定义的 TouchList 中找到。 touchcancel：当系统停止跟踪时触发;该事件暂时使用不到 当触点由于某些原因被中断时触发。有几种可能的原因如下（具体的原因根据不同的设备和浏览器有所不同）： 由于某个事件取消了触摸：例如触摸过程被一个模态的弹出框打断。 触点离开了文档窗口，而进入了浏览器的界面元素、插件或者其他外部内容区域。 当用户产生的触点个数超过了设备支持的个数，从而导致 TouchList 中最早的 Touch 对象被取消。 1234567891011121314151617181920212223242526272829303132333435var EventUtil = { addHandler: function(element,type,handler) { if(element.addEventListener) { element.addEventListener(type,handler,false); }else if(element.attachEvent) { element.attachEvent(&quot;on&quot;+type,handler); }else { element[&quot;on&quot; +type] = handler; } }, removeHandler: function(element,type,handler){ if(element.removeEventListener) { element.removeEventListener(type,handler,false); }else if(element.detachEvent) { element.detachEvent(&quot;on&quot;+type,handler); }else { element[&quot;on&quot; +type] = null; } }};var touch = document.getElementById(&quot;touch&quot;);//当手指接触屏幕时触发;EventUtil.addHandler(touch,&quot;touchstart&quot;,function(event){ console.log(event);});// 连续滑动触发EventUtil.addHandler(window,&quot;touchmove&quot;,function(event){ alert(&apos;move&apos;);});//当手指从屏幕上离开时触发;EventUtil.addHandler(window,&quot;touchend&quot;,function(event){ alert(&apos;end&apos;);}); TouchTouch对象表示在触控设备上的触摸点。通常是指手指或者触控笔在触屏设备或者触摸板上的操作。 对象属性 Touch.radiusX, Touch.radiusY, 和 Touch.rotationAngle 表示用户触摸操作所作用的区域，即触摸区域。这些属性对于处理类似于手指触摸之类的不精确操作很有帮助。这些属性可以表示出一个尽可能匹配触控区域的椭圆形（例如用户的指尖触控）。 注意: 以下很多属性的值需要依赖硬件设备去获取，例如，如果设备本身不支持侦测压感，那么 force 属性的值将始终是0，对于 radiusX 和 radiusY 来说同样可能有这种情况，如果设备认为触点只是一个点而不是一个面, 它们始终为1。 构造函数Touch()创建一个Touch对象。 1var touch = new Touch(touchInit); touchInit 是一个TouchInit 字典，它拥有以下属性： “identifier”, 必须，是一个长整型，表示一个触摸点的数字标记。 “target”, 必须, 是 EventTarget类型，表示在触摸点开始接触接触面时的节点。 “clientX”, 可选，默认为0，为双精度浮点数类型,表示触摸在浏览器视口的横轴坐标，不包括滚动条的偏移距离。 “clientY”, 可选，默认为0，为双精度浮点数类型,表示触摸在浏览器视口的横轴坐标，不包括滚动条的偏移距离。 “screenX”, 可选，默认为0，为双精度浮点数类型,表示以用户屏幕为基准的，触摸点横坐标。 “screenY”, 可选，默认为0，为双精度浮点数类型,表示以用户屏幕为基准的，触摸点纵坐标。 “pageX”,可选，默认为0，为双精度浮点数类型,表示触摸在用户屏幕的横轴坐标，包括滚动条的偏移距离。 “pageY”, 可选，默认为0，为双精度浮点数类型,表示触摸在用户屏幕的纵轴坐标，包括滚动条的偏移距离。 “radiusX”, 可选，默认为0，为浮点数类型。表示接触面（比如手指，触控笔）接触形成的椭圆，在rotationAngle角度下横轴上形成的椭圆半径。和screenX使用的CSS像素保持同一个缩放大小。这个值不能为负。 “radiusY”, 可选，默认为0，为浮点数类型。表示接触面（比如手指，触控笔）接触形成的椭圆，在rotationAngle角度下纵轴上形成的椭圆半径。和screenY使用的CSS像素保持同一个缩放大小。这个值不能为负。 “force”,可选，默认为0，为浮点数类型。表示触摸体对触摸面的压力值。范围为从0到1：0表示压力为零，1表示设备能承受的最大压力敏感值。对压力的敏感值变动范围根据不同环境变动比较大。 “rotationAngle”, 可选，默认为0，为浮点数类型。表示由 radiusX 和 radiusY决定的椭圆在顺时针方向相对其中心偏转的角度。这个值介于0到90度之间。如果由 radiusX 和 radiusY决定的椭圆是一个标准圆形，则rotationAngle没有任何效用。用户设备可能用0表示这种标准圆形的情况，或者用其他符合要求范围的值来表示（比如，用户设备可能用上一次的触摸事件rotationAngle值，来避免突然变动）。 ​ 属性以下属性描述了用户的触摸行为 Touch.identifier此 Touch 对象的唯一标识符. 一次触摸动作(我们值的是手指的触摸)在平面上移动的整个过程中, 该标识符不变. 可以根据它来判断跟踪的是否是同一次触摸过程. 只读属性. Touch.screenX触点相对于屏幕左边沿的的X坐标. 只读属性. Touch.screenY触点相对于屏幕上边沿的的Y坐标. 只读属性. Touch.clientX触点相对于可见视区(visual viewport)左边沿的的X坐标. 不包括任何滚动偏移. 只读属性. Touch.clientY触点相对于可见视区(visual viewport)上边沿的的Y坐标. 不包括任何滚动偏移. 只读属性. Touch.pageX触点相对于HTML文档左边沿的的X坐标. 当存在水平滚动的偏移时, 这个值包含了水平滚动的偏移. 只读属性. Touch.pageY触点相对于HTML文档上边沿的的Y坐标. 当存在水平滚动的偏移时, 这个值包含了垂直滚动的偏移. 只读属性. Touch.radiusX能够包围用户和触摸平面的接触面的最小椭圆的水平轴(X轴)半径. 这个值的单位和 screenX 相同. 只读属性. Touch.radiusY能够包围用户和触摸平面的接触面的最小椭圆的垂直轴(Y轴)半径. 这个值的单位和 screenY 相同. 只读属性. Touch.rotationAngle它是这样一个角度值：由radiusX 和 radiusY 描述的正方向的椭圆，需要通过顺时针旋转这个角度值，才能最精确地覆盖住用户和触摸平面的接触面. 只读属性. Touch.force手指挤压触摸平面的压力大小, 从0.0(没有压力)到1.0(最大压力)的浮点数. 只读属性. Touch.target当这个触点最开始被跟踪时(在 touchstart 事件中), 触点位于的HTML元素. 哪怕在触点移动过程中, 触点的位置已经离开了这个元素的有效交互区域, 或者这个元素已经被从文档中移除. 需要注意的是, 如果这个元素在触摸过程中被移除, 这个事件仍然会指向它, 但是不会再冒泡这个事件到 window 或 document 对象. 因此, 如果有元素在触摸过程中可能被移除, 最佳实践是将触摸事件的监听器绑定到这个元素本身, 防止元素被移除后, 无法再从它的上一级元素上侦测到从该元素冒泡的事件. 只读属性. 接触面Touch.radiusX, Touch.radiusY, 和 Touch.rotationAngle 描述了用户和触摸平面的接触面. 这在面向非精确触摸设备(由手指直接操作的触摸屏)开发时非常有用. 这些值描述了一个尽可能接近实际接触面(例如用户的指尖)的椭圆. TouchList一个 TouchList 代表一个触摸平面上所有触点的列表; 举例来讲, 如果一个用户用三根手指接触屏幕(或者触控板), 与之相关的TouchList 对于每根手指都会生成一个 Touch 对象, 共计三个. 属性TouchList.length返回TouchList中 Touch 对象的数量. 只读属性. 方法TouchList.identifiedTouch()列表中标示符与指定值匹配的第一个Touch 对象会被返回. TouchList.item()返回列表中以指定值作为索引的 Touch 对象. 你也可以使用数组的语法来引用TouchList(touchList[x]). DocumentTouch (已废弃)DocumentTouch 接口提供了一个便利的方法来创建 Touch 和 TouchList 对象, 可是它将被移除。 但这个方法将会继续在Document 接口中存在. 方法DocumentTouch.createTouch()创建一个新的 Touch 对象. DocumentTouch.createTouchList()创建一个新的 TouchList 对象. 手势事件 gesturestart：当一个手指已经按在屏幕上，而另一个手指又触摸在屏幕时触发。 gesturechange：当触摸屏幕的任何一个手指的位置发生变化时触发。 gestureend：当任何一个手指从屏幕上面移开时触发。 【注意】只有两个手指都触摸到事件的接收容器时才触发这些手势事件。 触摸事件与手势事件之间的关系1、当一个手指放在屏幕上时，会触发touchstart事件，如果另一个手指又放在了屏幕上，则会触发gesturestart事件，随后触发基于该手指的touchstart事件。 2、如果一个或两个手指在屏幕上滑动，将会触发gesturechange事件，但只要有一个手指移开，则会触发gestureend事件，紧接着又会触发toucheend事件。 手势的专有属性 rotation：表示手指变化引起的旋转角度，负值表示逆时针，正值表示顺时针，从零开始。 scale：表示两个手指之间的距离情况，向内收缩会缩短距离，这个值从1开始，并随距离拉大而增长。 示例1234567891011121314151617function handleGestureEvent(event) { var output = document.getElementById(&quot;output&quot;); switch(event.type) { case &quot;gesturestart&quot;: output.innerHTML = &quot;Gesture started (rotation=&quot; + event.ratation +&quot;,scale=&quot; + event.scale + &quot;)&quot;; break; case &quot;gestureend&quot;: output.innerHTML += &quot;&lt;br&gt;Gesture ended (rotation+&quot; + event.rotation + &quot;,scale=&quot; + event.scale + &quot;)&quot;; break; case &quot;gesturechange&quot;: output.innerHTML += &quot;&lt;br&gt;Gesture changed (rotation+=&quot; + event.rotation + &quot;,scale+&quot; + event.scale + &quot;)&quot;; break; }}document.addEventListener(&quot;gesturestart&quot;, handleGestureEvent, false);document.addEventListener(&quot;gestureend&quot;, handleGestureEvent, false);document.addEventListener(&quot;gesturechange&quot;, handleGestureEvent, false); 总结 触摸事件 touchstart当手指放在屏幕上触发。 touchmove当手指在屏幕上滑动时，连续地触发。 touchend当手指从屏幕上离开时触发。 touchcancel当系统停止跟踪时触发，系统什么时候取消，文档没有明确的说明。 除了常用的DOM属性，触摸事件还包含下列三个用于跟踪触摸的属性 touches：表示当前跟踪的触摸操作的touch对象的数组。当一个手指在触屏上时，event.touches.length=1,当两个手指在触屏上时，event.touches.length=2，以此类推。 targetTouches：特定于事件目标的touch对象数组。因为touch事件是会冒泡的，所以利用这个属性指出目标对象。 changedTouches：表示自上次触摸以来发生了什么改变的touch对象的数组。 每个touch对象都包含下列几个属性：clientX：触摸目标在视口中的x坐标。clientY：触摸目标在视口中的y坐标。identifier：标识触摸的唯一ID。pageX：触摸目标在页面中的x坐标。pageY：触摸目标在页面中的y坐标。screenX：触摸目标在屏幕中的x坐标。screenY：触摸目标在屏幕中的y坐标。target：触摸的DOM节点目标。 参考链接 ： https://developer.mozilla.org/zh-CN/docs/Web/API/Touch_events https://segmentfault.com/a/1190000005609334 http://www.jianshu.com/p/832f36531df9 http://web.jobbole.com/85132/","link":"/2016/08/25/javaScript/touch/"},{"title":"sublime快捷键总结","text":"sublime 快捷键大致比较全的快捷键网址：http://jinguoxing.github.io/sublime/mac/2015/07/02/sublime-mac-keys/有一些我认为用不到，在此我将常用的几个快捷键单独整理一下：1.)⌘（command）+d 选词（反复按快捷键，即可继续向下同时选中下一个相同的文本进行同时编辑） 2.)⌘（command）+P 搜索项目中的文件 输入当前项目中的文件名，快速搜索文件， 输入@和关键字，查找文件中函数名， 输入：和数字，跳转到文件中该行代码， 输入#和关键字，查找变量名。 (⌘（command）+t)与 ⌘（command）+P 作用一样 3.) ⌘（command）+ W 关闭当前打开文件 4.) ⌘（command）+X 剪切 5.) ⌘（command）+L 选择行，重复可依次增加选择下一行 效果和 Shift+↓ 效果一样 6.) ⌘（command）+O 打开文件 7.)⌘（command) +F 查找内容 8.)⌘（command) +Shift+F 查找并替换 9.)⌘（command) +N 新建窗口 10.)⌘（command) +数字 窗口切换 11.)⌘（command) +K+B 开关侧栏 12.)⌘（command) + / 注释当前行 (单行注释) 13.)alt+ ⌘（command)+/ 当前位置插入注释(多行注释) 14.)按 ⌘（command)键 依次点击或选取，可需要编辑的多个位置 15.)⌘（command）+M 最小化窗口 16.) 1. ⌘（command) + option +2 分成两屏 2. ⌘（command) + option +1 1屏 3. ⌘（command) + option +5 等分四屏 17.)⌘（command) + delelte 删除光标前所有字符 18.)cmd + [或 cmd + ] 智能行缩进 19.) CMD+CTRL+↓或CMD+CTRL+↑ 上下移动当前行。(换位置) 20.) Ctrl+Shift+K 删除整行 21.)command+ k + u 转换大写(将这个词的所有字母转换) 22.)command+ k + l 转换小写。 23.)command+Shift+L 先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。 24.)command+Enter 在下一行插入新行。举个例子：即使光标不在行尾，也能快速向下插入一行。 25.)command+Shift+Enter 在上一行插入新行。举个例子：即使光标不在行首，也能快速向上插入一行. 26.)command+K+0 展开所有折叠代码。 27.) command+← 向左单位性地移动光标，快速移动光标。 command+→ 向右单位性地移动光标，快速移动光标。 28.) shift+↑ 向上选中多行。 shift+↓ 向下选中多行。 Shift+← 向左选中文本。 (一个字符一个字符的增加选中，按住 shift键不放，一直点方向键) Shift+→ 向右选中文本。 29.) command+Shift+← 向左单位性地选中文本。 (单位性的我尝试后就是按一行选中，很方便) command+Shift+→ 向右单位性地选中文本。 30.)选中多行： 光标开始处按住shift键不放，到要结束处放下光标 31.)command+J 合并选中的多行代码为一行。举个例子：将多行格式的CSS属性合并为一行。 32.)command+Shift+D 复制光标所在整行，插入到下一行。 33.) Tab 向右缩进。 Shift+Tab 向左缩进。 34.)command+K+K 从光标处开始删除代码至行尾。 35.) command+Z 撤销。 command+Y 恢复撤销。 36.)Esc 退出光标多行选择，退出搜索框，命令框等。 37.)ctrl+` 打开控制台 38.)command + o 弹出当前文件所在的文件夹位置 39.)Ctrl＋Cmd＋G 选中所有同类名称，并可编辑 40.)Cmd+D 只是单纯选中同类名称，不可编辑","link":"/2016/08/25/IDE/sublime/sublimeKey/"},{"title":"关于数组的使用","text":"Array 方法concat 连接两个或者多个数组并返回新的数组，该方法不会影响原数组。 es6 实现concat123let arr1 = [2,3];let arr2 = [4,5];let arr3 = [...arr1,...arr2] 实现一个concat12345678910111213Array.prototype.myConcat = function () { let arr = this.slice(0); arguments.length &amp;&amp; [].forEach.call(arguments,(value) =&gt; { if (Array.isArray(value)) { value.forEach(val =&gt; { arr.push(val); }) } else { arr.push(value); } }) return arr;}; 方法 描述 concat() 连接两个或更多的数组，并返回结果。 join() 把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。 pop() 删除并返回数组的最后一个元素 push() 向数组的末尾添加一个或更多元素，并返回新的长度。 reverse() 颠倒数组中元素的顺序。 shift() 删除并返回数组的第一个元素 slice() 从某个已有的数组返回选定的元素 sort() 对数组的元素进行排序 splice() 删除元素，并向数组添加新元素。 toSource() 返回该对象的源代码。 toString() 把数组转换为字符串，并返回结果。 toLocaleString() 把数组转换为本地数组，并返回结果。 unshift() 向数组的开头添加一个或更多元素，并返回新的长度。 valueOf() 返回数组对象的原始值","link":"/2019/07/13/javaScript/array/function/"},{"title":"web优化","text":"作者：sunlei script 标签的优化 默认情况HTML解析，然后加载JS，此时HTML解析中断，然后执行JS，最后JS执行完成恢复HTML解析。 defer情况是HTMl和JS 并驾齐驱，等HTML加载完成再执行JS。 async 情况则HTMl和JS并驾齐驱,JS执行可能在HTML解析完成之前。 module情况和defer情况类似，只是在提取过程中多加载了多个JS文件。 怎么区分 有以下几点 defer翻译过来是延缓的意思，也就是拖拖拉拉了，所以比较懒，也就是说什么都不想做，也就是哪怕你把饭端在我面前，我也懒得动嘴的那种，这么一想，我们不就记住了，哪怕你客户端把JS文件下载好了，我也懒得执行，最后实在是大家都干完事了，我才不情愿的去执行JS文件。 async翻译过来就是异步的意思，异步异步，不就是一步一步嘛，什么都想一步到位，也就是说，只要下载完我就立马执行，至于其他的想都不想。 module翻译过来就是模块的意思，es6用过的人基本都了解这个关键字，加载也和defer差不多，只不过可以加载多个JS文件而已。 从上面我们可以看出，如果你的脚本依赖于DOM构建完成是否完成，则可以使用defer；如果无需DOM的构建，那就可以放心的使用async了 扩展导入","link":"/2019/07/13/other/optimize/web/"},{"title":"parcel使用","text":"什么是pracelparcel是一个前端项目打包器，现在我们已有的打包器与webpack和gulp。 为什么要把pracel拿出来说一说最近许多的网站推送pracel的相关消息，说什么零配置，打包速度快。 几个问题 我们现在使用的打包工具有哪些？ 我们为什么要是用这些打包工具，使用这些打包工具为我们解决了什么问题？ 现在已用到的打包工具给我们造成了什么困扰？ 用parcel建一个简单的项目安装Yarn:1yarn global add parcel-bundler npm:1npm install -g parcel-bundler 创建package.json1yarn init -y or1npm init -y 创建一个 index.html 和 index.js 文件。index.html12345&lt;html&gt;&lt;body&gt; &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; index.js1console.log(&quot;hello world&quot;); 在package.json重配置123&quot;scripts&quot;: { &quot;dev&quot;: &quot;parcel index.html -p 4000&quot;}, Babel配置1yarn add babel-preset-env .babelrc文件123{ &quot;presets&quot;: [&quot;env&quot;]} PostCSS配置1yarn add postcss-modules autoprefixer .postcssrc12345678{ &quot;modules&quot;: true, &quot;plugins&quot;: { &quot;autoprefixer&quot;: { &quot;grid&quot;: true } }} PostHTML配置1yarn add posthtml-img-autosize .posthtmlrc1234567{ &quot;plugins&quot;: { &quot;posthtml-img-autosize&quot;: { &quot;root&quot;: &quot;./images&quot; } }} parcelReact项目。 虽然说parcel是零配置但是在没有配置的情况下明显项目的灵活度降低许多，下载react有create-react-app进行构建，vue有vue-cli进行构架其实在项目配置相对来说已经非常少了，但是parcel没有配置文件还是让项目的开发有点难受，比如文件起别名，还有proxyConfig进行跨域处理在项目的开发时期都是很重有的事情，只能说对于一个初学web的人员来说配置变少了尤其是没有用到三大框架的项目组pracel还是使用很方便的，对于一些h5小网页比如基于canvas的小游戏的开发用pracel来构建还是非常方便的，但对于大型网站来说。。。","link":"/2019/07/13/packaging/parcel/parcelDev/"},{"title":"babel6","text":"babel 分离为多个包123babel-cli 命令行babel-core node api 以及 require hookbabel-polyfill 提供es2015的环境 preset 机制babel6 默认不再默认支持 es2015 以及 react。 需要手动在 .babelrc 中添加presets。所谓的 presets 其实就是一些同类plugin打包的结果，方便进行添加。123{ &quot;presets&quot;: [&quot;es2015&quot;, &quot;react&quot;]} stage 不再是配置项，以 presets 的形式添加。 博客推荐：babel6 升级总结软大师 Babel 入门教程","link":"/2019/07/13/packaging/webpack/babel6/"},{"title":"webpack中resolve模块","text":"Resolve 这些选项能设置模块如何被解析。webpack 提供合理的默认值，但是还是可能会修改一些解析的细节。 resolveobject 配置模块如何解析。例如，当在 ES2015 中调用 import “lodash”，resolve 选项能够对 webpack 查找 “lodash” 的方式去做修改（查看模块）。 resolve.aliasobject 创建 import 或 require 的别名，来确保模块引入变得更简单。例如，一些位于 src/ 文件夹下的常用模块：1234alias: { Utilities: path.resolve(__dirname, &apos;src/utilities/&apos;), Templates: path.resolve(__dirname, &apos;src/templates/&apos;)} 现在，替换「在导入时使用相对路径」这种方式，就像这样：1import Utility from &apos;../../utilities/utility&apos;; 你可以这样使用别名：1import Utility from &apos;Utilities/utility&apos;; 也可以在给定对象的键后的末尾添加 $，以表示精准匹配：123alias: { xyz$: path.resolve(__dirname, &apos;path/to/file.js&apos;)} 这将产生以下结果：12import Test1 from &apos;xyz&apos;; // 精确匹配，所以 path/to/file.js 被解析和导入import Test2 from &apos;xyz/file.js&apos;; // 精确匹配，触发普通解析 下面的表格展示了一些其他情况： 别名: import”xyz” import”xyz/file.js” {} /abc/node_modules/xyz/index.js /abc/node_modules/xyz/file.js { xyz: “/abs/path/to/file.js” } /abs/path/to/file.js error { xyz$: “/abs/path/to/file.js” } /abs/path/to/file.js /abc/node_modules/xyz/file.js { xyz: “./dir/file.js” } /abc/dir/file.js error { xyz$: “./dir/file.js” } /abc/dir/file.js /abc/node_modules/xyz/file.js { xyz: “/some/dir” } /some/dir/index.js /some/dir/file.js { xyz$: “/some/dir” } /some/dir/index.js /abc/node_modules/xyz/file.js { xyz: “./dir” } /abc/dir/index.js /abc/dir/file.js { xyz: “modu” } /abc/node_modules/modu/index.js /abc/node_modules/modu/file.js { xyz$: “modu” } /abc/node_modules/modu/index.js /abc/node_modules/xyz/file.js { xyz: “modu/some/file.js” } /abc/node_modules/modu/some/file.js error { xyz: “modu/dir” } /abc/node_modules/modu/dir/index.js /abc/node_modules/dir/file.js { xyz: “xyz/dir” } /abc/node_modules/xyz/dir/index.js /abc/node_modules/xyz/dir/file.js { xyz$: “xyz/dir” } /abc/node_modules/xyz/dir/index.js /abc/node_modules/xyz/file.js 如果在 package.json 中定义，index.js 可能会被解析为另一个文件。 /abc/node_modules 也可能在 /node_modules 中解析。 resolve.aliasFieldsstring 指定一个字段，例如 browser，根据此规范进行解析。默认：1aliasFields: [&quot;browser&quot;] resolve.cacheWithContextboolean ( webpack 3.1.0 以后版本) 如果启用了不安全的缓存，则包含request.context在缓存中。该enhanced-resolve模块考虑了该选项。因为解析缓存中的webpack 3.1.0上下文在提供解析或解析的插件时被忽略。这解决了性能回归。 resolve.descriptionFilesarray 用于描述的 JSON 文件。默认：1descriptionFiles: [&quot;package.json&quot;] resolve.enforceExtensionboolean 如果是 true，将不允许无扩展名(extension-less)文件。默认如果 ./foo 有 .js 扩展，require(‘./foo’) 可以正常运行。但如果启用此选项，只有 require(‘./foo.js’) 能够正常工作。默认：1enforceExtension: false resolve.enforceModuleExtensionboolean 对模块是否需要使用的扩展（例如 loader）。默认：1enforceModuleExtension: false resolve.extensionsarray 自动解析确定的扩展。默认值为：1extensions: [&quot;.js&quot;, &quot;.json&quot;] 能够使用户在引入模块时不带扩展： 1import File from &apos;../path/to/file&apos; 使用此选项，会覆盖默认数组，这就意味着 webpack 将不再尝试使用默认扩展来解析模块。对于使用其扩展导入的模块，例如，import SomeFile from “./somefile.ext”，要想正确的解析，一个包含“*”的字符串必须包含在数组中。 resolve.mainFieldsarray 当从 npm 包中导入模块时（例如，import * as D3 from “d3”），此选项将决定在 package.json 中使用哪个字段导入模块。根据 webpack 配置中指定的 target 不同，默认值也会有所不同。 当 target 属性设置为 webworker, web 或者没有指定，默认值为：1mainFields: [&quot;browser&quot;, &quot;module&quot;, &quot;main&quot;] 对于其他任意的 target（包括 node），默认值为：1mainFields: [&quot;module&quot;, &quot;main&quot;] 例如，D3 的 package.json 含有这些字段：1234567{ ... main: &apos;build/d3.Node.js&apos;, browser: &apos;build/d3.js&apos;, module: &apos;index&apos;, ...} 这意味着当我们 import * as D3 from “d3”，实际从 browser 属性解析文件。在这里 browser 属性是最优先选择的，因为它是 mainFields 的第一项。同时，由 webpack 打包的 Node.js 应用程序默认会从 module 字段中解析文件。 resolve.mainFilesarray 解析目录时要使用的文件名。默认：1mainFiles: [&quot;index&quot;] resolve.modulesarray 告诉 webpack 解析模块时应该搜索的目录。 绝对路径和相对路径都能使用，但是要知道它们之间有一点差异。 通过查看当前目录以及祖先路径（即 ./node_modules, ../node_modules 等等），相对路径将类似于 Node 查找 ‘node_modules’ 的方式进行查找。 使用绝对路径，将只在给定目录中搜索。 resolve.modules defaults to:1modules: [&quot;node_modules&quot;] 如果你想要添加一个目录到模块搜索目录，此目录优先于 node_modules/ 搜索：1modules: [path.resolve(__dirname, &quot;src&quot;), &quot;node_modules&quot;] resolve.unsafeCacheregex array boolean 启用，会主动缓存模块，但并不安全。传递 true 将缓存一切。默认：1unsafeCache: true 正则表达式，或正则表达式数组，可以用于匹配文件路径或只缓存某些模块。例如，只缓存 utilities 模块：1unsafeCache: /src\\/utilities/ 修改缓存路径可能在极少数情况下导致失败。 resolve.plugins应该使用的额外的解析插件列表。它允许插件，如 DirectoryNamedWebpackPlugin。1plugins: [new DirectoryNamedWebpackPlugin()] resolve.symlinksboolean 是否将符号链接(symlink)解析到它们的符号链接位置(symlink location)。默认：1symlinks: true resolve.cachePredicatefunction 决定请求是否应该被缓存的函数。函数传入一个带有 path 和 request 属性的对象。默认：1cachePredicate: function() { return true } resolveLoaderobject 这组选项与上面的 resolve 对象的属性集合相同，但仅用于解析 webpack 的 loader 包。默认：12345{ modules: [&quot;node_modules&quot;], extensions: [&quot;.js&quot;, &quot;.json&quot;], mainFields: [&quot;loader&quot;, &quot;main&quot;]} 注意，这里你可以使用别名，并且其他特性类似于 resolve 对象。例如，{ txt: ‘raw-loader’ } 会使用 raw-loader 去 shim(填充) txt!templates/demo.txt。 resolveLoader.moduleExtensionsarray 在解析模块（例如，loader）时尝试使用的扩展。默认是一个空数组。 如果你想要不带 -loader 后缀使用 loader，你可以使用：1moduleExtensions: [&apos;-loader&apos;]","link":"/2019/07/13/packaging/webpack/resolve/"},{"title":"babel-stage-x","text":"babel-stage 关于stage-x第一次遇见是在第一次搭建react项目时，项目搭建完成后在里边写箭头函数时报错,但当时没有深究只是在网上查找了一个方案说在loader里添加一个stage-0就能解决但是但是没有总结，后来babel升级遇到几次.babelrc的代码报错一直没有找到原因，后来总算知道原来是缺少插件 如何区分Babel中的stage-0,stage-1,stage-2以及stage-3大家知道，将ES6代码编译为ES5时，我们常用到Babel这个编译工具。大家参考一些网上的文章或者官方文档，里面常会建议大家在.babelrc中输入如下代码：12345678{ &quot;presets&quot;: [ &quot;es2015&quot;, &quot;react&quot;, &quot;stage-0&quot; ], &quot;plugins&quot;: []} 我们现在来说明下这个配置文件是什么意思。首先，这个配置文件是针对babel 6的。Babel 6做了一系列模块化，不像Babel 5一样把所有的内容都加载。比如需要编译ES6，我们需要设置presets为”es2015”，也就是预先加载es6编译的相关模块，如果需要编译jsx，需要预先加载”react”这个模块。那问题来了，这个”stage-0”又代表什么呢？ 有了”react-0”，是否又有诸如”stage-1”, “stage-2”等等呢？事实上， ”stage-0”是对ES7一些提案的支持，Babel通过插件的方式引入，让Babel可以编译ES7代码。当然由于ES7没有定下来，所以这些功能随时肯能被废弃掉的。现在我们来一一分析里面都有什么。 法力无边的stage-0为什么说“stage-0” 法力无边呢，因为它包含stage-1, stage-2以及stage-3的所有功能，同时还另外支持如下两个功能插件： 用过React的同学可能知道，jsx对条件表达式支持的不是太好，你不能很方便的使用if/else表达式，要么你使用三元表达，要么用函数。例如你不能写如下的代码： 1234567891011121314151617181920var App = React.createClass({ render(){ let { color } = this.props; return ( &lt;div className=&quot;parents&quot;&gt; { if(color == &apos;blue&apos;) { &lt;BlueComponent/&gt;; }else if(color == &apos;red&apos;) { &lt;RedComponent/&gt;; }else { &lt;GreenComponent/&gt;; } } } &lt;/div&gt; ) }}) 在React中你只能写成这样： 1234567891011121314151617181920var App = React.createClass({ render(){ let { color } = this.props; const getColoredComponent = color =&gt; { if(color === &apos;blue&apos;) { return &lt;BlueComponent/&gt;; } if(color === &apos;red&apos;) { return &lt;RedComponent/&gt;; } if(color === &apos;green&apos;) { return &lt;GreenComponent/&gt;; } } return ( &lt;div className=&quot;parents&quot;&gt; { getColoredComponent(color) } &lt;/div&gt; ) }}) transform-do-expressions 这个插件就是为了方便在 jsx写if/else表达式而提出的，我们可以重写下代码。 1234567891011121314151617181920var App = React.createClass({ render(){ let { color } = this.props; return ( &lt;div className=&quot;parents&quot;&gt; {do { if(color == &apos;blue&apos;) { &lt;BlueComponent/&gt;; }else if(color == &apos;red&apos;) { &lt;RedComponent/&gt;; }else { &lt;GreenComponent/&gt;; } } }} &lt;/div&gt; ) }}) 再说说 transform-function-bind, 这个插件其实就是提供过 :: 这个操作符来方便快速切换上下文， 如下面的代码： 123456789101112131415161718192021222324252627282930obj::func// is equivalent to:func.bind(obj)obj::func(val)// is equivalent to:func.call(obj, val)::obj.func(val)// is equivalent to:func.call(obj, val)// 再来一个复杂点的样例const box = { weight: 2, getWeight() { return this.weight; },};const { getWeight } = box;console.log(box.getWeight()); // prints &apos;2&apos;const bigBox = { weight: 10 };console.log(bigBox::getWeight()); // prints &apos;10&apos;// Can be chained:function add(val) { return this + val; }console.log(bigBox::getWeight()::add(5)); // prints &apos;15&apos; 如果想更屌点，还可以写出更牛逼的代码： 1234567const { map, filter } = Array.prototype;let sslUrls = document.querySelectorAll(&apos;a&apos;) ::map(node =&gt; node.href) ::filter(href =&gt; href.substring(0, 5) === &apos;https&apos;);console.log(sslUrls); 包罗万象的stage-1stage-1除了包含stage-2和stage-3，还包含了下面4个插件： 深藏不露的stage-2为什么说 stage-2深藏不露呢，因为它很低调，低调到你可以忽略它，但事实上，它很有内涵的。它除了覆盖stage-3的所有功能，还支持如下两个插件： syntax-trailing-function-commas这个插件让人一看觉得挺没趣的，让人甚至觉得它有点鸡肋。因它不是对ES6功能的增加，而是为了增强代码的可读性和可修改性而提出的。如下面的代码所示： 123456789101112131415161718192021222324252627// 假设有如下的一个函数，它有两个参数function clownPuppiesEverywhere( param1, param2) { /* ... */ }clownPuppiesEverywhere( &apos;foo&apos;, &apos;bar&apos;);// 有一天，它需要变成3个参数，你需要这样修改function clownPuppiesEverywhere( param1,- param2+ param2, // 这一行得加一个逗号+ param3 // 增加参数param3) { /* ... */ }clownPuppiesEverywhere( &apos;foo&apos;,- &apos;bar&apos;+ &apos;bar&apos;, // 这里的修改为逗号+ &apos;baz&apos; // 增加新的参数);// 看到没？ 我们修改了4行代码。。啊啊。修改了4行代码。 修改了4行代码，嗯嗯嗯。。追求高效的程序猿想想了，以后如果有更多参数了，我是不是要改等多行，得想想，代码改的越少越好，于是有了下面的改动。。 12345678910111213141516171819202122232425// 我们来重新定义一下函数function clownPuppiesEverywhere( param1, param2, // 注意这里，我们加了一个逗号哟) { /* ... */ }clownPuppiesEverywhere( &apos;foo&apos;, &apos;bar&apos;, // 这里我们也加了一个逗号);// 现在函数需要三个参数，我们来修改下function clownPuppiesEverywhere( param1, param2,+ param3, // 增加params3参数) { /* ... */ }clownPuppiesEverywhere( &apos;foo&apos;, &apos;bar&apos;,+ &apos;baz&apos;, // 增加第三个参数);// 叮叮当，我们只修改了两行代码就完成了，好开森 说实话吧，这个功能让人有点很无语。不过程序猿对干净代码的追求真的很让人感动，还是值得鼓励的。这个就是stage-2中”尾逗号函数”功能。哈哈哈哈。 transform-object-rest-spread再来说transform-object-rest-spread， 其实它是对 ES6中解构赋值的一个扩展，因为ES6只支持对数组的解构赋值，对对象是不支持的。如下面的代码所示： 12345678910// 获取剩下的属性let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };console.log(x); // 1console.log(y); // 2console.log(z); // { a: 3, b: 4 }// 属性展开let n = { x, y, ...z };console.log(n); // { x: 1, y: 2, a: 3, b: 4 } 大放异彩的stage3为啥说stage3大放异彩呢？因为它支持大名鼎鼎的async和await, 这两个哥们可是解决(Ajax)回调函数的终极解决方法呀！管你什么异步，我都可以用同步的思维来写，ES7里面非常强悍的存在。总的来说，它包含如下两个插件: transform-async-to-generator1234567891011121314151617181920212223242526transform-async-to-generator主要用来支持ES7中的async和await， 我们可以写出下面的代码：const sleep = (timeout)=&gt;{ return new Promise( (resolve, reject)=&gt;{ setTimeout(resolve, timeout) })}(async ()=&gt;{ console.time(&quot;async&quot;); await sleep(3000); console.timeEnd(&quot;async&quot;);})()再来一个实际点的例子const fetchUsers = (user)=&gt;{ return window.fetch(`https://api.douban.com/v2/user/${user}`).then( res=&gt;res.json())}const getUser = async (user) =&gt;{ let users = await fetchUsers(user); console.log( users);}console.log( getUser(&quot;flyingzl&quot;) 提示： 由于asycn和await是ES7里面的内容，现阶段不建议使用。为了顺利运行上面的代码，建议用webpack进行编译。 transform-exponentiation-operatortransform-exponentiation-operator这个插件算是一个语法糖，可以通过**这个符号来进行幂操作，想当于Math.pow(a,b)。如下面的样例 123456789101112131415161718// x ** ylet squared = 2 ** 2;// 相当于: 2 * 2let cubed = 2 ** 3;// 相当于: 2 * 2 * 2// x **= ylet a = 2;a **= 2;// 相当于: a = a * a;let b = 3;b **= 3;// 相当于: b = b * b * b;","link":"/2019/07/13/packaging/webpack/babel-stage/"},{"title":"浏览器缓存","text":"浏览器缓存的分类浏览器缓存分为两种类型： 强缓存：也称为本地缓存，不向服务器发送请求，直接使用客户端本地缓存数据 协商缓存：也称304缓存，向服务器发送请求，由服务器判断请求文件是否发生改变。如果未发生改变，则返回304状态码，通知客户端直接使用本地缓存；如果发生改变，则直接返回请求文件。 浏览器缓存机制的过程如下： 强缓存(本地缓存)强缓存是最彻底的缓存，无需向服务器发送请求，通常用于css、js、图片等静态资源。浏览器发送请求后会先判断本地是否有缓存。如果无缓存，则直接向服务器发送请求；如果有缓存，则判断缓存是否命中强缓存，如果命中则直接使用本地缓存，如果没命中则向服务器发送请求。判断是否命中本地缓存的方法有两种：Expires和Cache-Control。 ExpiresExpires是http1.0的响应头，代表的含义是资源本地缓存的过期时间，由服务器设定。服务器返回给浏览器的响应头中如果包含Expires字段，浏览器发送请求时拿当前时间和Expires字段值进行比较，判断资源缓存是否失效。如下图所示： Date代表请求资源的时间，Expires代表资源缓存的过期时间，可以看到服务器设置资源的缓存时间为5分钟。2017-02-10 07:53:19之前，请求这个资源就是命中本地缓存。超过这个时间再去请求则不命中。 Cache-ControlCache-Control是http1.0中新增的字段。由于Expires设置的是资源的具体过期时间，如果服务器时间和客户端时间不一样，就会造成缓存错乱，比如认为调节了客户端的时间，所以设置资源有效期的时长更合理。http1.1添加了Cache-Control的max-age字段。max-age代表的含义是资源有效期的时长，是一个相对时长，单位为s。 Cache-Control: max-age = 300设置资源的过期时间为5分钟。浏览器再次发送请求时，会把第一次请求的时间和max-age字段值相加和当前时间比较，以此判断是否命中本地缓存。max-age使用的都是客户端时间，比Expires更可靠。如果max-age和Expires同时出现，max-age的优先级更高。Cache-Control提供了更多的字段来控制缓存： no-store,不判断强缓存和协商缓存，服务器直接返回完整资源 no-cache,不判断强缓存，每次都需要向浏览器发送请求，进行协商缓存判断 public,指示响应可被任何缓存区缓存 private,通常只为单个用户缓存，不允许任何共享缓存对其进行缓存,通常用于用户个人信息 协商缓存协商缓存的判断在服务器端进行，判断是否命中的依据就是这次请求和上次请求之间资源是否发生改变。未发生改变命中，发生改变则未命中。判断文件是否发生改变的方法有两个：Last-Modified、If-Modified-Since和Etag、If-None-Match。 Last-Modified、If-Modified-SinceLast-Modified是http1.0中的响应头字段，代表请求的资源最后一次的改变时间。If-Modified-Since是http1.0的请求头，If-Modified-Since的值是上次请求服务器返回的Last-Modified的值。浏览器第一次请求资源时，服务器返回Last-Modified,浏览器缓存该值。浏览器第二次请求资源时，用于缓存的Last-Modified赋值给If-Modified-Since，发送给服务器。服务器判断If-Modified-Since和服务器本地的Last-Modified是否相等。如果相等，说明资源未发生改变，命中协商缓存；如果不相等，说明资源发生改变，未命中协商缓存。 可以看到该请求返回的是304状态码，说明资源的Last-Modified未改变，所以这次请求的Last-Modified和If-Modified-Since是一致的。 Etag、If-None-MatchLast-Modified、If-Modified-Since使用的都是服务器提供的时间，所以相对来说还是很可靠的。但是由于修改时间的精确级别或者定期生成文件这种情况，会造成一定的错误。所以http1.1添加Etag、If-None-Match字段，完善协商缓存的判断。Etag是根据资源文件内容生成的资源唯一标识符，一旦资源内容发生改变，Etag就会发生改变。基于内容的标识符比基于修改时间的更可靠。If-None-Match的值是上次请求服务器返回的Etag的值。Etag、If-None-Match的判断过程和Last-Modified、If-Modified-Since一致，Etag、If-None-Match的优先级更高。 工程中遇到的问题强缓存的优势很明显，无需向服务器发送请求，节省了大量的时间和带宽。但是有一个问题，缓存有效期内想更新资源怎么办？我在工程中还遇到另外一个问题，一个项目有四个环境，测试环境、开发环境、在线确认环境、在线环境，四个环境的域名相同，这样就会造成四个环境的缓存共用问题。比如先访问了测试环境，index.js被换成到浏览器中，再切换到在线环境，在线环境会请求index.js,此时浏览器就会使用本地缓存中测试环境的index.js,造成代码错乱。 如何使强缓存失效，是问题的关键。通常的解决方法是更新文件名，文件名不一样的话，浏览器就会重新请求资源。我们要保证新发布版本和不同环境中的文件名是不一样的。其中一种方法在文件名后加版本号： 12index.js?version=1index.css?version=1 webpack提供了很简单的方法可以配置缓存。1234567module.exports = { entry: &quot;main.js&quot;, output: { path: &quot;/build&quot;, filename: &quot;main.[hash].js&quot; }}; 通过hash占位符，在每次生成打包文件时，都会通过文件内容生成唯一的hash，并添加到输出的文件名中。如果有多个入口文件，可以使用name占位符设置输出： 12345678910module.exports = { entry: { main:&quot;main.js&quot;, sub:&quot;sub.js&quot; }, output: { path: &quot;/dist&quot;, filename: &quot;[name].[hash].js&quot; }}; 这时候有一个问题是，此时的hash是根据两个文件的内容来生成的，两个文件名使用的hash是一致的。如果main.js和sub.js只有一个改变，两个文件名都会改变，两个文件都会重新请求，造成资源浪费。webpack提供了chunkhash来代替hash在多入口情况下使用。chunkhash是根据每个入口文件单独生成的哈希值，避免上述情况。 webpack打包动态生成文件名，我们需要动态地把文件引用插入到html启动文件中。html-webpack-plugin可以帮我很好地解决这个问题。html-webpack-plugin可以动态地生成一个html文件，并在html文件中动态插入webpack打包生成的资源文件。 12345678910var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);var webpackConfig = { entry: &apos;main.js&apos;, output: { path: &apos;/dist&apos;, publicPath: &apos;/dist&apos;, filename: &apos;main.[hash].js&apos; }, plugins: [new HtmlWebpackPlugin()]}; 默认在webpackConfig.output.path路径下生成index.html,生成的html文件如下： 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Webpack App&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;main.2a6c1fee4b5b0d2c9285.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 通常html启动文件都有自定义的内容，所以html-webpack-plugin提供了模板功能，template字段设置模板的路径，html-webpack-plugin以template为模板，动态添加webpack打包生成的资源路径。1234567891011121314var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);var webpackConfig = { entry: &apos;main.js&apos;, output: { path: &apos;/dist&apos;, publicPath: &apos;/dist&apos;, filename: &apos;main.[hash].js&apos; }, plugins: [new HtmlWebpackPlugin( { template:&apos;index.html&apos; } )]}; 生成的index.html内容（\\dist\\index.html）: 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;stat-front&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;//at.alicdn.com/t/font_ejl5slgdvtg74x6r.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot; class=&quot;app-root&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;!-- built files will be auto injected --&gt; &lt;script src=&quot;main.2a6c1fee4b5b0d2c9285.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 最开始的时候静态的index.html在根目录下，webpack-dev-server设置的启动路径就是根目录下的index.html,如果要启动生成的index.html，还需要设置webpackConfig.output.publicPath： 1234567891011121314var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);var webpackConfig = { entry: &apos;main.js&apos;, output: { path: &apos;/dist&apos;, publicPath: &apos;/&apos;, filename: &apos;main.[hash].js&apos; }, plugins: [new HtmlWebpackPlugin( { template:&apos;index.html&apos; } )]}; 这样webpack-dev-server在内存中生成的资源都存放在根目录下，生成的index.html会代替原index.html启动。 进阶内容：webpack缓存","link":"/2019/07/13/packaging/webpack/cache/"},{"title":"sublime插件总结","text":"sublime 插件下载： https://www.sublimetext.com/3 //下载网址，可以选择版本 sublime Text3 以dmp结尾的 删除插件： command+shift+P,输入package 查找remove package 输入你要删除的package 回车，OK 安装插件:1. 安装 Package Control http://www.jianshu.com/p/5baa47642375 (利用Package Control来安装其他插件) 2. 上面的 Package Control 安装完以后, 就可以通过快捷键 command + shift + p 并输入 install package, 来选择需要安装的插件. 3. 插件有时默认的快捷键会和其他的软件的快捷键冲突，所以可以自己设置插件的快捷键 点击菜单 Preferences -&gt; KeyBindings - User, 加入如下内容 [{ &quot;keys&quot;: [&quot;ctrl+1&quot;], &quot;command&quot;: &quot;alignment&quot; }] 将快捷键修改成自己要改的。 Sublime Text常用插件总结:我认为插件比较官方了解可以参考此链接：https://packagecontrol.io/packages/Babel 后面换上不同的插件名称即可，不过可能只是大致介绍一些基础重要的。 1.) Emmet Emmet使用仿CSS选择器的语法来生成代码，大大提高了HTML/CSS代码编写的速度。 具体使用链接：http://www.iteye.com/news/27580 (桌面有两个我写的文件,不过对js和less没有作用) 2.)Alignment 这插件用于对齐代码赋值语句，如 123var name = &quot;sublimt&quot;var version = &quot;2.0.1&quot;var title = &quot;sublime text 按下快捷键后, 会变成: 123var name = &quot;sublimt&quot;var version = &quot;2.0.1&quot;var title = &quot;sublime text” 3.)Trimmer 你知道当你编写代码时，由于错误或别的某些原因，会产生一些不必要的空格。需要注意的是多余的空格有时也会造成错误。这个插件会自动删除这些不必要的空格，也可以删除空行，可以达到压缩css和js的效果。 4.)autoprefixer 自动在代码前面添加兼容性前缀 例子： 12345678910111213使用前：.wsl{ display:flex; -webkit-border-radius:20px; border-radius:20px; }使用后：.wsl{ display:-webkit-box; display:-ms-flexbox; display:flex; border-radius:20px;} 注释：效果明显，多于的 CSS/less 会自动删掉，border-radius 早就已经不需要前缀了，只有 Firefox 3.6，Chrome 4，Safari 4 和 Android 2.1 需要前缀； 快捷键设置方式还是如上第三步所示： 5.)Less 功能：LESS高亮插件 简介：用LESS的同学都知道，sublime没有支持less的语法高亮，所以这个插件可以帮上我们 使用：打开.less文件或者设置为less格式 //在没安装这个插件之前less文件中的代码是白色的，看着很不舒服，安装了这个插件则会让代码加上颜色 6.)Babel 这个插件支持ES6， React.js, jsx代码高亮，对 JavaScript, jQuery 也有很好的扩展。 按照上述步骤安装后，在view-&gt;Syntax(语法)-&gt;这个时候安装了babel就会有一项选择Babel-&gt;Babel(javascript)这一项，代码就会变高亮。 （默认是Syntax下面的javascript）。 7.)BracketHighlighter BracketHighlighter插件能为Sublime Text提供括号，引号这类高亮功能，但安装此插件后，默认没有高亮，只有下划线表示，不是很醒目，跟进一步的修改可以 http://www.wdclab.com/2015/09/10/mac%E7%89%88sublime-text-3%E4%B8%ADbrackethighlighter%E6%8F%92%E4%BB%B6%E9%AB%98%E4%BA%AE%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95/ (mac) http://www.cnblogs.com/willingtolove/p/4657320.html (windows) 可以参考此链接 ,很有用,执行完第二步是白色高亮 若想彩色高亮则根据步骤继续进行第三步。 , 1234567 Bracket Quote 表示引号 Bracket Tag 表示标签 Bracket Angle 表示角 （这个可以自己试试） Bracket Square 表示方括号 Bracket Round 表示小括号 Bracket Curly 表示大括号不过实现彩色的效果还需要安装SublimeLinter {主题相关插件8-9}8.)Theme-Soda Soda主题是sublime上一款很著名的清爽型主题，分两种： light: dark: 两者之间的切换通过在 （菜单 Preferences -&gt; Settings - User）中加入 &quot;theme&quot;: &quot;Soda Light.sublime-theme&quot; 或 &quot;theme&quot;: &quot;Soda Dark.sublime-theme” 如果想要原来默认的则去掉这句话不写即可，默认： 保存之后发现怎么代码区域还是黑色的背景，菜单栏颜色已经切换了，别急，这里还少了一步，就是配置一下color scheme,就用下面的插件介绍 9.)ColorSublime 1234主题可以参考此链接： http://www.jianshu.com/p/13fedee165f1主要以ColorSublime为插件安装安装了ColorSublime后，在控制面板里输入安装ColorSublime:install theme就可以如链接所示，选择你相中的主体安装 {文件模版10}10.)SublimeTmpl http://www.fantxi.com/blog/archives/sublime-template-engine-sublimetmpl/只看使用，安装就行，Sublime Text 新建文件的模版插件 {JS代码格式化11}11.)JsFormat 这是一款将JS格式化的插件，安装后即可在JS文件中通过鼠标右键-&gt;JsFormat或键盘快捷键Ctrl+Alt+F对JS进行格式化 {右键菜单功能增强插件12}12.)SideBarEnhancements 这是一款很实用的右键菜单增强功能，安装之前左侧菜单栏右键只有几个功能，安装之后增加了很多实用功能。 可以参考这个链接，有个简单的说明：https://nicesu.gitbooks.io/sublime-text-guide/content/plug-in/sidebarenhancements.html {只针对.css的文件代码排序13}13.)CSScomb 格式化前： , 格式化后：快捷键 ctrl+shift+c , 但是会产生一些空行，可以解决: 在sublime中下载CSS Format插件，然后执行 edit-&gt;css format-&gt;expanded 即可此 时空行将会消除。 , 我认为可以先用css最后可以改成less文件可以参考这个链接：https://segmentfault.com/a/1190000004577644 {文件中打开命令行窗口14}14.)Terminal123在编程过程中我们需要经常使用到命令行窗口，此快捷键可以在sublime Text3中打开cmd窗口，默认打开的是终端，如果想要打开iTerm,可以在setting-&gt;user中设置：快捷键（mac）:cmd+shift+t可以参考链接：https://packagecontrol.io/packages/Terminal {查看html、css兼容的15}15.)Can I Use 不过只是针对html和css，选中一个词或标签按快捷键：ctrl+alt+f就会跳到http://caniuse.com/，可以看到兼容到哪些浏览器 {代码校验16}16.)SublimeLinter SublimeLinter是一个代码校验插件，它可以帮你找出错误或编写不规范的代码 会在页面上产生一些点，点击点会有提示在下方 可以按照这个安装： http://www.cnblogs.com/xiaofeixiang/p/4853625.html 可以通过这个研究： https://nicesu.gitbooks.io/sublime-text-guide/content/plug-in/sublimelinter.html (但是不知道怎么把下面提示区域放大？) ####{在文件中调用Git命令17}17.)Git 可以参考此链接：https://packagecontrol.io/packages/Git 安装完git后可以在mac中用命令打开：cmd+shift+p，输入git就会出现很多git命令。 (但是git status可以用，其他的怎么用？)","link":"/2016/08/25/IDE/sublime/sublimePlug/"},{"title":"webpack1  到 webpack2的变化","text":"webpack1 到 webpack2的变化resolve.root, resolve.fallback, resolve.modulesDirectories上述配置项被一个单独的配置项 resolve.modules 取代。详见 resolving。 1234567 resolve: {- root: path.join(__dirname, &quot;src&quot;)+ modules: [+ path.join(__dirname, &quot;src&quot;),+ &quot;node_modules&quot;+ ] } resolve.extensions此配置项不再需要传一个空字符串。此行为被迁移到 resolve.enforceExtension。详见 resolving。 resolve.*变化较大在我的webpack中resolve模块节查看 module.loaders 改成了 module.rules旧的 loader 配置被更强大的 rules 系统取代，后者允许配置 loader 以及其他更多项。为了兼容旧版，module.loaders 语法被保留，旧的属性名依然可以被解析。新的命名约定更易于理解并且是升级配置使用 module.rules 的好理由。 12345678910111213141516171819202122232425262728 module: {- loaders: [+ rules: [ { test: /\\.css$/,- loaders: [+ use: [ { loader: &quot;style-loader&quot; }, { loader: &quot;css-loader&quot;,- query: {+ options: { modules: true } } ] }, { test: /\\.jsx$/, loader: &quot;babel-loader&quot;, // Do not use &quot;use&quot; here options: { // ... } } ] } 链式 loaders与 v1 版本相同，loaders 可以链式调用，上一个 loader 的输出被作为输入传给下一个 loader。使用 rule.use 配置项，use 可以设置为一个 loaders 的列表。在 v1 版本中，loaders 通常被用 ! 连写。这一写法在新版中只在使用旧的 module.loaders 时有效。123456789101112 module: {- loaders: {+ rules: [{ test: /\\.less$/,- loader: &quot;style-loader!css-loader!less-loader&quot;+ use: [+ &quot;style-loader&quot;,+ &quot;css-loader&quot;,+ &quot;less-loader&quot;+ ] }] } 取消了在模块名中自动添加 -loader 后缀1234567891011121314 module: { rules: [ { use: [- &quot;style&quot;,+ &quot;style-loader&quot;,- &quot;css&quot;,+ &quot;css-loader&quot;,- &quot;less&quot;,+ &quot;less-loader&quot;, ] } ] } json-loader 不再需要手动添加如果没有为 JSON 文件配置 loader，webpack 将自动尝试通过 加载 json-loader JSON 文件。12345678 module: { rules: [- {- test: /\\.json/,- loader: &quot;json-loader&quot;- } ] } loader 默认的 resolve 配置是相对于 context 的在 webpack 1 中，loader 默认配置下 resolve 相对于被匹配的文件。而在 webpack 2 中默认配置的 resolve 相对于 context 配置项。 这解决了一些问题，比如使用 npm link 或引用 context 之外的模块时导致重复载入。 你可以不再需要使用一些变通方案了：123456789101112 module: { rules: [ { // ...- loader: require.resolve(&quot;my-loader&quot;)+ loader: &quot;my-loader&quot; } ] }, resolveLoader: {- root: path.resolve(__dirname, &quot;node_modules&quot;) } 取消了 module.preLoaders 以及 module.postLoaders12345678910 module: {- preLoaders: [+ rules: [ { test: /\\.js$/,+ enforce: &quot;pre&quot;, loader: &quot;eslint-loader&quot; } ] } UglifyJsPlugin sourceMapUglifyJsPlugin 的 sourceMap 配置项现在默认为 false 而不是 true。 这意味着如果你在压缩代码时启用了 source map，或者想要让 uglifyjs 的警告能够对应到正确的代码行，你需要将 UglifyJsPlugin 的 sourceMap 设为 true。123456devtool: &quot;source-map&quot;, plugins: [ new UglifyJsPlugin({+ sourceMap: true }) ] UglifyJsPlugin warningsUglifyJsPlugin 的 compress.warnings 配置项现在默认为 false 而不是 true。 这意味着如果你想要看到 uglifyjs 的警告信息，你需要将 compress.warnings 设为 true。12345678 devtool: &quot;source-map&quot;, plugins: [ new UglifyJsPlugin({+ compress: {+ warnings: true+ } }) ] UglifyJsPlugin 压缩 loadersUglifyJsPlugin 不再压缩 loaders。在未来很长一段时间里，需要通过设置 minimize:true 来压缩 loaders。参考 loader 文档里的相关配置项。 loaders 的压缩模式将在 webpack 3 或更高的版本中被取消。 为了兼容旧的 loaders，loaders 可以通过插件来切换到压缩模式12345 plugins: [+ new webpack.LoaderOptionsPlugin({+ minimize: true+ }) ] DedupePlugin 被移除不再需要 webpack.optimize.DedupePlugin。请从配置中移除。 BannerPlugin - 破坏性改动BannerPlugin 不在接受两个参数而是只接受单独的 options 对象。1234 plugins: [- new webpack.BannerPlugin(&apos;Banner&apos;, {raw: true, entryOnly: true});+ new webpack.BannerPlugin({banner: &apos;Banner&apos;, raw: true, entryOnly: true}); ] OccurrenceOrderPlugin 被默认加载我们不再需要在配置里指定它：123 plugins: [- new webpack.optimize.OccurrenceOrderPlugin() ] ExtractTextWebpackPlugin - 大改变ExtractTextPlugin 1.0.0 不能在 webpack v2 下工作。 你需要明确地安装 ExtractTextPlugin v2。 npm install –save-dev extract-text-webpack-plugin@beta 这一插件的配置变化主要体现在语法上。ExtractTextPlugin.extract12345678910111213module: { rules: [ { test: /.css$/,- loader: ExtractTextPlugin.extract(&quot;style-loader&quot;, &quot;css-loader&quot;, { publicPath: &quot;/dist&quot; })+ use: ExtractTextPlugin.extract({+ fallback: &quot;style-loader&quot;,+ use: &quot;css-loader&quot;,+ publicPath: &quot;/dist&quot;+ }) } ]} new ExtractTextPlugin({options})12345678plugins: [- new ExtractTextPlugin(&quot;bundle.css&quot;, { allChunks: true, disable: false })+ new ExtractTextPlugin({+ filename: &quot;bundle.css&quot;,+ disable: false,+ allChunks: true+ })] 全动态 requires 现在默认会失败只有一个表达式的依赖（例如 require(expr)）将创建一个空的 context 而不是一个完整目录的 context。 如果有上面那样的代码，最好把它重构了，因为在 ES2015 模块下它不可以用。如果你确定不会有 ES2015 模块，你可以使用 ContextReplacementPlugin 来提示编译器进行正确的处理。 在 CLI 和配置中使用自定义参数如果你之前滥用 CLI 来传自定义参数到配置中，比如： webpack –custom-stuff 1234// webpack.config.jsvar customStuff = process.argv.indexOf(&quot;--custom-stuff&quot;) &gt;= 0;/* ... */module.exports = config; 你将会发现新版中不再允许这么做。CLI 现在更加严格了。 替代地，现在提供了一个接口来传递参数给配置。我们应该采用这种新方式，在未来许多工具将可能依赖它。 webpack –env.customStuff12345module.exports = function(env) { var customStuff = env.customStuff; /* ... */ return config;}; require.ensure 以及 AMD require 的异步现在这些函数总是异步的，而不是当 chunk 已经加载过的时候同步调用它们的 callback。 注意 require.ensure 现在依赖于原生的 Promise。如果在不支持 Promise 的环境里使用 require.ensure，你需要添加 polyfill。 通过 options 配置 loader你不能再通过 webpack.config.js 的自定义属性来配置 loader。只能通过 options 来配置。下面配置的 ts 属性在 webpack 2 下不再有效：1234567891011module.exports = { ... module: { rules: [{ test: /\\.tsx?$/, loader: &apos;ts-loader&apos; }] }, // does not work with webpack 2 ts: { transpileOnly: false }} 什么是 options? 好问题。严格来说，有两种办法，都可以用来配置 webpack 的 loader。典型的 options 被称为 query，是一个可以被添加到 loader 名之后的字符串。它比较像一个 query string，但是实际上有更强大的能力：123456789module.exports = { ... module: { rules: [{ test: /\\.tsx?$/, loader: &apos;ts-loader?&apos; + JSON.stringify({ transpileOnly: false }) }] }} 不过它也可以分开来，写成一个单独的对象，紧跟在 loader 属性后面：12345678910module.exports = { ... module: { rules: [{ test: /\\.tsx?$/, loader: &apos;ts-loader&apos;, options: { transpileOnly: false } }] }} LoaderOptionsPlugin context有的 loader 需要从配置中读取一些 context 信息。在未来很长一段时间里，这将需要通过 loader options 传入。详见 loader 文档的相关选项。 为了保持对旧 loaders 的兼容，这些信息可以通过插件传进来：1234567 plugins: [+ new webpack.LoaderOptionsPlugin({+ options: {+ context: __dirname+ }+ }) ] debug在 webpack 1 中 debug 配置项切换 loaders 到 debug 模式。在未来很长一段时间里，这将需要通过 loader 配置项传递。详见 loader 文档的相关选项。 loaders 的 debug 模式将在 webpack 3 或后续版本中取消。 为了保持对旧 loaders 的兼容，loader 可以通过插件来切换到 debug 模式：123456- debug: true, plugins: [+ new webpack.LoaderOptionsPlugin({+ debug: true+ }) ] ES2015 的代码分割在 webpack v1 中，你能使用 require.ensure 作为方法来懒加载 chunks 到你的应用中：123require.ensure([], function(require) { var foo = require(&quot;./module&quot;);}); ES2015 模块加载规范定义了 import() 方法来运行时动态地加载 ES2015 模块。 webpack 将 import() 作为分割点并将被请求的模块放到一个单独的 chunk 中。 import() 接收模块名作为参数，并返回一个 Promise。1234567function onClick() { import(&quot;./module&quot;).then(module =&gt; { return module.default; }).catch(err =&gt; { console.log(&quot;Chunk loading failed&quot;); });} 好消息是：如果加载 chunk 失败，我们可以进行处理，因为现在它基于 Promise。 警告：require.ensure 允许用可选的第三个参数为 chunk 简单命名，但是 import API 还未提供这个能力。如果你想要保留这个功能，你可以继续使用 require.ensure。123require.ensure([], function(require) { var foo = require(&quot;./module&quot;);}, &quot;custom-chunk-name&quot;); （注意废弃的 System.import：webpack 对 System.import 的使用不符合新提出的标准，所以它在 v2.1.0-beta.28 版本中被废弃，转向支持 import()） 由于这个建议还在 Stage 3，如果你想要同时使用 import 和 Babel，你需要安装/添加 dynamic-import 语法插件来绕过解析错误。当建议被添加到规范之后，就不再需要这个语法插件了。 动态表达式可以传递部分表达式给 import()。这与 CommonJS 对表达式的处理方式一致（webpack 为所有可能匹配的文件创建 context）。 import() 为每一个可能的模块创建独立的 chunk。12345function route(path, query) { return import(`./routes/${path}/route`) .then(route =&gt; new route.Route(query));}// 上面代码为每个可能的路由创建独立的 chunk 混合使用 ES2015、AMD 和 CommonJS你可以自由混合使用三种模块类型（甚至在同一个文件中）。在这个情况中 webpack 的行为和 babel 以及 node-eps 一致：123456// CommonJS consuming ES2015 Modulevar book = require(&quot;./book&quot;);book.currentPage;book.readPage();book.default === &quot;This is a book&quot;; 123456// ES2015 Module consuming CommonJSimport fs from &quot;fs&quot;; // module.exports map to defaultimport { readFileSync } from &quot;fs&quot;; // named exports are read from returned object+typeof fs.readFileSync === &quot;function&quot;;typeof readFileSync === &quot;function&quot;; 需要注意的是，您需要告诉Babel不要解析这些模块符号，这样webpack就可以使用它们。您可以通过在您的程序中设置以下内容来实现这一点。babelrc或babel-loader选项。 .babelrc12345{ &quot;presets&quot;: [ [&quot;es2015&quot;, { &quot;modules&quot;: false }] ]} 模板字符串webpack 现在支持表达式中的模板字符串了。这意味着你可以在 webpack 构建中使用它们：12- require(&quot;./templates/&quot; + name);+ require(`./templates/${name}`); 配置中使用 Promisewebpack 现在支持在配置文件中返回 Promise 了。这让你能在配置文件中做异步处理。 webpack.config.js123456789module.exports = function() { return fetchLangs().then(lang =&gt; ({ entry: &quot;...&quot;, // ... plugins: [ new DefinePlugin({ LANGUAGE: lang }) ] }));}; 高级 loader 匹配webpack 现在支持对 loader 进行更多方式的匹配。 123456789module: { rules: [ { resource: /filename/, // matches &quot;/path/filename.js&quot; resourceQuery: /querystring/, // matches &quot;/filename.js?querystring&quot; issuer: /filename/, // matches &quot;/path/something.js&quot; if requested from &quot;/path/filename.js&quot; } ]} 更多的 CLI 参数项你可以使用一些新的 CLI 参数项： –define process.env.NODE_ENV=”production” 见 DefinePlugin。 –display-depth 显示每个模块到入口的距离。 –display-used-exports 显示一个模块中被使用的 exports 信息。 –display-max-modules 设置输出时显示的模块数量（默认是 15）。 -p 能够定义 process.env.NODE_ENV 为 “production”。 CacheableLoaders 现在默认可被缓存。Loaders 如果不想被缓存，需要选择不被缓存。12345 // Cacheable loader module.exports = function(source) {- this.cacheable(); return source; } 12345 // Not cacheable loader module.exports = function(source) {+ this.cacheable(false); return source; } 复合 optionswebpack 1 只支持能够 JSON.stringify 的对象作为配置项。webpack 2 现在支持任意 JS 对象作为 loader 配置项。 使用复合 options 只有一个附加条件。你需要在 options 对象上添加一个 ident，让它能够被其他 loader 引用。 options 对象上有了 ident ，内联的 loader 就可以引用这个 options 对象。下面是个例子： require(“some-loader??by-ident!resource”)12345678{ test: /.../, loader: &quot;...&quot;, options: { ident: &quot;by-ident&quot;, magic: () =&gt; return Math.random() }} 这种内联风格在常规的代码里一般用不着，但是在 loader 生成的代码里比较常见。比如，style-loader 生成一个模块，通过 require 加载其余的请求（它们输出 CSS）。12345// style-loader generated code (simplified)var addStyle = require(&quot;./add-style&quot;);var css = require(&quot;-!css-loader?{&quot;modules&quot;:true}!postcss-loader??postcss-ident&quot;);addStyle(css); 所以如果你使用复合 options，告诉你的用户你使用的 ident。","link":"/2019/07/13/packaging/webpack/webpack2/"}],"tags":[{"name":"css","slug":"css","link":"/tags/css/"},{"name":"clamp","slug":"clamp","link":"/tags/clamp/"},{"name":"css3","slug":"css3","link":"/tags/css3/"},{"name":"flex","slug":"flex","link":"/tags/flex/"},{"name":"布局","slug":"布局","link":"/tags/布局/"},{"name":"mac","slug":"mac","link":"/tags/mac/"},{"name":"辅助工具","slug":"辅助工具","link":"/tags/辅助工具/"},{"name":"vim","slug":"vim","link":"/tags/vim/"},{"name":"IDE","slug":"IDE","link":"/tags/IDE/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"生命周期","slug":"生命周期","link":"/tags/生命周期/"},{"name":"框架","slug":"框架","link":"/tags/框架/"},{"name":"项目搭建","slug":"项目搭建","link":"/tags/项目搭建/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"配置","slug":"配置","link":"/tags/配置/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"ECMAScript提案","slug":"ECMAScript提案","link":"/tags/ECMAScript提案/"},{"name":"柯里化函数","slug":"柯里化函数","link":"/tags/柯里化函数/"},{"name":"arguments","slug":"arguments","link":"/tags/arguments/"},{"name":"caller","slug":"caller","link":"/tags/caller/"},{"name":"callee","slug":"callee","link":"/tags/callee/"},{"name":"变量提升","slug":"变量提升","link":"/tags/变量提升/"},{"name":"call","slug":"call","link":"/tags/call/"},{"name":"apply","slug":"apply","link":"/tags/apply/"},{"name":"bind","slug":"bind","link":"/tags/bind/"},{"name":"错误类型","slug":"错误类型","link":"/tags/错误类型/"},{"name":"执行上下文","slug":"执行上下文","link":"/tags/执行上下文/"},{"name":"鼠标相关","slug":"鼠标相关","link":"/tags/鼠标相关/"},{"name":"new","slug":"new","link":"/tags/new/"},{"name":"forEach","slug":"forEach","link":"/tags/forEach/"},{"name":"promise","slug":"promise","link":"/tags/promise/"},{"name":"es6","slug":"es6","link":"/tags/es6/"},{"name":"javasript","slug":"javasript","link":"/tags/javasript/"},{"name":"正则","slug":"正则","link":"/tags/正则/"},{"name":"number","slug":"number","link":"/tags/number/"},{"name":"prototype","slug":"prototype","link":"/tags/prototype/"},{"name":"原型链","slug":"原型链","link":"/tags/原型链/"},{"name":"上拉加载","slug":"上拉加载","link":"/tags/上拉加载/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"异常处理","slug":"异常处理","link":"/tags/异常处理/"},{"name":"try-catch","slug":"try-catch","link":"/tags/try-catch/"},{"name":"webSocket","slug":"webSocket","link":"/tags/webSocket/"},{"name":"html5","slug":"html5","link":"/tags/html5/"},{"name":"node","slug":"node","link":"/tags/node/"},{"name":"目录结构","slug":"目录结构","link":"/tags/目录结构/"},{"name":"thinkjs","slug":"thinkjs","link":"/tags/thinkjs/"},{"name":"颜色算法","slug":"颜色算法","link":"/tags/颜色算法/"},{"name":"颜色选择器","slug":"颜色选择器","link":"/tags/颜色选择器/"},{"name":"颜色转换","slug":"颜色转换","link":"/tags/颜色转换/"},{"name":"颜色","slug":"颜色","link":"/tags/颜色/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"nuxt","slug":"nuxt","link":"/tags/nuxt/"},{"name":"服务端项目集成","slug":"服务端项目集成","link":"/tags/服务端项目集成/"},{"name":"chrome","slug":"chrome","link":"/tags/chrome/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"辅助知识","slug":"辅助知识","link":"/tags/辅助知识/"},{"name":"mobx","slug":"mobx","link":"/tags/mobx/"},{"name":"数据层","slug":"数据层","link":"/tags/数据层/"},{"name":"router","slug":"router","link":"/tags/router/"},{"name":"路由","slug":"路由","link":"/tags/路由/"},{"name":"redux","slug":"redux","link":"/tags/redux/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"this","slug":"this","link":"/tags/this/"},{"name":"Array.prototype.slice","slug":"Array-prototype-slice","link":"/tags/Array-prototype-slice/"},{"name":"package.json","slug":"package-json","link":"/tags/package-json/"},{"name":"window","slug":"window","link":"/tags/window/"},{"name":"cmd","slug":"cmd","link":"/tags/cmd/"},{"name":"touch","slug":"touch","link":"/tags/touch/"},{"name":"array","slug":"array","link":"/tags/array/"},{"name":"优化","slug":"优化","link":"/tags/优化/"},{"name":"项目打包","slug":"项目打包","link":"/tags/项目打包/"},{"name":"parcel","slug":"parcel","link":"/tags/parcel/"},{"name":"packaging","slug":"packaging","link":"/tags/packaging/"},{"name":"babel","slug":"babel","link":"/tags/babel/"},{"name":"resolve","slug":"resolve","link":"/tags/resolve/"},{"name":"webpack路径简写","slug":"webpack路径简写","link":"/tags/webpack路径简写/"},{"name":"stage","slug":"stage","link":"/tags/stage/"},{"name":"开发经验","slug":"开发经验","link":"/tags/开发经验/"},{"name":"cache","slug":"cache","link":"/tags/cache/"},{"name":"webpack2.x的变化","slug":"webpack2-x的变化","link":"/tags/webpack2-x的变化/"}],"categories":[{"name":"css应用","slug":"css应用","link":"/categories/css应用/"},{"name":"css3","slug":"css3","link":"/categories/css3/"},{"name":"辅助工具","slug":"辅助工具","link":"/categories/辅助工具/"},{"name":"IDE","slug":"IDE","link":"/categories/IDE/"},{"name":"react","slug":"react","link":"/categories/react/"},{"name":"ECMAScript","slug":"ECMAScript","link":"/categories/ECMAScript/"},{"name":"javaScript基础","slug":"javaScript基础","link":"/categories/javaScript基础/"},{"name":"javaScript应用","slug":"javaScript应用","link":"/categories/javaScript应用/"},{"name":"javaScript原理","slug":"javaScript原理","link":"/categories/javaScript原理/"},{"name":"html5","slug":"html5","link":"/categories/html5/"},{"name":"javaScript阅读","slug":"javaScript阅读","link":"/categories/javaScript阅读/"},{"name":"node","slug":"node","link":"/categories/node/"},{"name":"方案思路","slug":"方案思路","link":"/categories/方案思路/"},{"name":"nuxt","slug":"nuxt","link":"/categories/nuxt/"},{"name":"chrome","slug":"chrome","link":"/categories/chrome/"},{"name":"辅助知识","slug":"辅助知识","link":"/categories/辅助知识/"},{"name":"webpack","slug":"webpack","link":"/categories/webpack/"},{"name":"命令行","slug":"命令行","link":"/categories/命令行/"},{"name":"vue","slug":"vue","link":"/categories/vue/"},{"name":"array","slug":"array","link":"/categories/array/"},{"name":"优化","slug":"优化","link":"/categories/优化/"},{"name":"parcel","slug":"parcel","link":"/categories/parcel/"}]}