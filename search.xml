<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>颜色转换</title>
      <link href="/2019/07/14/knowledge/color/"/>
      <url>/2019/07/14/knowledge/color/</url>
      
        <content type="html"><![CDATA[<h3 id="常用的颜色模式"><a href="#常用的颜色模式" class="headerlink" title="常用的颜色模式"></a>常用的颜色模式</h3><blockquote><p>目前常用的颜色模式有 RGB，HSV，HLS，CMYK，CMY这几种颜色分别在不同的领域使用，也有特定的应用场景。</p></blockquote><p><strong>RGB</strong></p><blockquote><p>RGB(Red)色彩模式是工业界的一种颜色标准，是通过对红(R)、绿(G)、蓝(B)<br>三个颜色通道的变化以及它们相互之间的叠加来得到各式各样的颜色的，RGB即是代表红、绿、蓝三个通道的颜色，这个标准几乎包括了人类视力所能感知的所有颜色，是目前运用最广的颜色系统之一。RGB模式又称加色模式。<br><img src="/2019/07/14/knowledge/color/rgb.jpg" title="RGB示意图"><br><strong>取值范围：</strong><br>R(red:0~255),<br>G(green:0~255),<br>B(blue:0~255)。</p></blockquote><p><strong> HSV </strong></p><blockquote><p>HSV(Hue, Saturation, Value)是根据颜色的直观特性由A. R. Smith在1978年创建的一种颜色空间, 也称六角锥体模型(Hexcone Model)。这个模型中颜色的参数分别是：色调（H），饱和度（S），明度（V）。<br><img src="/2019/07/14/knowledge/color/hsv.jpg" title="HSV/HSL示意图"><br><strong>取值范围：</strong><br>H(Hue:0~360),<br>S(Saturation:0~100),<br>V(Value:0~100)。</p></blockquote><p><strong>HSL</strong></p><blockquote><p>HSL(Hue, Saturation, Lightness)色彩模式是工业界的一种颜色标准，是通过对色相(H)、饱和度(S)、亮度(L)三个颜色通道的变化以及它们相互之间的叠加来得到各式各样的颜色的，HSL即是代表色相，饱和度，亮度三个通道的颜色，这个标准几乎包括了人类视力所能感知的所有颜色，是迄今运用最广的颜色系统之一。<br><img src="/2019/07/14/knowledge/color/hsl.png" title="HSV/HSL示意图"><br><strong>取值范围：</strong><br>H(Hue:0~360),<br>S(Saturation:0~100),<br>L(Lightness:0~100)。</p></blockquote><p><strong>CMYK/CMY</strong></p><blockquote><p>印刷四色模式是彩色印刷时采用的一种套色模式，利用色料的三原色混色原理，加上黑色油墨，共计四种颜色混合叠加，形成所谓“全彩印刷”。四种标准颜色是：C：Cyan = 青色，又称为‘天蓝色’或是‘湛蓝’M：Magenta = 品红色，又称为‘洋红色’；Y：Yellow = 黄色；K：blacK=黑色，虽然有文献解释说这里的K应该是Key Color（定位套版色），但其实是和制版时所用的定位套版观念混淆而有此一说。此处缩写使用最后一个字母K而非开头的B，是因为在整体色彩学中已经将B给了RGB的Blue蓝色。CMYK模式又称减色模式。<br><img src="/2019/07/14/knowledge/color/cmyk.jpeg" title="HSV/HSL示意图"><br><strong>取值范围：</strong><br>C(Cyan:0~100),<br>M(Magenta:0~100),<br>Y(Yellow:0~100),<br>K(blacK:0~100),</p></blockquote><p><strong>HEX 格式</strong></p><blockquote><p>HEX(十六进制颜色码)就是在软件中设定颜色值的代码。在很多软件中，都会遇到设定颜色值的问题，发展来源 人的眼睛看到的颜色有两种： 一种是发光体发出的颜色，比如计算机显示器屏幕显示的颜色； 另一种是物体本身不发光，而是反射的光产生 十六进制颜色。所有的颜色都可转换为HEX格式</p></blockquote><h3 id="颜色的互相转换"><a href="#颜色的互相转换" class="headerlink" title="颜色的互相转换"></a>颜色的互相转换</h3><p><strong>RGB 转换 HEX</strong></p><blockquote><p>RGB转HEX实际机会RGB的每一个参数转16进制然后组合，举个例子：RGB(92,184,232);92 / 16 = 5余12 -&gt; 5C;84 / 16 = 11余8 -&gt; B8;232 / 16 = 14余8 -&gt; E8;</p></blockquote><p>最简单代码实现代码实现</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function rgbToHex(r,g,b)&#123;</span><br><span class="line">    let hex = &apos;#&apos;;</span><br><span class="line">    hex+=r.toString(16);</span><br><span class="line">    hex+=g.toString(16);</span><br><span class="line">    hex+=b.toString(16);</span><br><span class="line">    return hex; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而在网页中获取到的颜色大多是RGB(0,0,0),或者rgb(0,0,0)，#000;为应对不同浏览器的不同表现我们对代码进行健壮处理，代码如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">function colorToHex (color)&#123;</span><br><span class="line">    let that = color;</span><br><span class="line">    //十六进制颜色值的正则表达式</span><br><span class="line">    let reg = /^#([0-9a-fA-f]&#123;3&#125;|[0-9a-fA-f]&#123;6&#125;)$/;</span><br><span class="line">    // 如果是rgb颜色表示</span><br><span class="line">    if (/^(rgb|RGB)/.test(that)) &#123;</span><br><span class="line">        let aColor = that.replace(/(?:\(|\)|rgb|RGB)*/g, &quot;&quot;).split(&quot;,&quot;);</span><br><span class="line">        let strHex = &quot;#&quot;;</span><br><span class="line">        for (let i=0; i&lt;aColor.length; i++) &#123;</span><br><span class="line">            let hex = Number(aColor[i]).toString(16);</span><br><span class="line">            if (hex.length &lt; 2) &#123;</span><br><span class="line">                hex = &apos;0&apos; + hex;    </span><br><span class="line">            &#125;</span><br><span class="line">            strHex += hex;</span><br><span class="line">        &#125;</span><br><span class="line">        if (strHex.length !== 7) &#123;</span><br><span class="line">            strHex = that;    </span><br><span class="line">        &#125;</span><br><span class="line">        return strHex;</span><br><span class="line">    &#125; else if (reg.test(that)) &#123;</span><br><span class="line">        let aNum = that.replace(/#/,&quot;&quot;).split(&quot;&quot;);</span><br><span class="line">        if (aNum.length === 6) &#123;</span><br><span class="line">            return that;    </span><br><span class="line">        &#125; else if(aNum.length === 3) &#123;</span><br><span class="line">            let numHex = &quot;#&quot;;</span><br><span class="line">            for (let i=0; i&lt;aNum.length; i+=1) &#123;</span><br><span class="line">                numHex += (aNum[i] + aNum[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            return numHex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return that;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在网上我看到一个大神的写法很简洁但是不太明白他的算法原理我就先把代码放这<br><a href="https://www.cnblogs.com/gossip/p/6058158.html" target="_blank" rel="noopener">原文地址</a></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function colorRGB2Hex(color) &#123;</span><br><span class="line">    let rgb = color.split(&apos;,&apos;);</span><br><span class="line">    let r = parseInt(rgb[0].split(&apos;(&apos;)[1]);</span><br><span class="line">    let g = parseInt(rgb[1]);</span><br><span class="line">    let b = parseInt(rgb[2].split(&apos;)&apos;)[0]);</span><br><span class="line"> </span><br><span class="line">    let hex = &quot;#&quot; + ((1 &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).slice(1);</span><br><span class="line">    return hex;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>HEX 转换 RGB</strong><br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function hexToRgb(sColor)&#123;</span><br><span class="line">    sColor = sColor.toLowerCase();</span><br><span class="line">    //十六进制颜色值的正则表达式</span><br><span class="line">    let reg = /^#([0-9a-fA-f]&#123;3&#125;|[0-9a-fA-f]&#123;6&#125;)$/;</span><br><span class="line">    // 如果是16进制颜色</span><br><span class="line">    if (sColor &amp;&amp; reg.test(sColor)) &#123;</span><br><span class="line">        if (sColor.length === 4) &#123;</span><br><span class="line">            let sColorNew = &quot;#&quot;;</span><br><span class="line">            for (let i=1; i&lt;4; i+=1) &#123;</span><br><span class="line">                sColorNew += sColor.slice(i, i+1).concat(sColor.slice(i, i+1));    </span><br><span class="line">            &#125;</span><br><span class="line">            sColor = sColorNew;</span><br><span class="line">        &#125;</span><br><span class="line">        //处理六位的颜色值</span><br><span class="line">        let sColorChange = [];</span><br><span class="line">        for (let i=1; i&lt;7; i+=2) &#123;</span><br><span class="line">            sColorChange.push(parseInt(&quot;0x&quot;+sColor.slice(i, i+2)));    </span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;RGB(&quot; + sColorChange.join(&quot;,&quot;) + &quot;)&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return sColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>HSL 转换 RGB</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function hslToRgb(h, s, l) &#123;</span><br><span class="line">    let r, g, b;</span><br><span class="line"></span><br><span class="line">    if(s == 0) &#123;</span><br><span class="line">        r = g = b = l; // achromatic</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        let hue2rgb = function hue2rgb(p, q, t) &#123;</span><br><span class="line">            if(t &lt; 0) t += 1;</span><br><span class="line">            if(t &gt; 1) t -= 1;</span><br><span class="line">            if(t &lt; 1/6) return p + (q - p) * 6 * t;</span><br><span class="line">            if(t &lt; 1/2) return q;</span><br><span class="line">            if(t &lt; 2/3) return p + (q - p) * (2/3 - t) * 6;</span><br><span class="line">            return p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        let q = l &lt; 0.5 ? l * (1 + s) : l + s - l * s;</span><br><span class="line">        let p = 2 * l - q;</span><br><span class="line">        r = hue2rgb(p, q, h + 1/3);</span><br><span class="line">        g = hue2rgb(p, q, h);</span><br><span class="line">        b = hue2rgb(p, q, h - 1/3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>RGB 转换 HSL</strong><br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function rgbToHsl(r, g, b) &#123;</span><br><span class="line">    r /= 255, g /= 255, b /= 255;</span><br><span class="line">    let max = Math.max(r, g, b), min = Math.min(r, g, b);</span><br><span class="line">    let h, s, l = (max + min) / 2;</span><br><span class="line"></span><br><span class="line">    if (max == min)&#123; </span><br><span class="line">        h = s = 0; // achromatic</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        let d = max - min;</span><br><span class="line">        s = l &gt; 0.5 ? d / (2 - max - min) : d / (max + min);</span><br><span class="line">        switch(max) &#123;</span><br><span class="line">            case r: h = (g - b) / d + (g &lt; b ? 6 : 0); break;</span><br><span class="line">            case g: h = (b - r) / d + 2; break;</span><br><span class="line">            case b: h = (r - g) / d + 4; break;</span><br><span class="line">        &#125;</span><br><span class="line">        h /= 6;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return [h, s, l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>RGB 转换 HSV</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">function rgbToHsv(r, g, b) &#123;</span><br><span class="line">    r = r / 255;</span><br><span class="line">    g = g / 255;</span><br><span class="line">    b = b / 255;</span><br><span class="line">    let h, s, v;</span><br><span class="line">    let min = Math.min(r, g, b);</span><br><span class="line">    let max = v = Math.max(r, g, b);</span><br><span class="line">    let l = (min + max) / 2;</span><br><span class="line">    let difference = max - min;</span><br><span class="line"></span><br><span class="line">    if (max == min) &#123;</span><br><span class="line">        h = 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        switch (max) &#123;</span><br><span class="line">        case r:</span><br><span class="line">            h = (g - b) / difference + (g &lt; b ? 6 : 0);</span><br><span class="line">            break;</span><br><span class="line">        case g:</span><br><span class="line">            h = 2.0 + (b - r) / difference;</span><br><span class="line">            break;</span><br><span class="line">        case b:</span><br><span class="line">            h = 4.0 + (r - g) / difference;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        h = Math.round(h * 60);</span><br><span class="line">    &#125;</span><br><span class="line">    if (max == 0) &#123;</span><br><span class="line">        s = 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        s = 1 - min / max;</span><br><span class="line">    &#125;</span><br><span class="line">    s = Math.round(s * 100);</span><br><span class="line">    v = Math.round(v * 100);</span><br><span class="line">    return &#123;s,h,v&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>HSV 转换 RGB</strong></p><p><strong>RGB 转换 CMYK</strong></p><blockquote><p>RGB 转 CMYK 实际的实现方案是先由 RGB 转 CMY 在由 CMY 修正为 CMYK<br>RGB 转 CMY 的转换公式<br>c = 255 - r;<br>m = 255 - g;<br>y = 255 - b;</p></blockquote><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function rgbToCmyk (params)&#123;</span><br><span class="line">    let &#123; r, g, b &#125; = params;</span><br><span class="line">    const saturation = 2.55</span><br><span class="line">    for(let key in params)&#123;</span><br><span class="line">        if(!params[key])&#123;</span><br><span class="line">            throw new Error(`$&#123;key&#125;是必填项`);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let c = 0; </span><br><span class="line">    let m = 255 - g;</span><br><span class="line">    let y = 255 - b;</span><br><span class="line">    let k = Math.min(Math.min(255-r,255-g),255-b)/saturation</span><br><span class="line">    let div = 100-k ? 100-k : 1;</span><br><span class="line">    r = r/saturation;</span><br><span class="line">    g = g/saturation;</span><br><span class="line">    b = b/saturation;</span><br><span class="line">    c = ((100 - r - k) / div)*100;</span><br><span class="line">    m = ((100 - g - k) / div)*100;</span><br><span class="line">    y = ((100 - b - k) / div)*100;</span><br><span class="line">    return &#123;c,m,y,k&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong> CMYK 转换 RGB </strong></p><blockquote><p>CMYK 转 RGB 转换的公式<br>R = 255<em>(100-C)</em>(100-K)/10000；<br>G = 255<em>(100-M)</em>(100-K)/10000；<br>B = 255<em>(100-Y)</em>(100-K)/10000；</p></blockquote><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function cmykToRgb(params)&#123;</span><br><span class="line">    const &#123;c,m,y,k&#125; = params;</span><br><span class="line">    for(let key in params)&#123;</span><br><span class="line">        if(!params[key])&#123;</span><br><span class="line">            throw new Error(`$&#123;key&#125;是必填项`);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">        r:255*(100-c)*(100-k)/10000,</span><br><span class="line">        g:255*(100-m)*(100-k)/10000,</span><br><span class="line">        b:255*(100-y)*(100-k)/10000</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="颜色选择器的实现思路"><a href="#颜色选择器的实现思路" class="headerlink" title="颜色选择器的实现思路"></a>颜色选择器的实现思路</h3><blockquote><p>颜色选择的选择和使用，原本 input 有 color 类型 来调用系统的颜色选择，但是这个方案有系统兼容问题，而且在mac 和window 两个系统的表现形式不一样所以只能放弃，自己实现一个颜色选择器。<br>既然这样我们来利用我们前面学习的知识来分析一下这样的需求，首先我们要看常用的颜色选择器，都是两个选择色板如下是mac的颜色选择器：<br><img src="/2019/07/14/knowledge/color/input-color.png" title="HSV/HSL示意图"><br>我们不难看出上边的圆是有两个参数控制下边的滑条是由一个参数控制也就是说三个参数控制的交互界面是比较友好的所以 CMYK 模式的方案被排除剩下 RGB SHV SHL CMY 这四个方案，由于RGB 和 CMY 模式是你必须选择三个颜色后才知道最终颜色所以这个方案不合适，最终只剩下 SHV 和 SHL 对比 mac 的颜色选择我们可以发现其实就是使用了这个模式<br>最终定的是SHV模式如下图滑条是 H(色调)选择取值范围是0~360 , 下面的矩形是由 S (饱和度) 和 V (明度) 分别表示 水平轴和垂直轴，最会在使用上面的色彩转换方法将 SHV 转为 RGB 设置到元素上。<br><img src="/2019/07/14/knowledge/color/my-color.png" title="HSV/HSL示意图"><br>具体实现这里就不展开了有了显现原理，具体实现就很简单了。</p></blockquote><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://www.jianshu.com/p/f03e9ac9c9ef" target="_blank" rel="noopener">深入理解color model(颜色模型)</a></p>]]></content>
      
      
      <categories>
          
          <category> 方案思路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 颜色算法 </tag>
            
            <tag> 颜色选择器 </tag>
            
            <tag> 颜色转换 </tag>
            
            <tag> 颜色 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node异常处理机制详解</title>
      <link href="/2019/07/13/node/try-catch/"/>
      <url>/2019/07/13/node/try-catch/</url>
      
        <content type="html"><![CDATA[<hr><ol><li>assert()</li><li>assert.ok()</li><li>assert.equal()</li><li>assert.notEqual()</li><li>assert.deepEqual()</li><li>assert.notDeepEqual()</li><li>assert.strictEqual()</li><li>assert.notStrictEqual()</li><li>assert.throws()</li><li>assert.ifError()</li><li>assert.fail()</li></ol><hr><p>assert模块是Node的内置模块，主要用于断言。如果表达式不符合预期，就抛出一个错误。该模块提供11个方法，但只有少数几个是常用的。</p><h3 id="1-assert"><a href="#1-assert" class="headerlink" title="1. assert()"></a>1. assert()</h3><p>assert方法接受两个参数，当第一个参数对应的布尔值为true时，不会有任何提示，返回undefined。当第一个参数对应的布尔值为false时，会抛出一个错误，该错误的提示信息就是第二个参数设定的字符串。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 格式</span><br><span class="line">assert(value, message)</span><br><span class="line"></span><br><span class="line">// 例子</span><br><span class="line">var assert = require(&apos;assert&apos;);</span><br><span class="line"></span><br><span class="line">function add (a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var expected = add(1,2);</span><br><span class="line">assert( expected === 3, &apos;预期1加2等于3&apos;);</span><br></pre></td></tr></table></figure><p>上面代码不会有任何输出，因为assert方法的第一个参数是true。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assert( expected === 4, &apos;预期1加2等于3&apos;)</span><br><span class="line">// AssertionError: 预期1加2等于3</span><br></pre></td></tr></table></figure><p>上面代码会抛出一个错误，因为assert方法的第一个参数是false。</p><h3 id="2-assert-ok"><a href="#2-assert-ok" class="headerlink" title="2. assert.ok()"></a>2. assert.ok()</h3><p>ok是assert方法的另一个名字，与assert方法完全一样。</p><h3 id="3-assert-equal"><a href="#3-assert-equal" class="headerlink" title="3. assert.equal()"></a>3. assert.equal()</h3><p>equal方法接受三个参数，第一个参数是实际值，第二个是预期值，第三个是错误的提示信息。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 格式</span><br><span class="line">assert.equal(actual, expected, [message])</span><br><span class="line"></span><br><span class="line">assert.equal(true, value, message);</span><br><span class="line">// 等同于</span><br><span class="line">assert(value, message);</span><br><span class="line"></span><br><span class="line">// 例子</span><br><span class="line">var assert = require(&apos;assert&apos;);</span><br><span class="line"></span><br><span class="line">function add (a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var expected = add(1,2);</span><br><span class="line"></span><br><span class="line">// 以下三句效果相同</span><br><span class="line">assert(expected == 3, &apos;预期1+2等于3&apos;);</span><br><span class="line">assert.ok(expected == 3, &apos;预期1+2等于3&apos;);</span><br><span class="line">assert.equal(expected, 3, &apos;预期1+2等于3&apos;);</span><br></pre></td></tr></table></figure><p>equal方法内部使用的是相等运算符（==），而不是严格运算符（===），进行比较运算。</p><h3 id="4-assert-notEqual"><a href="#4-assert-notEqual" class="headerlink" title="4. assert.notEqual()"></a>4. assert.notEqual()</h3><p>notEqual方法的用法与equal方法类似，但只有在实际值等于预期值时，才会抛出错误。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 格式</span><br><span class="line">assert.notEqual(actual, expected, [message])</span><br><span class="line"></span><br><span class="line">// 用法</span><br><span class="line">var assert = require(&apos;assert&apos;);</span><br><span class="line"></span><br><span class="line">function add (a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var expected = add(1,2);</span><br><span class="line"></span><br><span class="line">// 以下三种写法效果相同</span><br><span class="line">assert(expected != 4, &apos;预期不等于4&apos;);</span><br><span class="line">assert.ok(expected != 4, &apos;预期不等于4&apos;);</span><br><span class="line">assert.notEqual(expected, 4, &apos;预期不等于4&apos;);</span><br></pre></td></tr></table></figure><p>notEqual方法内部使用不相等运算符（!=），而不是严格不相等运算符（!==），进行比较运算。</p><h3 id="5-assert-deepEqual"><a href="#5-assert-deepEqual" class="headerlink" title="5. assert.deepEqual()"></a>5. assert.deepEqual()</h3><p>deepEqual方法用来比较两个对象。只要它们的属性一一对应，且值都相等，就认为两个对象相等，否则抛出一个错误。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 格式</span><br><span class="line">assert.deepEqual(actual, expected, [message])</span><br><span class="line"></span><br><span class="line">// 例子</span><br><span class="line">var assert = require(&apos;assert&apos;);</span><br><span class="line"></span><br><span class="line">var list1 = [1, 2, 3, 4, 5];</span><br><span class="line">var list2 = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">assert.deepEqual(list1, list2, &apos;预期两个数组应该有相同的属性&apos;);</span><br><span class="line"></span><br><span class="line">var person1 = &#123; &quot;name&quot;:&quot;john&quot;, &quot;age&quot;:&quot;21&quot; &#125;;</span><br><span class="line">var person2 = &#123; &quot;name&quot;:&quot;john&quot;, &quot;age&quot;:&quot;21&quot; &#125;;</span><br><span class="line"></span><br><span class="line">assert.deepEqual(person1, person2, &apos;预期两个对象应该有相同的属性&apos;);</span><br></pre></td></tr></table></figure><h3 id="6-assert-notDeepEqual"><a href="#6-assert-notDeepEqual" class="headerlink" title="6. assert.notDeepEqual()"></a>6. assert.notDeepEqual()</h3><p>notDeepEqual方法与deepEqual方法正好相反，用来断言两个对象是否不相等。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 格式</span><br><span class="line">assert.notDeepEqual(actual, expected, [message])</span><br><span class="line"></span><br><span class="line">// 例子</span><br><span class="line">var assert = require(&apos;assert&apos;);</span><br><span class="line"></span><br><span class="line">var list1 = [1, 2, ,3, 4, 5];</span><br><span class="line">var list2 = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">assert.notDeepEqual(list1, list2, &apos;预期两个对象不相等&apos;);</span><br><span class="line"></span><br><span class="line">var person1 = &#123; &quot;name&quot;:&quot;john&quot;, &quot;age&quot;:&quot;21&quot; &#125;;</span><br><span class="line">var person2 = &#123; &quot;name&quot;:&quot;jane&quot;, &quot;age&quot;:&quot;19&quot; &#125;;</span><br><span class="line"></span><br><span class="line">// deepEqual checks the elements in the objects are identical</span><br><span class="line">assert.notDeepEqual(person1, person2, &apos;预期两个对象不相等&apos;);</span><br></pre></td></tr></table></figure><h3 id="7-assert-strictEqual"><a href="#7-assert-strictEqual" class="headerlink" title="7. assert.strictEqual()"></a>7. assert.strictEqual()</h3><p>strictEqual方法使用严格相等运算符（===），比较两个表达式。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 格式</span><br><span class="line">assert.strictEqual(actual, expected, [message])</span><br><span class="line"></span><br><span class="line">// 例子</span><br><span class="line">var assert = require(&apos;assert&apos;);</span><br><span class="line"></span><br><span class="line">assert.strictEqual(1, &apos;1&apos;, &apos;预期严格相等&apos;);</span><br><span class="line">// AssertionError: 预期严格相等</span><br></pre></td></tr></table></figure><h3 id="8-assert-notStrictEqual"><a href="#8-assert-notStrictEqual" class="headerlink" title="8. assert.notStrictEqual()"></a>8. assert.notStrictEqual()</h3><p>assert.notStrictEqual方法使用严格不相等运算符（!==），比较两个表达式。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 格式</span><br><span class="line">assert.notStrictEqual(actual, expected, [message])</span><br><span class="line"></span><br><span class="line">// 例子</span><br><span class="line">var assert = require(&apos;assert&apos;);</span><br><span class="line"></span><br><span class="line">assert.notStrictEqual(1, true, &apos;预期严格不相等&apos;);</span><br></pre></td></tr></table></figure><h3 id="9-assert-throws"><a href="#9-assert-throws" class="headerlink" title="9. assert.throws()"></a>9. assert.throws()</h3><p>throws方法预期某个代码块会抛出一个错误，且抛出的错误符合指定的条件。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 格式</span><br><span class="line">assert.throws(block, [error], [message])</span><br><span class="line"></span><br><span class="line">// 例一，抛出的错误符合某个构造函数</span><br><span class="line">assert.throws(</span><br><span class="line">  function() &#123;</span><br><span class="line">    throw new Error(&quot;Wrong value&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">  Error,</span><br><span class="line">  &apos;不符合预期的错误类型&apos;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 例二、抛出错误的提示信息符合正则表达式</span><br><span class="line">assert.throws(</span><br><span class="line">  function() &#123;</span><br><span class="line">    throw new Error(&quot;Wrong value&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">  /value/,</span><br><span class="line">  &apos;不符合预期的错误类型&apos;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 例三、抛出的错误符合自定义函数的校验</span><br><span class="line">assert.throws(</span><br><span class="line">  function() &#123;</span><br><span class="line">    throw new Error(&quot;Wrong value&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">  function(err) &#123;</span><br><span class="line">    if ( (err instanceof Error) &amp;&amp; /value/.test(err) ) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &apos;不符合预期的错误类型&apos;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="10-assert-doesNotThrow"><a href="#10-assert-doesNotThrow" class="headerlink" title="10. assert.doesNotThrow()"></a>10. assert.doesNotThrow()</h3><p>doesNotThrow方法与throws方法正好相反，预期某个代码块不抛出错误。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 格式</span><br><span class="line">assert.doesNotThrow(block, [message])</span><br><span class="line"></span><br><span class="line">// 用法</span><br><span class="line">assert.doesNotThrow(</span><br><span class="line">  function() &#123;</span><br><span class="line">    console.log(&quot;Nothing to see here&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">  &apos;预期不抛出错误&apos;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="11-assert-ifError"><a href="#11-assert-ifError" class="headerlink" title="11. assert.ifError()"></a>11. assert.ifError()</h3><p>ifError方法断言某个表达式是否false，如果该表达式对应的布尔值等于true，就抛出一个错误。它对于验证回调函数的第一个参数十分有用，如果该参数为true，就表示有错误。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 格式</span><br><span class="line">assert.ifError(value)</span><br><span class="line"></span><br><span class="line">// 用法</span><br><span class="line">function sayHello(name, callback) &#123;</span><br><span class="line">  var error = false;</span><br><span class="line">  var str   = &quot;Hello &quot;+name;</span><br><span class="line">  callback(error, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// use the function</span><br><span class="line">sayHello(&apos;World&apos;, function(err, value)&#123;</span><br><span class="line">  assert.ifError(err);</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="12-assert-fail"><a href="#12-assert-fail" class="headerlink" title="12. assert.fail()"></a>12. assert.fail()</h3><p>fail方法用于抛出一个错误。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 格式</span><br><span class="line">assert.fail(actual, expected, message, operator)</span><br><span class="line"></span><br><span class="line">// 例子</span><br><span class="line">var assert = require(&apos;assert&apos;);</span><br><span class="line"></span><br><span class="line">assert.fail(21, 42, &apos;Test Failed&apos;, &apos;###&apos;)</span><br><span class="line">// AssertionError: Test Failed</span><br><span class="line">assert.fail(21, 21, &apos;Test Failed&apos;, &apos;###&apos;)</span><br><span class="line">// AssertionError: Test Failed</span><br><span class="line">assert.fail(21, 42, undefined, &apos;###&apos;)</span><br><span class="line">// AssertionError: 21 ### 42</span><br></pre></td></tr></table></figure><p>该方法共有四个参数，但是不管参数是什么值，它总是抛出一个错误。如果message参数对应的布尔值不为false，抛出的错误信息就是message，否则错误信息就是“实际值 + 分隔符 + 预期值”。</p>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异常处理 </tag>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器缓存</title>
      <link href="/2019/07/13/packaging/webpack/cache/"/>
      <url>/2019/07/13/packaging/webpack/cache/</url>
      
        <content type="html"><![CDATA[<h2 id="浏览器缓存的分类"><a href="#浏览器缓存的分类" class="headerlink" title="浏览器缓存的分类"></a>浏览器缓存的分类</h2><p>浏览器缓存分为两种类型：</p><p>强缓存：也称为本地缓存，不向服务器发送请求，直接使用客户端本地缓存数据</p><p>协商缓存：也称304缓存，向服务器发送请求，由服务器判断请求文件是否发生改变。如果未发生改变，则返回304状态码，通知客户端直接使用本地缓存；如果发生改变，则直接返回请求文件。</p><p>浏览器缓存机制的过程如下：<br><img src="./flow.png" alt="缓存机制"></p><h2 id="强缓存-本地缓存"><a href="#强缓存-本地缓存" class="headerlink" title="强缓存(本地缓存)"></a>强缓存(本地缓存)</h2><p>强缓存是最彻底的缓存，无需向服务器发送请求，通常用于css、js、图片等静态资源。浏览器发送请求后会先判断本地是否有缓存。如果无缓存，则直接向服务器发送请求；如果有缓存，则判断缓存是否命中强缓存，如果命中则直接使用本地缓存，如果没命中则向服务器发送请求。判断是否命中本地缓存的方法有两种：Expires和Cache-Control。</p><h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p>Expires是http1.0的响应头，代表的含义是资源本地缓存的过期时间，由服务器设定。服务器返回给浏览器的响应头中如果包含Expires字段，浏览器发送请求时拿当前时间和Expires字段值进行比较，判断资源缓存是否失效。如下图所示：</p><p><img src="./expires.png" alt="Expires"></p><p>Date代表请求资源的时间，Expires代表资源缓存的过期时间，可以看到服务器设置资源的缓存时间为5分钟。2017-02-10 07:53:19之前，请求这个资源就是命中本地缓存。超过这个时间再去请求则不命中。</p><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>Cache-Control是http1.0中新增的字段。由于Expires设置的是资源的具体过期时间，如果服务器时间和客户端时间不一样，就会造成缓存错乱，比如认为调节了客户端的时间，所以设置资源有效期的时长更合理。http1.1添加了Cache-Control的max-age字段。max-age代表的含义是资源有效期的时长，是一个相对时长，单位为s。</p><p><img src="./cache-Control.png" alt="Cache-Control"></p><p>Cache-Control: max-age = 300设置资源的过期时间为5分钟。浏览器再次发送请求时，会把第一次请求的时间和max-age字段值相加和当前时间比较，以此判断是否命中本地缓存。max-age使用的都是客户端时间，比Expires更可靠。如果max-age和Expires同时出现，max-age的优先级更高。Cache-Control提供了更多的字段来控制缓存：</p><ul><li>no-store,不判断强缓存和协商缓存，服务器直接返回完整资源</li><li>no-cache,不判断强缓存，每次都需要向浏览器发送请求，进行协商缓存判断</li><li>public,指示响应可被任何缓存区缓存</li><li>private,通常只为单个用户缓存，不允许任何共享缓存对其进行缓存,通常用于用户个人信息</li></ul><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>协商缓存的判断在服务器端进行，判断是否命中的依据就是这次请求和上次请求之间资源是否发生改变。未发生改变命中，发生改变则未命中。判断文件是否发生改变的方法有两个：Last-Modified、If-Modified-Since和Etag、If-None-Match。</p><h3 id="Last-Modified、If-Modified-Since"><a href="#Last-Modified、If-Modified-Since" class="headerlink" title="Last-Modified、If-Modified-Since"></a>Last-Modified、If-Modified-Since</h3><p>Last-Modified是http1.0中的响应头字段，代表请求的资源最后一次的改变时间。If-Modified-Since是http1.0的请求头，If-Modified-Since的值是上次请求服务器返回的Last-Modified的值。浏览器第一次请求资源时，服务器返回Last-Modified,浏览器缓存该值。浏览器第二次请求资源时，用于缓存的Last-Modified赋值给If-Modified-Since，发送给服务器。服务器判断If-Modified-Since和服务器本地的Last-Modified是否相等。如果相等，说明资源未发生改变，命中协商缓存；如果不相等，说明资源发生改变，未命中协商缓存。</p><p><img src="./last.png" alt="Last-Modified"></p><p>可以看到该请求返回的是304状态码，说明资源的Last-Modified未改变，所以这次请求的Last-Modified和If-Modified-Since是一致的。</p><h3 id="Etag、If-None-Match"><a href="#Etag、If-None-Match" class="headerlink" title="Etag、If-None-Match"></a>Etag、If-None-Match</h3><p>Last-Modified、If-Modified-Since使用的都是服务器提供的时间，所以相对来说还是很可靠的。但是由于修改时间的精确级别或者定期生成文件这种情况，会造成一定的错误。所以http1.1添加Etag、If-None-Match字段，完善协商缓存的判断。Etag是根据资源文件内容生成的资源唯一标识符，一旦资源内容发生改变，Etag就会发生改变。基于内容的标识符比基于修改时间的更可靠。If-None-Match的值是上次请求服务器返回的Etag的值。Etag、If-None-Match的判断过程和Last-Modified、If-Modified-Since一致，Etag、If-None-Match的优先级更高。</p><h2 id="工程中遇到的问题"><a href="#工程中遇到的问题" class="headerlink" title="工程中遇到的问题"></a>工程中遇到的问题</h2><p>强缓存的优势很明显，无需向服务器发送请求，节省了大量的时间和带宽。但是有一个问题，缓存有效期内想更新资源怎么办？我在工程中还遇到另外一个问题，一个项目有四个环境，测试环境、开发环境、在线确认环境、在线环境，四个环境的域名相同，这样就会造成四个环境的缓存共用问题。比如先访问了测试环境，index.js被换成到浏览器中，再切换到在线环境，在线环境会请求index.js,此时浏览器就会使用本地缓存中测试环境的index.js,造成代码错乱。</p><p>如何使强缓存失效，是问题的关键。通常的解决方法是更新文件名，文件名不一样的话，浏览器就会重新请求资源。我们要保证新发布版本和不同环境中的文件名是不一样的。其中一种方法在文件名后加版本号：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">index.js?version=1</span><br><span class="line">index.css?version=1</span><br></pre></td></tr></table></figure><p>webpack提供了很简单的方法可以配置缓存。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &quot;main.js&quot;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: &quot;/build&quot;,</span><br><span class="line">    filename: &quot;main.[hash].js&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>通过hash占位符，在每次生成打包文件时，都会通过文件内容生成唯一的hash，并添加到输出的文件名中。如果有多个入口文件，可以使用name占位符设置输出：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">      main:&quot;main.js&quot;,</span><br><span class="line">      sub:&quot;sub.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: &quot;/dist&quot;,</span><br><span class="line">    filename: &quot;[name].[hash].js&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这时候有一个问题是，此时的hash是根据两个文件的内容来生成的，两个文件名使用的hash是一致的。如果main.js和sub.js只有一个改变，两个文件名都会改变，两个文件都会重新请求，造成资源浪费。webpack提供了chunkhash来代替hash在多入口情况下使用。chunkhash是根据每个入口文件单独生成的哈希值，避免上述情况。</p><p>webpack打包动态生成文件名，我们需要动态地把文件引用插入到html启动文件中。html-webpack-plugin可以帮我很好地解决这个问题。html-webpack-plugin可以动态地生成一个html文件，并在html文件中动态插入webpack打包生成的资源文件。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line">var webpackConfig = &#123;</span><br><span class="line">  entry: &apos;main.js&apos;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: &apos;/dist&apos;,</span><br><span class="line">    publicPath: &apos;/dist&apos;,</span><br><span class="line">    filename: &apos;main.[hash].js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [new HtmlWebpackPlugin()]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>默认在webpackConfig.output.path路径下生成index.html,生成的html文件如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Webpack App&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;script src=&quot;main.2a6c1fee4b5b0d2c9285.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>通常html启动文件都有自定义的内容，所以html-webpack-plugin提供了模板功能，template字段设置模板的路径，html-webpack-plugin以template为模板，动态添加webpack打包生成的资源路径。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line">var webpackConfig = &#123;</span><br><span class="line">  entry: &apos;main.js&apos;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: &apos;/dist&apos;,</span><br><span class="line">    publicPath: &apos;/dist&apos;,</span><br><span class="line">    filename: &apos;main.[hash].js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [new HtmlWebpackPlugin(</span><br><span class="line">      &#123;</span><br><span class="line">          template:&apos;index.html&apos;</span><br><span class="line">      &#125;</span><br><span class="line">  )]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>生成的index.html内容（\dist\index.html）:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;stat-front&lt;/title&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;//at.alicdn.com/t/font_ejl5slgdvtg74x6r.css&quot;&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot; class=&quot;app-root&quot;&gt;</span><br><span class="line">        &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;!-- built files will be auto injected --&gt;</span><br><span class="line">    &lt;script src=&quot;main.2a6c1fee4b5b0d2c9285.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>最开始的时候静态的index.html在根目录下，webpack-dev-server设置的启动路径就是根目录下的index.html,如果要启动生成的index.html，还需要设置webpackConfig.output.publicPath：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line">var webpackConfig = &#123;</span><br><span class="line">  entry: &apos;main.js&apos;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: &apos;/dist&apos;,</span><br><span class="line">    publicPath: &apos;/&apos;,</span><br><span class="line">    filename: &apos;main.[hash].js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [new HtmlWebpackPlugin(</span><br><span class="line">      &#123;</span><br><span class="line">          template:&apos;index.html&apos;</span><br><span class="line">      &#125;</span><br><span class="line">  )]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样webpack-dev-server在内存中生成的资源都存放在根目录下，生成的index.html会代替原index.html启动。</p><h3 id="进阶内容："><a href="#进阶内容：" class="headerlink" title="进阶内容："></a>进阶内容：</h3><p><a href="https://doc.webpack-china.org/guides/caching/" target="_blank" rel="noopener">webpack缓存</a></p>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
            <tag> packaging </tag>
            
            <tag> 开发经验 </tag>
            
            <tag> cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>babel-stage-x</title>
      <link href="/2019/07/13/packaging/webpack/babel-stage/"/>
      <url>/2019/07/13/packaging/webpack/babel-stage/</url>
      
        <content type="html"><![CDATA[<h1 id="babel-stage"><a href="#babel-stage" class="headerlink" title="babel-stage"></a>babel-stage</h1><blockquote><p>关于stage-x第一次遇见是在第一次搭建react项目时，项目搭建完成后在里边写箭头函数时报错,但当时没有深究只是在网上查找了一个方案说在loader里添加一个stage-0就能解决但是但是没有总结，后来babel升级遇到几次.babelrc的代码报错一直没有找到原因，后来总算知道原来是缺少插件</p></blockquote><h2 id="如何区分Babel中的stage-0-stage-1-stage-2以及stage-3"><a href="#如何区分Babel中的stage-0-stage-1-stage-2以及stage-3" class="headerlink" title="如何区分Babel中的stage-0,stage-1,stage-2以及stage-3"></a>如何区分Babel中的stage-0,stage-1,stage-2以及stage-3</h2><h4 id="大家知道，将ES6代码编译为ES5时，我们常用到Babel这个编译工具。大家参考一些网上的文章或者官方文档，里面常会建议大家在-babelrc中输入如下代码："><a href="#大家知道，将ES6代码编译为ES5时，我们常用到Babel这个编译工具。大家参考一些网上的文章或者官方文档，里面常会建议大家在-babelrc中输入如下代码：" class="headerlink" title="大家知道，将ES6代码编译为ES5时，我们常用到Babel这个编译工具。大家参考一些网上的文章或者官方文档，里面常会建议大家在.babelrc中输入如下代码："></a>大家知道，将ES6代码编译为ES5时，我们常用到Babel这个编译工具。大家参考一些网上的文章或者官方文档，里面常会建议大家在.babelrc中输入如下代码：</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;: [</span><br><span class="line">      &quot;es2015&quot;,</span><br><span class="line">      &quot;react&quot;,</span><br><span class="line">      &quot;stage-0&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;plugins&quot;: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在来说明下这个配置文件是什么意思。首先，这个配置文件是针对babel 6的。Babel 6做了一系列模块化，不像Babel 5一样把所有的内容都加载。比如需要编译ES6，我们需要设置presets为”es2015”，也就是预先加载es6编译的相关模块，如果需要编译jsx，需要预先加载”react”这个模块。那问题来了，这个”stage-0”又代表什么呢？ 有了”react-0”，是否又有诸如”stage-1”, “stage-2”等等呢？<br>事实上， ”stage-0”是对ES7一些提案的支持，Babel通过插件的方式引入，让Babel可以编译ES7代码。当然由于ES7没有定下来，所以这些功能随时肯能被废弃掉的。现在我们来一一分析里面都有什么。</p><h2 id="法力无边的stage-0"><a href="#法力无边的stage-0" class="headerlink" title="法力无边的stage-0"></a>法力无边的stage-0</h2><p>为什么说“stage-0” 法力无边呢，因为它包含stage-1, stage-2以及stage-3的所有功能，同时还另外支持如下两个功能插件：</p><p><img src="https://babeljs.io/docs/plugins/transform-do-expressions" alt="* transform-do-expressions"><br><img src="https://babeljs.io/docs/plugins/transform-function-bind" alt="* transform-function-bind"></p><p>用过React的同学可能知道，jsx对条件表达式支持的不是太好，你不能很方便的使用if/else表达式，要么你使用三元表达，要么用函数。例如你不能写如下的代码：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var App = React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">        let &#123; color &#125; = this.props;</span><br><span class="line"></span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&quot;parents&quot;&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    if(color == &apos;blue&apos;) &#123;</span><br><span class="line">                        &lt;BlueComponent/&gt;;</span><br><span class="line">                    &#125;else if(color == &apos;red&apos;) &#123;</span><br><span class="line">                        &lt;RedComponent/&gt;;</span><br><span class="line">                    &#125;else &#123;</span><br><span class="line">                        &lt;GreenComponent/&gt;; &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在React中你只能写成这样：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var App = React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">        let &#123; color &#125; = this.props;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        const getColoredComponent = color =&gt; &#123;</span><br><span class="line">            if(color === &apos;blue&apos;) &#123; return &lt;BlueComponent/&gt;; &#125;</span><br><span class="line">            if(color === &apos;red&apos;) &#123; return &lt;RedComponent/&gt;; &#125;</span><br><span class="line">            if(color === &apos;green&apos;) &#123; return &lt;GreenComponent/&gt;; &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&quot;parents&quot;&gt;</span><br><span class="line">                &#123; getColoredComponent(color) &#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>transform-do-expressions 这个插件就是为了方便在 jsx写if/else表达式而提出的，我们可以重写下代码。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var App = React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">        let &#123; color &#125; = this.props;</span><br><span class="line"></span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&quot;parents&quot;&gt;</span><br><span class="line">                &#123;do &#123;</span><br><span class="line">                    if(color == &apos;blue&apos;) &#123;</span><br><span class="line">                        &lt;BlueComponent/&gt;;</span><br><span class="line">                    &#125;else if(color == &apos;red&apos;) &#123;</span><br><span class="line">                        &lt;RedComponent/&gt;;</span><br><span class="line">                    &#125;else &#123;</span><br><span class="line">                        &lt;GreenComponent/&gt;; &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>再说说 transform-function-bind, 这个插件其实就是提供过 :: 这个操作符来方便快速切换上下文， 如下面的代码：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">obj::func</span><br><span class="line">// is equivalent to:</span><br><span class="line">func.bind(obj)</span><br><span class="line"></span><br><span class="line">obj::func(val)</span><br><span class="line">// is equivalent to:</span><br><span class="line">func.call(obj, val)</span><br><span class="line"></span><br><span class="line">::obj.func(val)</span><br><span class="line">// is equivalent to:</span><br><span class="line">func.call(obj, val)</span><br><span class="line"></span><br><span class="line">// 再来一个复杂点的样例</span><br><span class="line"></span><br><span class="line">const box = &#123;</span><br><span class="line">  weight: 2,</span><br><span class="line">  getWeight() &#123; return this.weight; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const &#123; getWeight &#125; = box;</span><br><span class="line"></span><br><span class="line">console.log(box.getWeight()); // prints &apos;2&apos;</span><br><span class="line"></span><br><span class="line">const bigBox = &#123; weight: 10 &#125;;</span><br><span class="line">console.log(bigBox::getWeight()); // prints &apos;10&apos;</span><br><span class="line"></span><br><span class="line">// Can be chained:</span><br><span class="line">function add(val) &#123; return this + val; &#125;</span><br><span class="line"></span><br><span class="line">console.log(bigBox::getWeight()::add(5)); // prints &apos;15&apos;</span><br></pre></td></tr></table></figure><p>如果想更屌点，还可以写出更牛逼的代码：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const &#123; map, filter &#125; = Array.prototype;</span><br><span class="line"></span><br><span class="line">let sslUrls = document.querySelectorAll(&apos;a&apos;)</span><br><span class="line">                ::map(node =&gt; node.href)</span><br><span class="line">                ::filter(href =&gt; href.substring(0, 5) === &apos;https&apos;);</span><br><span class="line"></span><br><span class="line">console.log(sslUrls);</span><br></pre></td></tr></table></figure><h2 id="包罗万象的stage-1"><a href="#包罗万象的stage-1" class="headerlink" title="包罗万象的stage-1"></a>包罗万象的stage-1</h2><p>stage-1除了包含stage-2和stage-3，还包含了下面4个插件：</p><p><img src="http://babeljs.io/docs/plugins/transform-class-constructor-call" alt="* transform-class-constructor-call (Deprecated)"><br><img src="http://babeljs.io/docs/plugins/transform-class-properties" alt="* transform-class-properties"><br><img src="http://babeljs.io/docs/plugins/transform-export-extensions" alt="* transform-export-extensions"></p><h2 id="深藏不露的stage-2"><a href="#深藏不露的stage-2" class="headerlink" title="深藏不露的stage-2"></a>深藏不露的stage-2</h2><p>为什么说 stage-2深藏不露呢，因为它很低调，低调到你可以忽略它，但事实上，它很有内涵的。它除了覆盖stage-3的所有功能，还支持如下两个插件：</p><p><img src="http://babeljs.io/docs/plugins/syntax-trailing-function-commas/" alt="* syntax-trailing-function-commas"><br><img src="http://babeljs.io/docs/plugins/transform-object-rest-spread" alt="* ransform-object-reset-spread"></p><h3 id="syntax-trailing-function-commas"><a href="#syntax-trailing-function-commas" class="headerlink" title="syntax-trailing-function-commas"></a>syntax-trailing-function-commas</h3><p>这个插件让人一看觉得挺没趣的，让人甚至觉得它有点鸡肋。因它不是对ES6功能的增加，而是为了增强代码的可读性和可修改性而提出的。如下面的代码所示：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 假设有如下的一个函数，它有两个参数</span><br><span class="line">function clownPuppiesEverywhere(</span><br><span class="line">  param1,</span><br><span class="line">  param2</span><br><span class="line">) &#123; /* ... */ &#125;</span><br><span class="line"></span><br><span class="line">clownPuppiesEverywhere(</span><br><span class="line">  &apos;foo&apos;,</span><br><span class="line">  &apos;bar&apos;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 有一天，它需要变成3个参数，你需要这样修改</span><br><span class="line">function clownPuppiesEverywhere(</span><br><span class="line">  param1,</span><br><span class="line">- param2</span><br><span class="line">+ param2, // 这一行得加一个逗号</span><br><span class="line">+ param3  // 增加参数param3</span><br><span class="line">) &#123; /* ... */ &#125;</span><br><span class="line"></span><br><span class="line">clownPuppiesEverywhere(</span><br><span class="line">  &apos;foo&apos;,</span><br><span class="line">- &apos;bar&apos;</span><br><span class="line">+ &apos;bar&apos;, // 这里的修改为逗号</span><br><span class="line">+ &apos;baz&apos;  // 增加新的参数</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 看到没？ 我们修改了4行代码。。啊啊。修改了4行代码。</span><br></pre></td></tr></table></figure><p>修改了4行代码，嗯嗯嗯。。追求高效的程序猿想想了，以后如果有更多参数了，我是不是要改等多行，得想想，代码改的越少越好，于是有了下面的改动。。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 我们来重新定义一下函数</span><br><span class="line">function clownPuppiesEverywhere(</span><br><span class="line">  param1,</span><br><span class="line">  param2, // 注意这里，我们加了一个逗号哟</span><br><span class="line">) &#123; /* ... */ &#125;</span><br><span class="line"></span><br><span class="line">clownPuppiesEverywhere(</span><br><span class="line">  &apos;foo&apos;,</span><br><span class="line">  &apos;bar&apos;, // 这里我们也加了一个逗号</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 现在函数需要三个参数，我们来修改下</span><br><span class="line">function clownPuppiesEverywhere(</span><br><span class="line">  param1,</span><br><span class="line">  param2,</span><br><span class="line">+ param3, // 增加params3参数</span><br><span class="line">) &#123; /* ... */ &#125;</span><br><span class="line"></span><br><span class="line">clownPuppiesEverywhere(</span><br><span class="line">  &apos;foo&apos;,</span><br><span class="line">  &apos;bar&apos;,</span><br><span class="line">+ &apos;baz&apos;, // 增加第三个参数</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 叮叮当，我们只修改了两行代码就完成了，好开森</span><br></pre></td></tr></table></figure><p>说实话吧，这个功能让人有点很无语。不过程序猿对干净代码的追求真的很让人感动，还是值得鼓励的。这个就是stage-2中”尾逗号函数”功能。哈哈哈哈。</p><h3 id="transform-object-rest-spread"><a href="#transform-object-rest-spread" class="headerlink" title="transform-object-rest-spread"></a>transform-object-rest-spread</h3><p>再来说transform-object-rest-spread， 其实它是对 ES6中解构赋值的一个扩展，因为ES6只支持对数组的解构赋值，对对象是不支持的。如下面的代码所示：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 获取剩下的属性</span><br><span class="line"></span><br><span class="line">let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;</span><br><span class="line">console.log(x); // 1</span><br><span class="line">console.log(y); // 2</span><br><span class="line">console.log(z); // &#123; a: 3, b: 4 &#125;</span><br><span class="line"></span><br><span class="line">// 属性展开</span><br><span class="line">let n = &#123; x, y, ...z &#125;;</span><br><span class="line">console.log(n); // &#123; x: 1, y: 2, a: 3, b: 4 &#125;</span><br></pre></td></tr></table></figure><h2 id="大放异彩的stage3"><a href="#大放异彩的stage3" class="headerlink" title="大放异彩的stage3"></a>大放异彩的stage3</h2><p>为啥说stage3大放异彩呢？因为它支持大名鼎鼎的async和await, 这两个哥们可是解决(Ajax)回调函数的终极解决方法呀！管你什么异步，我都可以用同步的思维来写，ES7里面非常强悍的存在。总的来说，它包含如下两个插件:</p><p><img src="http://babeljs.io/docs/plugins/transform-async-to-generator/" alt="* transform-async-to-generator"><br><img src="http://babeljs.io/docs/plugins/transform-exponentiation-operator" alt="* transform-exponentiation-operator"></p><h3 id="transform-async-to-generator"><a href="#transform-async-to-generator" class="headerlink" title="transform-async-to-generator"></a>transform-async-to-generator</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">transform-async-to-generator主要用来支持ES7中的async和await， 我们可以写出下面的代码：</span><br><span class="line"></span><br><span class="line">const sleep = (timeout)=&gt;&#123;</span><br><span class="line">    return new Promise( (resolve, reject)=&gt;&#123;</span><br><span class="line">        setTimeout(resolve, timeout)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(async ()=&gt;&#123;</span><br><span class="line">    console.time(&quot;async&quot;);</span><br><span class="line">    await sleep(3000);</span><br><span class="line">    console.timeEnd(&quot;async&quot;);</span><br><span class="line">&#125;)()</span><br><span class="line">再来一个实际点的例子</span><br><span class="line"></span><br><span class="line">const fetchUsers = (user)=&gt;&#123;</span><br><span class="line">    return window.fetch(`https://api.douban.com/v2/user/$&#123;user&#125;`).then( res=&gt;res.json())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const getUser = async (user) =&gt;&#123;</span><br><span class="line">    let users = await fetchUsers(user);</span><br><span class="line">    console.log( users);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log( getUser(&quot;flyingzl&quot;)</span><br></pre></td></tr></table></figure><p>提示： 由于asycn和await是ES7里面的内容，现阶段不建议使用。为了顺利运行上面的代码，建议用webpack进行编译。</p><h3 id="transform-exponentiation-operator"><a href="#transform-exponentiation-operator" class="headerlink" title="transform-exponentiation-operator"></a>transform-exponentiation-operator</h3><p>transform-exponentiation-operator这个插件算是一个语法糖，可以通过**这个符号来进行幂操作，想当于Math.pow(a,b)。如下面的样例</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// x ** y</span><br><span class="line"></span><br><span class="line">let squared = 2 ** 2;</span><br><span class="line">// 相当于: 2 * 2</span><br><span class="line"></span><br><span class="line">let cubed = 2 ** 3;</span><br><span class="line">// 相当于: 2 * 2 * 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// x **= y</span><br><span class="line"></span><br><span class="line">let a = 2;</span><br><span class="line">a **= 2;</span><br><span class="line">// 相当于: a = a * a;</span><br><span class="line"></span><br><span class="line">let b = 3;</span><br><span class="line">b **= 3;</span><br><span class="line">// 相当于: b = b * b * b;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> node </tag>
            
            <tag> webpack </tag>
            
            <tag> babel </tag>
            
            <tag> packaging </tag>
            
            <tag> stage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React生命周期</title>
      <link href="/2019/07/13/React/lifecyce/"/>
      <url>/2019/07/13/React/lifecyce/</url>
      
        <content type="html"><![CDATA[<h1 id="React生命周期"><a href="#React生命周期" class="headerlink" title="React生命周期"></a>React生命周期</h1><h3 id="用一个表格表示生命周期"><a href="#用一个表格表示生命周期" class="headerlink" title="用一个表格表示生命周期"></a>用一个表格表示生命周期</h3><table><thead><tr><th>函数</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td>getDefaultProps</td><td style="text-align:center">作用于组件类，只调用一次，返回对象用于设置默认的props，对于引用值，会在实例中共享</td></tr><tr><td>getInitialState</td><td style="text-align:center">作用于组件的实例，在实例创建时调用一次，用于初始化每个实例的state，此时可以访问this.props</td></tr><tr><td>componentWillMount</td><td style="text-align:center">在完成首次渲染之前调用，此时仍可以修改组件的state</td></tr><tr><td>render</td><td style="text-align:center">必选的方法，创建虚拟DOM，该方法具有特殊的规则： 1.只能通过this.props和this.state访问数据  2.可以返回null、false或任何React组件  3.只能出现一个顶级组件（不能返回数组） 4.不能改变组件的状态   5.不能修改DOM的输出</td></tr><tr><td>componentDidMount</td><td style="text-align:center">真实的DOM被渲染出来后调用，在该方法中可通过this.getDOMNode()访问到真实的DOM元素。此时已可以使用其他类库来操作这个DOM。在服务端中，该方法不会被调用</td></tr><tr><td>componentWillReceiveProps</td><td style="text-align:center">组件接收到新的props时调用，并将其作为参数nextProps使用，此时可以更改组件props及state</td></tr><tr><td>shouldComponentUpdate</td><td style="text-align:center">组件是否应当渲染新的props或state，返回false表示跳过后续的生命周期方法，通常不需要使用以避免出现bug。在出现应用的瓶颈时，可通过该方法进行适当的优化</td></tr><tr><td>componentWillUpdate</td><td style="text-align:center">接收到新的props或者state后，进行渲染之前调用，此时不允许更新props或state</td></tr><tr><td>componentDidUpdate</td><td style="text-align:center">完成渲染新的props或者state后调用，此时可以访问到新的DOM元素</td></tr><tr><td>componentWillUnmount</td><td style="text-align:center">组件被移除之前被调用，可以用于做一些清理工作，在componentDidMount方法中添加的所有任务都需要在该方法中撤销，比如创建的定时器或添加的事件监听器</td></tr></tbody></table><h2 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h2><h5 id="首次实例化"><a href="#首次实例化" class="headerlink" title="首次实例化"></a>首次实例化</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getDefaultProps</span><br><span class="line">getInitialState</span><br><span class="line">componentWillMount</span><br><span class="line">render</span><br><span class="line">componentDidMount</span><br></pre></td></tr></table></figure><h5 id="实例化完成后的更新"><a href="#实例化完成后的更新" class="headerlink" title="实例化完成后的更新"></a>实例化完成后的更新</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getInitialState</span><br><span class="line">componentWillMount</span><br><span class="line">render</span><br><span class="line">componentDidMount</span><br></pre></td></tr></table></figure><h5 id="存在期"><a href="#存在期" class="headerlink" title="存在期"></a>存在期</h5><p>组件已存在时的状态改变<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">componentWillReceiveProps</span><br><span class="line">shouldComponentUpdate</span><br><span class="line">componentWillUpdate</span><br><span class="line">render</span><br><span class="line">componentDidUpdate</span><br></pre></td></tr></table></figure></p><h5 id="销毁-amp-清理期"><a href="#销毁-amp-清理期" class="headerlink" title="销毁&amp;清理期"></a>销毁&amp;清理期</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">componentWillUnmount</span><br></pre></td></tr></table></figure><p>说明<br>生命周期共提供了10个不同的API。</p><h5 id="1-getDefaultProps"><a href="#1-getDefaultProps" class="headerlink" title="1.getDefaultProps"></a>1.getDefaultProps</h5><p>作用于组件类，只调用一次，返回对象用于设置默认的props，对于引用值，会在实例中共享。</p><h5 id="2-getInitialState"><a href="#2-getInitialState" class="headerlink" title="2.getInitialState"></a>2.getInitialState</h5><p>作用于组件的实例，在实例创建时调用一次，用于初始化每个实例的state，此时可以访问this.props。</p><h5 id="3-componentWillMount"><a href="#3-componentWillMount" class="headerlink" title="3.componentWillMount"></a>3.componentWillMount</h5><p>在完成首次渲染之前调用，此时仍可以修改组件的state。</p><h5 id="4-render"><a href="#4-render" class="headerlink" title="4.render"></a>4.render</h5><p>必选的方法，创建虚拟DOM，该方法具有特殊的规则：</p><p>只能通过this.props和this.state访问数据<br>可以返回null、false或任何React组件<br>只能出现一个顶级组件（不能返回数组）<br>不能改变组件的状态<br>不能修改DOM的输出</p><h5 id="5-componentDidMount"><a href="#5-componentDidMount" class="headerlink" title="5.componentDidMount"></a>5.componentDidMount</h5><p>真实的DOM被渲染出来后调用，在该方法中可通过this.getDOMNode()访问到真实的DOM元素。此时已可以使用其他类库来操作这个DOM。</p><p>在服务端中，该方法不会被调用。</p><h5 id="6-componentWillReceiveProps"><a href="#6-componentWillReceiveProps" class="headerlink" title="6.componentWillReceiveProps"></a>6.componentWillReceiveProps</h5><p>组件接收到新的props时调用，并将其作为参数nextProps使用，此时可以更改组件props及state。</p><pre><code>componentWillReceiveProps: function(nextProps) {    if (nextProps.bool) {        this.setState({            bool: true        });    }}</code></pre><h5 id="7-shouldComponentUpdate"><a href="#7-shouldComponentUpdate" class="headerlink" title="7.shouldComponentUpdate"></a>7.shouldComponentUpdate</h5><p>组件是否应当渲染新的props或state，返回false表示跳过后续的生命周期方法，通常不需要使用以避免出现bug。在出现应用的瓶颈时，可通过该方法进行适当的优化。</p><p>在首次渲染期间或者调用了forceUpdate方法后，该方法不会被调用</p><h5 id="8-componentWillUpdate"><a href="#8-componentWillUpdate" class="headerlink" title="8.componentWillUpdate"></a>8.componentWillUpdate</h5><p>接收到新的props或者state后，进行渲染之前调用，此时不允许更新props或state。</p><h5 id="9-componentDidUpdate"><a href="#9-componentDidUpdate" class="headerlink" title="9.componentDidUpdate"></a>9.componentDidUpdate</h5><p>完成渲染新的props或者state后调用，此时可以访问到新的DOM元素。</p><h5 id="10-componentWillUnmount"><a href="#10-componentWillUnmount" class="headerlink" title="10.componentWillUnmount"></a>10.componentWillUnmount</h5><p>组件被移除之前被调用，可以用于做一些清理工作，在componentDidMount方法中添加的所有任务都需要在该方法中撤销，比如创建的定时器或添加的事件监听器。</p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> 生命周期 </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack中resolve模块</title>
      <link href="/2019/07/13/packaging/webpack/resolve/"/>
      <url>/2019/07/13/packaging/webpack/resolve/</url>
      
        <content type="html"><![CDATA[<h1 id="Resolve"><a href="#Resolve" class="headerlink" title="Resolve"></a>Resolve</h1><blockquote><p>这些选项能设置模块如何被解析。webpack 提供合理的默认值，但是还是可能会修改一些解析的细节。</p></blockquote><h3 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h3><p>object</p><blockquote><p>配置模块如何解析。例如，当在 ES2015 中调用 import “lodash”，resolve 选项能够对 webpack 查找 “lodash” 的方式去做修改（查看模块）。</p></blockquote><h3 id="resolve-alias"><a href="#resolve-alias" class="headerlink" title="resolve.alias"></a>resolve.alias</h3><p>object</p><p>创建 import 或 require 的别名，来确保模块引入变得更简单。例如，一些位于 src/ 文件夹下的常用模块：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alias: &#123;</span><br><span class="line">  Utilities: path.resolve(__dirname, &apos;src/utilities/&apos;),</span><br><span class="line">  Templates: path.resolve(__dirname, &apos;src/templates/&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在，替换「在导入时使用相对路径」这种方式，就像这样：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Utility from &apos;../../utilities/utility&apos;;</span><br></pre></td></tr></table></figure></p><p>你可以这样使用别名：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Utility from &apos;Utilities/utility&apos;;</span><br></pre></td></tr></table></figure></p><p><strong> 也可以在给定对象的键后的末尾添加 $，以表示精准匹配：</strong><br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alias: &#123;</span><br><span class="line">  xyz$: path.resolve(__dirname, &apos;path/to/file.js&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这将产生以下结果：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import Test1 from &apos;xyz&apos;; // 精确匹配，所以 path/to/file.js 被解析和导入</span><br><span class="line">import Test2 from &apos;xyz/file.js&apos;; // 精确匹配，触发普通解析</span><br></pre></td></tr></table></figure></p><p>下面的表格展示了一些其他情况：</p><table><thead><tr><th style="text-align:left">别名:</th><th style="text-align:left">import”xyz”</th><th style="text-align:left">import”xyz/file.js”</th></tr></thead><tbody><tr><td style="text-align:left">{}</td><td style="text-align:left">/abc/node_modules/xyz/index.js</td><td style="text-align:left">/abc/node_modules/xyz/file.js</td></tr><tr><td style="text-align:left">{ xyz: “/abs/path/to/file.js” }</td><td style="text-align:left">/abs/path/to/file.js</td><td style="text-align:left">error</td></tr><tr><td style="text-align:left">{ xyz$: “/abs/path/to/file.js” }</td><td style="text-align:left">/abs/path/to/file.js</td><td style="text-align:left">/abc/node_modules/xyz/file.js</td></tr><tr><td style="text-align:left">{ xyz: “./dir/file.js” }</td><td style="text-align:left">/abc/dir/file.js</td><td style="text-align:left">error</td></tr><tr><td style="text-align:left">{ xyz$: “./dir/file.js” }</td><td style="text-align:left">/abc/dir/file.js</td><td style="text-align:left">/abc/node_modules/xyz/file.js</td></tr><tr><td style="text-align:left">{ xyz: “/some/dir” }</td><td style="text-align:left">/some/dir/index.js</td><td style="text-align:left">/some/dir/file.js</td></tr><tr><td style="text-align:left">{ xyz$: “/some/dir” }</td><td style="text-align:left">/some/dir/index.js</td><td style="text-align:left">/abc/node_modules/xyz/file.js</td></tr><tr><td style="text-align:left">{ xyz: “./dir” }</td><td style="text-align:left">/abc/dir/index.js</td><td style="text-align:left">/abc/dir/file.js</td></tr><tr><td style="text-align:left">{ xyz: “modu” }</td><td style="text-align:left">/abc/node_modules/modu/index.js</td><td style="text-align:left">/abc/node_modules/modu/file.js</td></tr><tr><td style="text-align:left">{ xyz$: “modu” }</td><td style="text-align:left">/abc/node_modules/modu/index.js</td><td style="text-align:left">/abc/node_modules/xyz/file.js</td></tr><tr><td style="text-align:left">{ xyz: “modu/some/file.js” }</td><td style="text-align:left">/abc/node_modules/modu/some/file.js</td><td style="text-align:left">error</td></tr><tr><td style="text-align:left">{ xyz: “modu/dir” }</td><td style="text-align:left">/abc/node_modules/modu/dir/index.js</td><td style="text-align:left">/abc/node_modules/dir/file.js</td></tr><tr><td style="text-align:left">{ xyz: “xyz/dir” }</td><td style="text-align:left">/abc/node_modules/xyz/dir/index.js</td><td style="text-align:left">/abc/node_modules/xyz/dir/file.js</td></tr><tr><td style="text-align:left">{ xyz$: “xyz/dir” }</td><td style="text-align:left">/abc/node_modules/xyz/dir/index.js</td><td style="text-align:left">/abc/node_modules/xyz/file.js</td></tr></tbody></table><p>如果在 package.json 中定义，index.js 可能会被解析为另一个文件。</p><p><strong> /abc/node_modules 也可能在 /node_modules 中解析。</strong></p><h3 id="resolve-aliasFields"><a href="#resolve-aliasFields" class="headerlink" title="resolve.aliasFields"></a>resolve.aliasFields</h3><p>string</p><p>指定一个字段，例如 browser，根据此规范进行解析。默认：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aliasFields: [&quot;browser&quot;]</span><br></pre></td></tr></table></figure></p><h3 id="resolve-cacheWithContext"><a href="#resolve-cacheWithContext" class="headerlink" title="resolve.cacheWithContext"></a>resolve.cacheWithContext</h3><p>boolean ( webpack 3.1.0 以后版本)</p><p>如果启用了不安全的缓存，则包含request.context在缓存中。该enhanced-resolve模块考虑了该选项。因为解析缓存中的webpack 3.1.0上下文在提供解析或解析的插件时被忽略。这解决了性能回归。</p><h3 id="resolve-descriptionFiles"><a href="#resolve-descriptionFiles" class="headerlink" title="resolve.descriptionFiles"></a>resolve.descriptionFiles</h3><p>array</p><p>用于描述的 JSON 文件。默认：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">descriptionFiles: [&quot;package.json&quot;]</span><br></pre></td></tr></table></figure></p><h3 id="resolve-enforceExtension"><a href="#resolve-enforceExtension" class="headerlink" title="resolve.enforceExtension"></a>resolve.enforceExtension</h3><p>boolean</p><p>如果是 true，将不允许无扩展名(extension-less)文件。默认如果 ./foo 有 .js 扩展，require(‘./foo’) 可以正常运行。但如果启用此选项，只有 require(‘./foo.js’) 能够正常工作。默认：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enforceExtension: false</span><br></pre></td></tr></table></figure></p><h3 id="resolve-enforceModuleExtension"><a href="#resolve-enforceModuleExtension" class="headerlink" title="resolve.enforceModuleExtension"></a>resolve.enforceModuleExtension</h3><p>boolean</p><p>对模块是否需要使用的扩展（例如 loader）。默认：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enforceModuleExtension: false</span><br></pre></td></tr></table></figure></p><h3 id="resolve-extensions"><a href="#resolve-extensions" class="headerlink" title="resolve.extensions"></a>resolve.extensions</h3><p>array</p><p>自动解析确定的扩展。默认值为：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extensions: [&quot;.js&quot;, &quot;.json&quot;]</span><br></pre></td></tr></table></figure></p><p>能够使用户在引入模块时不带扩展：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import File from &apos;../path/to/file&apos;</span><br></pre></td></tr></table></figure><p>使用此选项，会覆盖默认数组，这就意味着 webpack 将不再尝试使用默认扩展来解析模块。对于使用其扩展导入的模块，例如，import SomeFile from “./somefile.ext”，要想正确的解析，一个包含“*”的字符串必须包含在数组中。</p><h3 id="resolve-mainFields"><a href="#resolve-mainFields" class="headerlink" title="resolve.mainFields"></a>resolve.mainFields</h3><p>array</p><p>当从 npm 包中导入模块时（例如，import * as D3 from “d3”），此选项将决定在 package.json 中使用哪个字段导入模块。根据 webpack 配置中指定的 target 不同，默认值也会有所不同。</p><p>当 target 属性设置为 webworker, web 或者没有指定，默认值为：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mainFields: [&quot;browser&quot;, &quot;module&quot;, &quot;main&quot;]</span><br></pre></td></tr></table></figure></p><p>对于其他任意的 target（包括 node），默认值为：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mainFields: [&quot;module&quot;, &quot;main&quot;]</span><br></pre></td></tr></table></figure></p><p>例如，D3 的 package.json 含有这些字段：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  main: &apos;build/d3.Node.js&apos;,</span><br><span class="line">  browser: &apos;build/d3.js&apos;,</span><br><span class="line">  module: &apos;index&apos;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这意味着当我们 import * as D3 from “d3”，实际从 browser 属性解析文件。在这里 browser 属性是最优先选择的，因为它是 mainFields 的第一项。同时，由 webpack 打包的 Node.js 应用程序默认会从 module 字段中解析文件。</p><h3 id="resolve-mainFiles"><a href="#resolve-mainFiles" class="headerlink" title="resolve.mainFiles"></a>resolve.mainFiles</h3><p>array</p><p>解析目录时要使用的文件名。默认：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mainFiles: [&quot;index&quot;]</span><br></pre></td></tr></table></figure></p><h3 id="resolve-modules"><a href="#resolve-modules" class="headerlink" title="resolve.modules"></a>resolve.modules</h3><p>array</p><p>告诉 webpack 解析模块时应该搜索的目录。</p><p>绝对路径和相对路径都能使用，但是要知道它们之间有一点差异。</p><p>通过查看当前目录以及祖先路径（即 ./node_modules, ../node_modules 等等），相对路径将类似于 Node 查找 ‘node_modules’ 的方式进行查找。</p><p>使用绝对路径，将只在给定目录中搜索。</p><p>resolve.modules defaults to:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modules: [&quot;node_modules&quot;]</span><br></pre></td></tr></table></figure></p><p>如果你想要添加一个目录到模块搜索目录，此目录优先于 node_modules/ 搜索：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modules: [path.resolve(__dirname, &quot;src&quot;), &quot;node_modules&quot;]</span><br></pre></td></tr></table></figure></p><h3 id="resolve-unsafeCache"><a href="#resolve-unsafeCache" class="headerlink" title="resolve.unsafeCache"></a>resolve.unsafeCache</h3><p>regex array boolean</p><p>启用，会主动缓存模块，但并不安全。传递 true 将缓存一切。默认：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsafeCache: true</span><br></pre></td></tr></table></figure></p><p>正则表达式，或正则表达式数组，可以用于匹配文件路径或只缓存某些模块。例如，只缓存 utilities 模块：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsafeCache: /src\/utilities/</span><br></pre></td></tr></table></figure></p><p>修改缓存路径可能在极少数情况下导致失败。</p><h3 id="resolve-plugins"><a href="#resolve-plugins" class="headerlink" title="resolve.plugins"></a>resolve.plugins</h3><p>应该使用的额外的解析插件列表。它允许插件，如 DirectoryNamedWebpackPlugin。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugins: [new DirectoryNamedWebpackPlugin()]</span><br></pre></td></tr></table></figure></p><h3 id="resolve-symlinks"><a href="#resolve-symlinks" class="headerlink" title="resolve.symlinks"></a>resolve.symlinks</h3><p>boolean</p><p>是否将符号链接(symlink)解析到它们的符号链接位置(symlink location)。默认：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">symlinks: true</span><br></pre></td></tr></table></figure></p><h3 id="resolve-cachePredicate"><a href="#resolve-cachePredicate" class="headerlink" title="resolve.cachePredicate"></a>resolve.cachePredicate</h3><p>function</p><p>决定请求是否应该被缓存的函数。函数传入一个带有 path 和 request 属性的对象。默认：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cachePredicate: function() &#123; return true &#125;</span><br></pre></td></tr></table></figure></p><h3 id="resolveLoader"><a href="#resolveLoader" class="headerlink" title="resolveLoader"></a>resolveLoader</h3><p>object</p><p>这组选项与上面的 resolve 对象的属性集合相同，但仅用于解析 webpack 的 loader 包。默认：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    modules: [&quot;node_modules&quot;],</span><br><span class="line">    extensions: [&quot;.js&quot;, &quot;.json&quot;],</span><br><span class="line">    mainFields: [&quot;loader&quot;, &quot;main&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意，这里你可以使用别名，并且其他特性类似于 resolve 对象。例如，{ txt: ‘raw-loader’ } 会使用 raw-loader 去 shim(填充) txt!templates/demo.txt。</p><h3 id="resolveLoader-moduleExtensions"><a href="#resolveLoader-moduleExtensions" class="headerlink" title="resolveLoader.moduleExtensions"></a>resolveLoader.moduleExtensions</h3><p>array</p><p>在解析模块（例如，loader）时尝试使用的扩展。默认是一个空数组。</p><p>如果你想要不带 -loader 后缀使用 loader，你可以使用：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moduleExtensions: [&apos;-loader&apos;]</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> webpack </tag>
            
            <tag> packaging </tag>
            
            <tag> resolve </tag>
            
            <tag> webpack路径简写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react项目搭建</title>
      <link href="/2019/07/13/React/react/"/>
      <url>/2019/07/13/React/react/</url>
      
        <content type="html"><![CDATA[<h1 id="react项目搭建"><a href="#react项目搭建" class="headerlink" title="react项目搭建"></a>react项目搭建</h1><p>要想使用npm,请先安装nodejs.</p><h2 id="第一步、安装全局包"><a href="#第一步、安装全局包" class="headerlink" title="第一步、安装全局包"></a>第一步、安装全局包</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install babel -g</span><br><span class="line">$ npm install webpack -g</span><br><span class="line">$ npm install webpack-dev-server -g</span><br></pre></td></tr></table></figure><h2 id="第二步、创建根目录"><a href="#第二步、创建根目录" class="headerlink" title="第二步、创建根目录"></a>第二步、创建根目录</h2><p>创建一个根目录，目录名为：reactApp，再使用 npm init 初始化，生成 package.json 文件：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir reactApp</span><br><span class="line">$ cd reactApp/</span><br><span class="line">$ npm init</span><br></pre></td></tr></table></figure></p><h4 id="命令行显示以下内容"><a href="#命令行显示以下内容" class="headerlink" title="命令行显示以下内容"></a>命令行显示以下内容</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">name: (reactApp) runoob-react-test</span><br><span class="line">version: (1.0.0)</span><br><span class="line">description: cllgeek</span><br><span class="line">entry point: (index.js)</span><br><span class="line">test command:</span><br><span class="line">git repository:</span><br><span class="line">keywords:</span><br><span class="line">author:</span><br><span class="line">license: (ISC)</span><br><span class="line">About to write to /Users/tianqixin/www/reactApp/package.json:</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;react-runoob&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;cllgeek test&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;webpack-dev-server --hot&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">    &quot;author&quot;: &quot;&quot;,</span><br><span class="line">    &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">    &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;react&quot;: &quot;^0.14.8&quot;,</span><br><span class="line">    &quot;react-dom&quot;: &quot;^0.14.8&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Is this ok? (yes)</span><br></pre></td></tr></table></figure><h2 id="第三步、添加越来包及插件"><a href="#第三步、添加越来包及插件" class="headerlink" title="第三步、添加越来包及插件"></a>第三步、添加越来包及插件</h2><p>因为我们要使用 React, 所以我们需要先安装它，–save 命令用于将包添加至 package.json 文件。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ npm install react --save</span><br><span class="line">$ npm install react-dom --save</span><br><span class="line">同时我们也要安装一些 babel 插件</span><br><span class="line"></span><br><span class="line">$ npm install babel-core</span><br><span class="line">$ npm install babel-loader</span><br><span class="line">$ npm install babel-preset-react</span><br><span class="line">$ npm install babel-preset-es2015</span><br></pre></td></tr></table></figure></p><h2 id="第四步、创建文件"><a href="#第四步、创建文件" class="headerlink" title="第四步、创建文件"></a>第四步、创建文件</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">接下来我们创建一些必要文件：</span><br><span class="line"></span><br><span class="line">$ touch index.html</span><br><span class="line">$ touch App.jsx</span><br><span class="line">$ touch main.js</span><br><span class="line">$ touch webpack.config.js</span><br></pre></td></tr></table></figure><h2 id="第五步、设置编译器，服务器，载入器"><a href="#第五步、设置编译器，服务器，载入器" class="headerlink" title="第五步、设置编译器，服务器，载入器"></a>第五步、设置编译器，服务器，载入器</h2><p>打开 webpack.config.js 文件添加以下代码:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var config = &#123;</span><br><span class="line">  entry: &apos;./main.js&apos;,</span><br><span class="line"></span><br><span class="line">  output: &#123;</span><br><span class="line">    path:&apos;./&apos;,</span><br><span class="line">    filename: &apos;index.js&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    inline: true,</span><br><span class="line">    port: 8888</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  module: &#123;</span><br><span class="line">    loaders: [ &#123;</span><br><span class="line">      test: /.jsx?$/,</span><br><span class="line">      exclude: /node_modules/,</span><br><span class="line">      loader: &apos;babel&apos;,</span><br><span class="line"></span><br><span class="line">         query: &#123;</span><br><span class="line">            presets: [&apos;es2015&apos;, &apos;react&apos;]</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = config;</span><br></pre></td></tr></table></figure></p><p>entry: 指定打包的入口文件 main.js。<br>output：配置打包结果，path定义了输出的文件夹，filename则定义了打包结果文件的名称。<br>devServer：设置服务器端口号为 8888，端口后你可以自己设定 。<br>module：定义了对模块的处理逻辑，这里可以用loaders定义了一系列的加载器，以及一些正则。当需要加载的文件匹配test的正则时，就会调用后面的loader对文件进行处理，这正是webpack强大的原因。<br>现在打开 package.json 文件，找到 “scripts” 中的 “test” “echo \”Error: no test specified\” &amp;&amp; exit 1″ 使用以下代码替换：</p><p>“start”: “webpack-dev-server –hot”<br>替换后的 package.json 文件 内容如下：</p><p>$ cat package.json<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;runoob-react-test&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;cllgeek test&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;webpack-dev-server --hot&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;react&quot;: &quot;^0.14.7&quot;,</span><br><span class="line">    &quot;react-dom&quot;: &quot;^0.14.7&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在我们可以使用 npm start 命令来启动服务。–hot 命令会在文件变化后重新载入，这样我们就不需要在代码修改后重新刷新浏览器就能看到变化。</p><h2 id="第六步、index-html"><a href="#第六步、index-html" class="headerlink" title="第六步、index.html"></a>第六步、index.html</h2><p>设置 div id = “app” 为我们应用的根元素，并引入 index.js 脚本文件。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset = &quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;React App - cllgeek(cllgeek.com)&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id = &quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script src = &quot;index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><h2 id="第七步、App-jsx-和-main-js"><a href="#第七步、App-jsx-和-main-js" class="headerlink" title="第七步、App.jsx 和 main.js"></a>第七步、App.jsx 和 main.js</h2><p>这是第一个 react 组件。后面的章节我们会详细介绍 React 组件。这个组件将输出 Hello World!!!。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">App.jsx 文件代码</span><br><span class="line">import React from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        Hello World!!!</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure></p><p>我们需要引入组件并将其渲染到根元素 App 上，这样我们才可以在浏览器上看到它。<br>main.js 文件代码<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;;</span><br><span class="line"></span><br><span class="line">import App from &apos;./App.jsx&apos;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.getElementById(&apos;app&apos;))</span><br></pre></td></tr></table></figure></p><p>注意：<br>如果想要组件可以在任何的应用中使用，需要在创建后使用 export 将其导出，在使用组件的文件使用 import将其导入。</p><h2 id="第八步、运行服务"><a href="#第八步、运行服务" class="headerlink" title="第八步、运行服务"></a>第八步、运行服务</h2><p>完成以上配置后，我们即可运行该服务：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm start</span><br><span class="line">通过浏览器访问 http://localhost:7777/，输出结果如下:</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> 项目搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git区分大小写</title>
      <link href="/2019/07/13/git/git-capitalize/"/>
      <url>/2019/07/13/git/git-capitalize/</url>
      
        <content type="html"><![CDATA[<p>其实 git 默认对于文件名大小写是不敏感的,所以上面你修改了首字母大写,但是git 并没有发现代码任何改动.</p><p>那么如何才能让 git 识别文件名大小写变化.</p><p>一  配置git 使其对文件名大小写敏感</p><p>git config core.ignorecase false</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Administrator@SC-202102021413 F:\xunlian\hexo</span><br><span class="line">&gt;git config core.ignorecase false</span><br></pre></td></tr></table></figure><p>二 从git 本地仓库删除此文件,然后添加再提交</p><p>(1) 删除<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Administrator@SC-202102021413 F:\xunlian\hexo</span><br><span class="line">&gt;git rm readme.md</span><br></pre></td></tr></table></figure></p><p>(2) 重新添加<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Administrator@SC-202102021413 F:\xunlian\hexo</span><br><span class="line">&gt;git add Readme.md</span><br></pre></td></tr></table></figure></p><p>(3)提交<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Administrator@SC-202102021413 F:\xunlian\hexo</span><br><span class="line">&gt;git commit -m &apos;Readme.md&apos;</span><br></pre></td></tr></table></figure></p><p>推荐第一种方法,配置好git 对文件名大小写敏感.</p>]]></content>
      
      
      <categories>
          
          <category> 辅助工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 辅助工具 </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git设置上传忽略</title>
      <link href="/2019/07/13/git/git-neglect/"/>
      <url>/2019/07/13/git/git-neglect/</url>
      
        <content type="html"><![CDATA[<h1 id="Git设置上传忽略"><a href="#Git设置上传忽略" class="headerlink" title="Git设置上传忽略"></a>Git设置上传忽略</h1><h2 id="忽略语法规则"><a href="#忽略语法规则" class="headerlink" title="忽略语法规则"></a>忽略语法规则</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># 忽略*.o和*.a文件</span><br><span class="line"></span><br><span class="line"> *.[oa]</span><br><span class="line"></span><br><span class="line"># 忽略*.b和*.B文件，my.b除外</span><br><span class="line"></span><br><span class="line">*.[bB]</span><br><span class="line"></span><br><span class="line">!my.b</span><br><span class="line"></span><br><span class="line"># 忽略dbg文件和dbg目录</span><br><span class="line"></span><br><span class="line">dbg</span><br><span class="line"></span><br><span class="line"># 只忽略dbg目录，不忽略dbg文件</span><br><span class="line"></span><br><span class="line">dbg/</span><br><span class="line"></span><br><span class="line"># 只忽略dbg文件，不忽略dbg目录</span><br><span class="line"></span><br><span class="line">dbg</span><br><span class="line"></span><br><span class="line">!dbg/</span><br><span class="line"></span><br><span class="line"># 只忽略当前目录下的dbg文件和目录，子目录的dbg不在忽略范围内</span><br><span class="line"></span><br><span class="line">/dbg</span><br><span class="line"></span><br><span class="line"># 忽略所有 .a 结尾的文件</span><br><span class="line">*.a</span><br><span class="line"></span><br><span class="line"># 但 lib.a 除外</span><br><span class="line">!lib.a </span><br><span class="line"></span><br><span class="line"># 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span><br><span class="line">/TODO </span><br><span class="line"></span><br><span class="line"># 忽略 build/ 目录下的所有文件</span><br><span class="line">build/ </span><br><span class="line"></span><br><span class="line"># 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br><span class="line">doc/*.txt</span><br></pre></td></tr></table></figure><p>下面介绍3种方法来设置上传忽略配置：</p><h2 id="【方法一】"><a href="#【方法一】" class="headerlink" title="【方法一】"></a>【方法一】</h2><p> 通过配置.git/info/exclude文件来忽略文件。这种方式对仓库全局有效，只能对自己本地仓库有作用，其他人没办法通过这种方式来共享忽略规则，除非他人也修改其本地仓库的该文件。</p><h2 id="【方法二】"><a href="#【方法二】" class="headerlink" title="【方法二】"></a>【方法二】</h2><p> 通过.git/config配置文件的core. Excludesfile选项，指定一个忽略规则文件（完整路径），如下图所示。忽略规则在文件e:/gitignore.txt中（当然该文件名可以任意取）。在config的[remote “origin”]上一行添加 excludesfile = e:/gitignore.text即可<br> <figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> [core]</span><br><span class="line">repositoryformatversion = 0</span><br><span class="line">filemode = false</span><br><span class="line">bare = false</span><br><span class="line">logallrefupdates = true</span><br><span class="line">symlinks = false</span><br><span class="line">ignorecase = true</span><br><span class="line">    excludesfile = e:/gitignore.text</span><br><span class="line">[remote &quot;origin&quot;]</span><br></pre></td></tr></table></figure></p><p> 该方式的作用域是也全局的。</p><h2 id="【方式三】"><a href="#【方式三】" class="headerlink" title="【方式三】"></a>【方式三】</h2><p> 在项目根目录下创建.gitignore文件如果已经创建则不用创建然后在该文件中添加忽略语法<br> .gitignore文件对其所在的目录及所在目录的全部子目录均有效。通过将.gitignore文件添加到仓库，其他开发者更新该文件到本地仓库，以共享同一套忽略规则。</p>]]></content>
      
      
      <categories>
          
          <category> 辅助工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 辅助工具 </tag>
            
            <tag> Git </tag>
            
            <tag> 配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac终端配置sublime和vsCode的快捷方式</title>
      <link href="/2019/07/13/IDE/macPath/"/>
      <url>/2019/07/13/IDE/macPath/</url>
      
        <content type="html"><![CDATA[<h2 id="vsCode的终端命令配置"><a href="#vsCode的终端命令配置" class="headerlink" title="vsCode的终端命令配置"></a>vsCode的终端命令配置</h2><h3 id="mac端配置"><a href="#mac端配置" class="headerlink" title="mac端配置"></a>mac端配置</h3><blockquote><p>vsCode的终端命令配置较为简单，运行VS code并打开命令面板（ ⇧⌘P ），然后输入 shell command 找到: Install ‘code’ command in PATH 就行了。</p></blockquote><p>code命令还支持其他参数，具体看 <a href="http://www.jianshu.com/p/3dda4756eca5" target="_blank" rel="noopener">Visual Studio Code入门</a></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//配好后的使用方法(打开当前路径)</span><br><span class="line">code .</span><br></pre></td></tr></table></figure><h2 id="sublime的终端配置"><a href="#sublime的终端配置" class="headerlink" title="sublime的终端配置"></a>sublime的终端配置</h2><h3 id="mac端配置-1"><a href="#mac端配置-1" class="headerlink" title="mac端配置"></a>mac端配置</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 1. 打开终端</span><br><span class="line">cd ~</span><br><span class="line"></span><br><span class="line">ls -la</span><br><span class="line">//找打.zshrc文件如果安装过atom 就输入 atom .zshrc 如果有 vim 就输入 vim .zshrc这里我用vim</span><br><span class="line"></span><br><span class="line">vim .zshrc</span><br><span class="line"></span><br><span class="line">//到 atom 中</span><br></pre></td></tr></table></figure><p>//把下面内容粘贴到最后</p><p>alias subl=”‘/Applications/Sublime.app/Contents/SharedSupport/bin/subl’”<br>alias nano=”subl”<br>export EDITOR=”subl”</p><p>上面的第一行里是自己sublime的在、安装路径一般只有 Sublime.app 不一样</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//配好后的使用方法(打开当前路径)记得重启终端</span><br><span class="line">subl .</span><br></pre></td></tr></table></figure><p>因为 atom 在这两款中显得较为鸡肋就不做介绍</p>]]></content>
      
      
      <categories>
          
          <category> 辅助工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 辅助工具 </tag>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>parcel使用</title>
      <link href="/2019/07/13/packaging/parcel/parcelDev/"/>
      <url>/2019/07/13/packaging/parcel/parcelDev/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是pracel"><a href="#什么是pracel" class="headerlink" title="什么是pracel"></a>什么是pracel</h3><p>parcel是一个前端项目打包器，现在我们已有的打包器与webpack和gulp。</p><h3 id="为什么要把pracel拿出来说一说"><a href="#为什么要把pracel拿出来说一说" class="headerlink" title="为什么要把pracel拿出来说一说"></a>为什么要把pracel拿出来说一说</h3><p>最近许多的网站推送pracel的相关消息，说什么零配置，打包速度快。</p><h3 id="几个问题"><a href="#几个问题" class="headerlink" title="几个问题"></a>几个问题</h3><ol><li>我们现在使用的打包工具有哪些？</li><li>我们为什么要是用这些打包工具，使用这些打包工具为我们解决了什么问题？</li><li>现在已用到的打包工具给我们造成了什么困扰？</li></ol><h3 id="用parcel建一个简单的项目"><a href="#用parcel建一个简单的项目" class="headerlink" title="用parcel建一个简单的项目"></a>用parcel建一个简单的项目</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>Yarn:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn global add parcel-bundler</span><br></pre></td></tr></table></figure></p><p>npm:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g parcel-bundler</span><br></pre></td></tr></table></figure></p><h4 id="创建package-json"><a href="#创建package-json" class="headerlink" title="创建package.json"></a>创建package.json</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn init -y</span><br></pre></td></tr></table></figure><p>or<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure></p><h4 id="创建一个-index-html-和-index-js-文件。"><a href="#创建一个-index-html-和-index-js-文件。" class="headerlink" title="创建一个 index.html 和 index.js 文件。"></a>创建一个 index.html 和 index.js 文件。</h4><p>index.html<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>index.js<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;hello world&quot;);</span><br></pre></td></tr></table></figure></p><h4 id="在package-json重配置"><a href="#在package-json重配置" class="headerlink" title="在package.json重配置"></a>在package.json重配置</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;parcel index.html -p 4000&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="Babel配置"><a href="#Babel配置" class="headerlink" title="Babel配置"></a>Babel配置</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add babel-preset-env</span><br></pre></td></tr></table></figure><p> .babelrc文件<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [&quot;env&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="PostCSS配置"><a href="#PostCSS配置" class="headerlink" title="PostCSS配置"></a>PostCSS配置</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add postcss-modules autoprefixer</span><br></pre></td></tr></table></figure><p>.postcssrc<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;modules&quot;: true,</span><br><span class="line">  &quot;plugins&quot;: &#123;</span><br><span class="line">    &quot;autoprefixer&quot;: &#123;</span><br><span class="line">      &quot;grid&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="PostHTML配置"><a href="#PostHTML配置" class="headerlink" title="PostHTML配置"></a>PostHTML配置</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add posthtml-img-autosize</span><br></pre></td></tr></table></figure><p>.posthtmlrc<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;plugins&quot;: &#123;</span><br><span class="line">    &quot;posthtml-img-autosize&quot;: &#123;</span><br><span class="line">      &quot;root&quot;: &quot;./images&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/yihaoliu/parcelReact" target="_blank" rel="noopener">parcelReact项目</a>。</p><p>虽然说parcel是零配置但是在没有配置的情况下明显项目的灵活度降低许多，下载react有create-react-app进行构建，vue有vue-cli进行构架其实在项目配置相对来说已经非常少了，但是parcel没有配置文件还是让项目的开发有点难受，比如文件起别名，还有proxyConfig进行跨域处理在项目的开发时期都是很重有的事情，只能说对于一个初学web的人员来说配置变少了尤其是没有用到三大框架的项目组pracel还是使用很方便的，对于一些h5小网页比如基于canvas的小游戏的开发用pracel来构建还是非常方便的，但对于大型网站来说。。。</p>]]></content>
      
      
      <categories>
          
          <category> parcel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> packaging </tag>
            
            <tag> 项目打包 </tag>
            
            <tag> parcel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ECMAScript 提案</title>
      <link href="/2019/07/13/javaScript/ECMAScript/"/>
      <url>/2019/07/13/javaScript/ECMAScript/</url>
      
        <content type="html"><![CDATA[<h2 id="标准的流程包括五个步骤："><a href="#标准的流程包括五个步骤：" class="headerlink" title="标准的流程包括五个步骤："></a>标准的流程包括五个步骤：</h2><h3 id="stage0-strawman"><a href="#stage0-strawman" class="headerlink" title="stage0 strawman"></a>stage0 strawman</h3><p>任何讨论、想法、改变或者还没加到提案的特性都在这个阶段。只有TC39成员可以提交。</p><h3 id="stage1-proposal"><a href="#stage1-proposal" class="headerlink" title="stage1 proposal"></a>stage1 proposal</h3><p>（1）产出一个正式的提案。<br>（2）发现潜在的问题，例如与其他特性的关系，实现难题。<br>（3）提案包括详细的API描述，使用例子，以及关于相关的语义和算法。</p><h3 id="stage2-draft"><a href="#stage2-draft" class="headerlink" title="stage2 draft"></a>stage2 draft</h3><p>（1）提供一个初始的草案规范，与最终标准中包含的特性不会有太大差别。草案之后，原则上只接受增量修改。<br>（2）开始实验如何实现，实现形式包括polyfill, 实现引擎（提供草案执行本地支持），或者编译转换（例如babel）</p><h3 id="stage3-candidate"><a href="#stage3-candidate" class="headerlink" title="stage3 candidate"></a>stage3 candidate</h3><p>（1）候选阶段，获得具体实现和用户的反馈。此后，只有在实现和使用过程中出现了重大问题才会修改。 （2）规范文档必须是完整的，评审人和ECMAScript的编辑要在规范上签字。<br>（3）至少要在一个浏览器中实现，提供polyfill或者babel插件。</p><h3 id="stage4-finished"><a href="#stage4-finished" class="headerlink" title="stage4 finished"></a>stage4 finished</h3><p>（1）已经准备就绪，该特性会出现在下个版本的ECMAScript规范之中。<br>（2）需要通过有2个独立的实现并通过验收测试，以获取使用过程中的重要实践经验。</p><h2 id="TC39什么鬼？什么成分？主要业务是什么？"><a href="#TC39什么鬼？什么成分？主要业务是什么？" class="headerlink" title="TC39什么鬼？什么成分？主要业务是什么？"></a>TC39什么鬼？什么成分？主要业务是什么？</h2><p>一个推动 JavaScript 发展的委员会，由各个主流浏览器厂商的代表构成。制定ECMAScript标准，标准生成的流程，并实现。</p><h2 id="相关-stage0-4的具体内容查看地址"><a href="#相关-stage0-4的具体内容查看地址" class="headerlink" title="相关 stage0-4的具体内容查看地址"></a>相关 stage0-4的具体内容查看地址</h2><p>stage0 的提案 <a href="https://github.com/tc39/proposals/blob/master/stage-0-proposals.md" target="_blank" rel="noopener">https://github.com/tc39/proposals/blob/master/stage-0-proposals.md</a><br>stage1 - 4 的提案 <a href="https://github.com/tc39/proposa" target="_blank" rel="noopener">https://github.com/tc39/proposa</a></p><p>推荐阅读：<br><a href="https://zhuanlan.zhihu.com/p/27762556" target="_blank" rel="noopener">精读 TC39 与 ECMAScript 提案</a></p>]]></content>
      
      
      <categories>
          
          <category> ECMAScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> ECMAScript提案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>babel6</title>
      <link href="/2019/07/13/packaging/webpack/babel6/"/>
      <url>/2019/07/13/packaging/webpack/babel6/</url>
      
        <content type="html"><![CDATA[<h2 id="babel-分离为多个包"><a href="#babel-分离为多个包" class="headerlink" title="babel 分离为多个包"></a>babel 分离为多个包</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">babel-cli 命令行</span><br><span class="line">babel-core node api 以及 require hook</span><br><span class="line">babel-polyfill 提供es2015的环境</span><br></pre></td></tr></table></figure><h2 id="preset-机制"><a href="#preset-机制" class="headerlink" title="preset 机制"></a>preset 机制</h2><p>babel6 默认不再默认支持 es2015 以及 react。 需要手动在 .babelrc 中添加presets。<br>所谓的 presets 其实就是一些同类plugin打包的结果，方便进行添加。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [&quot;es2015&quot;, &quot;react&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>stage 不再是配置项，以 presets 的形式添加。</p><p>博客推荐：<br><a href="https://segmentfault.com/a/1190000004301150" target="_blank" rel="noopener">babel6 升级总结</a><br><a href="http://www.ruanyifeng.com/blog/2016/01/babel.html" target="_blank" rel="noopener">软大师 Babel 入门教程</a></p>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> webpack </tag>
            
            <tag> babel </tag>
            
            <tag> packaging </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web优化</title>
      <link href="/2019/07/13/other/optimize/web/"/>
      <url>/2019/07/13/other/optimize/web/</url>
      
        <content type="html"><![CDATA[<h3 id="作者：sunlei"><a href="#作者：sunlei" class="headerlink" title="作者：sunlei"></a>作者：sunlei</h3><p> <strong>script 标签的优化</strong> </p><ul><li>默认情况HTML解析，然后加载JS，此时HTML解析中断，然后执行JS，最后JS执行完成恢复HTML解析。</li><li>defer情况是HTMl和JS 并驾齐驱，等HTML加载完成再执行JS。</li><li>async 情况则HTMl和JS并驾齐驱,JS执行可能在HTML解析完成之前。 </li><li>module情况和defer情况类似，只是在提取过程中多加载了多个JS文件。</li></ul><blockquote><p>怎么区分 有以下几点 </p></blockquote><ol><li>defer翻译过来是延缓的意思，也就是拖拖拉拉了，所以比较懒，也就是说什么都不想做，也就是哪怕你把饭端在我面前，我也懒得动嘴的那种，这么一想，我们不就记住了，哪怕你客户端把JS文件下载好了，我也懒得执行，最后实在是大家都干完事了，我才不情愿的去执行JS文件。</li></ol><hr><ol start="2"><li>async翻译过来就是异步的意思，异步异步，不就是一步一步嘛，什么都想一步到位，也就是说，只要下载完我就立马执行，至于其他的想都不想。</li></ol><hr><ol start="3"><li>module翻译过来就是模块的意思，es6用过的人基本都了解这个关键字，加载也和defer差不多，只不过可以加载多个JS文件而已。</li></ol><p><strong>从上面我们可以看出，如果你的脚本依赖于DOM构建完成是否完成，则可以使用defer；如果无需DOM的构建，那就可以放心的使用async了</strong></p><h2 id="扩展导入"><a href="#扩展导入" class="headerlink" title="扩展导入"></a>扩展导入</h2><p><img src="./image.png" alt="扩展导入"><br><img src="./async.png" alt="图片详解解析步骤"></p>]]></content>
      
      
      <categories>
          
          <category> 优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于数组的使用</title>
      <link href="/2019/07/13/javaScript/array/function/"/>
      <url>/2019/07/13/javaScript/array/function/</url>
      
        <content type="html"><![CDATA[<h1 id="Array-方法"><a href="#Array-方法" class="headerlink" title="Array 方法"></a>Array 方法</h1><h2 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h2><blockquote><p>连接两个或者多个数组并返回新的数组，该方法不会影响原数组。</p></blockquote><h3 id="es6-实现concat"><a href="#es6-实现concat" class="headerlink" title="es6 实现concat"></a>es6 实现concat</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr1 = [2,3];</span><br><span class="line">let arr2 = [4,5];</span><br><span class="line">let arr3 = [...arr1,...arr2]</span><br></pre></td></tr></table></figure><h3 id="实现一个concat"><a href="#实现一个concat" class="headerlink" title="实现一个concat"></a>实现一个concat</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.myConcat = function () &#123;</span><br><span class="line">  let arr = this.slice(0);</span><br><span class="line">  arguments.length &amp;&amp; [].forEach.call(arguments,(value) =&gt; &#123;</span><br><span class="line">    if (Array.isArray(value)) &#123;</span><br><span class="line">     value.forEach(val =&gt; &#123;</span><br><span class="line">       arr.push(val);</span><br><span class="line">     &#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      arr.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  return arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">concat()</td><td style="text-align:center">连接两个或更多的数组，并返回结果。</td></tr><tr><td style="text-align:center">join()</td><td style="text-align:center">把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。</td></tr><tr><td style="text-align:center">pop()</td><td style="text-align:center">删除并返回数组的最后一个元素</td></tr><tr><td style="text-align:center">push()</td><td style="text-align:center">向数组的末尾添加一个或更多元素，并返回新的长度。</td></tr><tr><td style="text-align:center">reverse()</td><td style="text-align:center">颠倒数组中元素的顺序。</td></tr><tr><td style="text-align:center">shift()</td><td style="text-align:center">删除并返回数组的第一个元素</td></tr><tr><td style="text-align:center">slice()</td><td style="text-align:center">从某个已有的数组返回选定的元素</td></tr><tr><td style="text-align:center">sort()</td><td style="text-align:center">对数组的元素进行排序</td></tr><tr><td style="text-align:center">splice()</td><td style="text-align:center">删除元素，并向数组添加新元素。</td></tr><tr><td style="text-align:center">toSource()</td><td style="text-align:center">返回该对象的源代码。</td></tr><tr><td style="text-align:center">toString()</td><td style="text-align:center">把数组转换为字符串，并返回结果。</td></tr><tr><td style="text-align:center">toLocaleString()</td><td style="text-align:center">把数组转换为本地数组，并返回结果。</td></tr><tr><td style="text-align:center">unshift()</td><td style="text-align:center">向数组的开头添加一个或更多元素，并返回新的长度。</td></tr><tr><td style="text-align:center">valueOf()</td><td style="text-align:center">返回数组对象的原始值</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>packagejson文件详解</title>
      <link href="/2019/07/13/node/packagejson/"/>
      <url>/2019/07/13/node/packagejson/</url>
      
        <content type="html"><![CDATA[<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. 概述</span><br><span class="line">2. scripts字段</span><br><span class="line">3. dependencies字段，devDependencies字段</span><br><span class="line">4. peerDependencies</span><br><span class="line">5. bin字段</span><br><span class="line">6. main字段</span><br><span class="line">7. config 字段</span><br><span class="line">8. 其他</span><br><span class="line">9. browser字段</span><br><span class="line">10. engines 字段</span><br><span class="line">11. man字段</span><br><span class="line">12. preferGlobal字段</span><br><span class="line">13. style字段</span><br></pre></td></tr></table></figure><hr><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>每个项目的根目录下面，一般都有一个package.json文件，定义了这个项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等元数据）。npm install命令根据这个配置文件，自动下载所需的模块，也就是配置项目所需的运行和开发环境。</p><p>下面是一个最简单的package.json文件，只定义两项元数据：项目名称和项目版本。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot; : &quot;xxx&quot;,</span><br><span class="line">  &quot;version&quot; : &quot;0.0.0&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>package.json文件就是一个JSON对象，该对象的每一个成员就是当前项目的一项设置。比如name就是项目名称，version是版本（遵守“大版本.次要版本.小版本”的格式）。</p><p>下面是一个更完整的package.json文件。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;name&quot;: &quot;Hello World&quot;,</span><br><span class="line">&quot;version&quot;: &quot;0.0.1&quot;,</span><br><span class="line">&quot;author&quot;: &quot;张三&quot;,</span><br><span class="line">&quot;description&quot;: &quot;第一个node.js程序&quot;,</span><br><span class="line">&quot;keywords&quot;:[&quot;node.js&quot;,&quot;javascript&quot;],</span><br><span class="line">&quot;repository&quot;: &#123;</span><br><span class="line">&quot;type&quot;: &quot;git&quot;,</span><br><span class="line">&quot;url&quot;: &quot;https://path/to/url&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;license&quot;:&quot;MIT&quot;,</span><br><span class="line">&quot;engines&quot;: &#123;&quot;node&quot;: &quot;0.10.x&quot;&#125;,</span><br><span class="line">&quot;bugs&quot;:&#123;&quot;url&quot;:&quot;http://path/to/bug&quot;,&quot;email&quot;:&quot;bug@example.com&quot;&#125;,</span><br><span class="line">&quot;contributors&quot;:[&#123;&quot;name&quot;:&quot;李四&quot;,&quot;email&quot;:&quot;lisi@example.com&quot;&#125;],</span><br><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">&quot;start&quot;: &quot;node index.js&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;dependencies&quot;: &#123;</span><br><span class="line">&quot;express&quot;: &quot;latest&quot;,</span><br><span class="line">&quot;mongoose&quot;: &quot;~3.8.3&quot;,</span><br><span class="line">&quot;handlebars-runtime&quot;: &quot;~1.0.12&quot;,</span><br><span class="line">&quot;express3-handlebars&quot;: &quot;~0.5.0&quot;,</span><br><span class="line">&quot;MD5&quot;: &quot;~1.2.0&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;devDependencies&quot;: &#123;</span><br><span class="line">&quot;bower&quot;: &quot;~1.2.8&quot;,</span><br><span class="line">&quot;grunt&quot;: &quot;~0.4.1&quot;,</span><br><span class="line">&quot;grunt-contrib-concat&quot;: &quot;~0.3.0&quot;,</span><br><span class="line">&quot;grunt-contrib-jshint&quot;: &quot;~0.7.2&quot;,</span><br><span class="line">&quot;grunt-contrib-uglify&quot;: &quot;~0.2.7&quot;,</span><br><span class="line">&quot;grunt-contrib-clean&quot;: &quot;~0.5.0&quot;,</span><br><span class="line">&quot;browserify&quot;: &quot;2.36.1&quot;,</span><br><span class="line">&quot;grunt-browserify&quot;: &quot;~1.3.0&quot;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面详细解释package.json文件的各个字段。</p><h3 id="2-scripts字段"><a href="#2-scripts字段" class="headerlink" title="2. scripts字段"></a>2. scripts字段</h3><p>scripts指定了运行脚本命令的npm命令行缩写，比如start指定了运行npm run start时，所要执行的命令。</p><p>下面的设置指定了npm run preinstall、npm run postinstall、npm run start、npm run test时，所要执行的命令。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;preinstall&quot;: &quot;echo here it comes!&quot;,</span><br><span class="line">    &quot;postinstall&quot;: &quot;echo there it goes!&quot;,</span><br><span class="line">    &quot;start&quot;: &quot;node index.js&quot;,</span><br><span class="line">    &quot;test&quot;: &quot;tap test/*.js&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-dependencies字段，devDependencies字段"><a href="#3-dependencies字段，devDependencies字段" class="headerlink" title="3. dependencies字段，devDependencies字段"></a>3. dependencies字段，devDependencies字段</h3><p>dependencies字段指定了项目运行所依赖的模块，devDependencies指定项目开发所需要的模块。</p><p>它们都指向一个对象。该对象的各个成员，分别由模块名和对应的版本要求组成，表示依赖的模块及其版本范围。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;browserify&quot;: &quot;~13.0.0&quot;,</span><br><span class="line">    &quot;karma-browserify&quot;: &quot;~5.0.1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的版本可以加上各种限定，主要有以下几种</p><blockquote><p>指定版本：比如1.2.2，遵循“大版本.次要版本.小版本”的格式规定，安装时只安装指定版本。<br>波浪号（tilde）+指定版本：比如~1.2.2，表示安装1.2.x的最新版本（不低于1.2.2），但是不安装1.3.x，也就是说安装时不改变大版本号和次要版本号。<br>插入号（caret）+指定版本：比如ˆ1.2.2，表示安装1.x.x的最新版本（不低于1.2.2），但是不安装2.x.x，也就是说安装时不改变大版本号。需要注意的是，如果大版本号为0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。<br>latest：安装最新版本。</p></blockquote><p>package.json文件可以手工编写，也可以使用npm init命令自动生成。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm init</span><br></pre></td></tr></table></figure><p>这个命令采用互动方式，要求用户回答一些问题，然后在当前目录生成一个基本的package.json文件。所有问题之中，只有项目名称（name）和项目版本（version）是必填的，其他都是选填的。</p><p>有了package.json文件，直接使用npm install命令，就会在当前目录中安装所需要的模块。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>如果一个模块不在package.json文件之中，可以单独安装这个模块，并使用相应的参数，将其写入package.json文件之中。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install express --save</span><br><span class="line">$ npm install express --save-dev</span><br></pre></td></tr></table></figure><p>上面代码表示单独安装express模块，–save参数表示将该模块写入dependencies属性，–save-dev表示将该模块写入devDependencies属性。</p><h3 id="4-peerDependencies"><a href="#4-peerDependencies" class="headerlink" title="4. peerDependencies"></a>4. peerDependencies</h3><p>有时，你的项目和所依赖的模块，都会同时依赖另一个模块，但是所依赖的版本不一样。比如，你的项目依赖A模块和B模块的1.0版，而A模块本身又依赖B模块的2.0版。</p><p>大多数情况下，这不构成问题，B模块的两个版本可以并存，同时运行。但是，有一种情况，会出现问题，就是这种依赖关系将暴露给用户。</p><p>最典型的场景就是插件，比如A模块是B模块的插件。用户安装的B模块是1.0版本，但是A插件只能和2.0版本的B模块一起使用。这时，用户要是将1.0版本的B的实例传给A，就会出现问题。因此，需要一种机制，在模板安装的时候提醒用户，如果A和B一起安装，那么B必须是2.0模块。</p><p>peerDependencies字段，就是用来供插件指定其所需要的主工具的版本。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;chai-as-promised&quot;,</span><br><span class="line">  &quot;peerDependencies&quot;: &#123;</span><br><span class="line">    &quot;chai&quot;: &quot;1.x&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码指定，安装chai-as-promised模块时，主程序chai必须一起安装，而且chai的版本必须是1.x。如果你的项目指定的依赖是chai的2.0版本，就会报错。</p><p>注意，从npm 3.0版开始，peerDependencies不再会默认安装了。</p><h3 id="5-bin字段"><a href="#5-bin字段" class="headerlink" title="5. bin字段"></a>5. bin字段</h3><p>bin项用来指定各个内部命令对应的可执行文件的位置。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;bin&quot;: &#123;</span><br><span class="line">  &quot;someTool&quot;: &quot;./bin/someTool.js&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码指定，someTool 命令对应的可执行文件为 bin 子目录下的 someTool.js。Npm会寻找这个文件，在node_modules/.bin/目录下建立符号链接。在上面的例子中，someTool.js会建立符号链接npm_modules/.bin/someTool。由于node_modules/.bin/目录会在运行时加入系统的PATH变量，因此在运行npm时，就可以不带路径，直接通过命令来调用这些脚本。</p><p>因此，像下面这样的写法可以采用简写。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scripts: &#123;  </span><br><span class="line">  start: &apos;./node_modules/someTool/someTool.js build&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 简写为</span><br><span class="line"></span><br><span class="line">scripts: &#123;  </span><br><span class="line">  start: &apos;someTool build&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有node_modules/.bin/目录下的命令，都可以用npm run [命令]的格式运行。在命令行下，键入npm run，然后按tab键，就会显示所有可以使用的命令。</p><h3 id="6-main字段"><a href="#6-main字段" class="headerlink" title="6. main字段"></a>6. main字段</h3><p>main字段指定了加载的入口文件，require(‘moduleName’)就会加载这个文件。这个字段的默认值是模块根目录下面的index.js。</p><h3 id="7-config-字段"><a href="#7-config-字段" class="headerlink" title="7. config 字段"></a>7. config 字段</h3><p>config字段用于添加命令行的环境变量。</p><p>下面是一个package.json文件。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot; : &quot;foo&quot;,</span><br><span class="line">  &quot;config&quot; : &#123; &quot;port&quot; : &quot;8080&quot; &#125;,</span><br><span class="line">  &quot;scripts&quot; : &#123; &quot;start&quot; : &quot;node server.js&quot; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在server.js脚本就可以引用config字段的值。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http</span><br><span class="line">  .createServer(...)</span><br><span class="line">  .listen(process.env.npm_package_config_port)</span><br></pre></td></tr></table></figure><p>用户执行npm run start命令时，这个脚本就可以得到值。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run start</span><br></pre></td></tr></table></figure><p>用户可以改变这个值。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm config set foo:port 80</span><br></pre></td></tr></table></figure><h3 id="8-其他"><a href="#8-其他" class="headerlink" title="8. 其他"></a>8. 其他</h3><h4 id="8-1-browser字段"><a href="#8-1-browser字段" class="headerlink" title="8.1 browser字段"></a>8.1 browser字段</h4><p>browser指定该模板供浏览器使用的版本。Browserify这样的浏览器打包工具，通过它就知道该打包那个文件。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;browser&quot;: &#123;</span><br><span class="line">  &quot;tipso&quot;: &quot;./node_modules/tipso/src/tipso.js&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><h4 id="8-1-engines-字段"><a href="#8-1-engines-字段" class="headerlink" title="8.1 engines 字段"></a>8.1 engines 字段</h4><p>engines字段指明了该模块运行的平台，比如 Node 的某个版本或者浏览器。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;engines&quot; : &#123; &quot;node&quot; : &quot;&gt;=0.10.3 &lt;0.12&quot; &#125; &#125;</span><br></pre></td></tr></table></figure><p>该字段也可以指定适用的npm版本。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;engines&quot; : &#123; &quot;npm&quot; : &quot;~1.0.20&quot; &#125; &#125;</span><br></pre></td></tr></table></figure><h4 id="8-3-man字段"><a href="#8-3-man字段" class="headerlink" title="8.3 man字段"></a>8.3 man字段</h4><p>man用来指定当前模块的man文档的位置。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;man&quot; :[ &quot;./doc/calc.1&quot; ]</span><br></pre></td></tr></table></figure><h4 id="8-4-preferGlobal字段"><a href="#8-4-preferGlobal字段" class="headerlink" title="8.4 preferGlobal字段"></a>8.4 preferGlobal字段</h4><p>preferGlobal的值是布尔值，表示当用户不将该模块安装为全局模块时（即不用–global参数），要不要显示警告，表示该模块的本意就是安装为全局模块。</p><h4 id="8-5-style字段"><a href="#8-5-style字段" class="headerlink" title="8.5 style字段"></a>8.5 style字段</h4><p>style指定供浏览器使用时，样式文件所在的位置。样式文件打包工具parcelify，通过它知道样式文件的打包位置。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;style&quot;: [</span><br><span class="line">  &quot;./node_modules/tipso/src/tipso.css&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置 </tag>
            
            <tag> node </tag>
            
            <tag> webpack </tag>
            
            <tag> package.json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack1  到 webpack2的变化</title>
      <link href="/2019/07/13/packaging/webpack/webpack2/"/>
      <url>/2019/07/13/packaging/webpack/webpack2/</url>
      
        <content type="html"><![CDATA[<h1 id="webpack1-到-webpack2的变化"><a href="#webpack1-到-webpack2的变化" class="headerlink" title="webpack1  到 webpack2的变化"></a>webpack1  到 webpack2的变化</h1><h2 id="resolve-root-resolve-fallback-resolve-modulesDirectories"><a href="#resolve-root-resolve-fallback-resolve-modulesDirectories" class="headerlink" title="resolve.root, resolve.fallback, resolve.modulesDirectories"></a>resolve.root, resolve.fallback, resolve.modulesDirectories</h2><p>上述配置项被一个单独的配置项 resolve.modules 取代。详见 resolving。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  resolve: &#123;</span><br><span class="line">-   root: path.join(__dirname, &quot;src&quot;)</span><br><span class="line">+   modules: [</span><br><span class="line">+     path.join(__dirname, &quot;src&quot;),</span><br><span class="line">+     &quot;node_modules&quot;</span><br><span class="line">+   ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="resolve-extensions"><a href="#resolve-extensions" class="headerlink" title="resolve.extensions"></a>resolve.extensions</h2><p>此配置项不再需要传一个空字符串。此行为被迁移到 resolve.enforceExtension。详见 resolving。</p><h2 id="resolve"><a href="#resolve" class="headerlink" title="resolve.*"></a>resolve.*</h2><p>变化较大在我的webpack中resolve模块节查看</p><h2 id="module-loaders-改成了-module-rules"><a href="#module-loaders-改成了-module-rules" class="headerlink" title="module.loaders 改成了 module.rules"></a>module.loaders 改成了 module.rules</h2><p>旧的 loader 配置被更强大的 rules 系统取代，后者允许配置 loader 以及其他更多项。为了兼容旧版，module.loaders 语法被保留，旧的属性名依然可以被解析。新的命名约定更易于理解并且是升级配置使用 module.rules 的好理由。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> module: &#123;</span><br><span class="line">-   loaders: [</span><br><span class="line">+   rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.css$/,</span><br><span class="line">-       loaders: [</span><br><span class="line">+       use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &quot;style-loader&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &quot;css-loader&quot;,</span><br><span class="line">-           query: &#123;</span><br><span class="line">+           options: &#123;</span><br><span class="line">              modules: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.jsx$/,</span><br><span class="line">        loader: &quot;babel-loader&quot;, // Do not use &quot;use&quot; here</span><br><span class="line">        options: &#123;</span><br><span class="line">          // ...</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="链式-loaders"><a href="#链式-loaders" class="headerlink" title="链式 loaders"></a>链式 loaders</h2><p>与 v1 版本相同，loaders 可以链式调用，上一个 loader 的输出被作为输入传给下一个 loader。使用 rule.use 配置项，use 可以设置为一个 loaders 的列表。在 v1 版本中，loaders 通常被用 ! 连写。这一写法在新版中只在使用旧的 module.loaders 时有效。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  module: &#123;</span><br><span class="line">-   loaders: &#123;</span><br><span class="line">+   rules: [&#123;</span><br><span class="line">      test: /\.less$/,</span><br><span class="line">-     loader: &quot;style-loader!css-loader!less-loader&quot;</span><br><span class="line">+     use: [</span><br><span class="line">+       &quot;style-loader&quot;,</span><br><span class="line">+       &quot;css-loader&quot;,</span><br><span class="line">+       &quot;less-loader&quot;</span><br><span class="line">+     ]</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h2 id="取消了在模块名中自动添加-loader-后缀"><a href="#取消了在模块名中自动添加-loader-后缀" class="headerlink" title="取消了在模块名中自动添加 -loader 后缀"></a>取消了在模块名中自动添加 -loader 后缀</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        use: [</span><br><span class="line">-         &quot;style&quot;,</span><br><span class="line">+         &quot;style-loader&quot;,</span><br><span class="line">-         &quot;css&quot;,</span><br><span class="line">+         &quot;css-loader&quot;,</span><br><span class="line">-         &quot;less&quot;,</span><br><span class="line">+         &quot;less-loader&quot;,</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="json-loader-不再需要手动添加"><a href="#json-loader-不再需要手动添加" class="headerlink" title="json-loader 不再需要手动添加"></a>json-loader 不再需要手动添加</h2><p>如果没有为 JSON 文件配置 loader，webpack 将自动尝试通过 加载 json-loader JSON 文件。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">-     &#123;</span><br><span class="line">-       test: /\.json/,</span><br><span class="line">-       loader: &quot;json-loader&quot;</span><br><span class="line">-     &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h2 id="loader-默认的-resolve-配置是相对于-context-的"><a href="#loader-默认的-resolve-配置是相对于-context-的" class="headerlink" title="loader 默认的 resolve 配置是相对于 context 的"></a>loader 默认的 resolve 配置是相对于 context 的</h2><p>在 webpack 1 中，loader 默认配置下 resolve 相对于被匹配的文件。而在 webpack 2 中默认配置的 resolve 相对于 context 配置项。</p><p>这解决了一些问题，比如使用 npm link 或引用 context 之外的模块时导致重复载入。</p><p>你可以不再需要使用一些变通方案了：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        // ...</span><br><span class="line">-       loader: require.resolve(&quot;my-loader&quot;)</span><br><span class="line">+       loader: &quot;my-loader&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  resolveLoader: &#123;</span><br><span class="line">-   root: path.resolve(__dirname, &quot;node_modules&quot;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h2 id="取消了-module-preLoaders-以及-module-postLoaders"><a href="#取消了-module-preLoaders-以及-module-postLoaders" class="headerlink" title="取消了 module.preLoaders 以及 module.postLoaders"></a>取消了 module.preLoaders 以及 module.postLoaders</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> module: &#123;</span><br><span class="line">-   preLoaders: [</span><br><span class="line">+   rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.js$/,</span><br><span class="line">+       enforce: &quot;pre&quot;,</span><br><span class="line">        loader: &quot;eslint-loader&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="UglifyJsPlugin-sourceMap"><a href="#UglifyJsPlugin-sourceMap" class="headerlink" title="UglifyJsPlugin sourceMap"></a>UglifyJsPlugin sourceMap</h2><p>UglifyJsPlugin 的 sourceMap 配置项现在默认为 false 而不是 true。 这意味着如果你在压缩代码时启用了 source map，或者想要让 uglifyjs 的警告能够对应到正确的代码行，你需要将 UglifyJsPlugin 的 sourceMap 设为 true。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">devtool: &quot;source-map&quot;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new UglifyJsPlugin(&#123;</span><br><span class="line">+     sourceMap: true</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></p><h2 id="UglifyJsPlugin-warnings"><a href="#UglifyJsPlugin-warnings" class="headerlink" title="UglifyJsPlugin warnings"></a>UglifyJsPlugin warnings</h2><p>UglifyJsPlugin 的 compress.warnings 配置项现在默认为 false 而不是 true。 这意味着如果你想要看到 uglifyjs 的警告信息，你需要将 compress.warnings 设为 true。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  devtool: &quot;source-map&quot;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new UglifyJsPlugin(&#123;</span><br><span class="line">+     compress: &#123;</span><br><span class="line">+       warnings: true</span><br><span class="line">+     &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></p><h2 id="UglifyJsPlugin-压缩-loaders"><a href="#UglifyJsPlugin-压缩-loaders" class="headerlink" title="UglifyJsPlugin 压缩 loaders"></a>UglifyJsPlugin 压缩 loaders</h2><p>UglifyJsPlugin 不再压缩 loaders。在未来很长一段时间里，需要通过设置 minimize:true 来压缩 loaders。参考 loader 文档里的相关配置项。</p><p>loaders 的压缩模式将在 webpack 3 或更高的版本中被取消。</p><p>为了兼容旧的 loaders，loaders 可以通过插件来切换到压缩模式<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  plugins: [</span><br><span class="line">+   new webpack.LoaderOptionsPlugin(&#123;</span><br><span class="line">+     minimize: true</span><br><span class="line">+   &#125;)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></p><h2 id="DedupePlugin-被移除"><a href="#DedupePlugin-被移除" class="headerlink" title="DedupePlugin 被移除"></a>DedupePlugin 被移除</h2><p>不再需要 webpack.optimize.DedupePlugin。请从配置中移除。</p><h2 id="BannerPlugin-破坏性改动"><a href="#BannerPlugin-破坏性改动" class="headerlink" title="BannerPlugin - 破坏性改动"></a>BannerPlugin - 破坏性改动</h2><p>BannerPlugin 不在接受两个参数而是只接受单独的 options 对象。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> plugins: [</span><br><span class="line">-    new webpack.BannerPlugin(&apos;Banner&apos;, &#123;raw: true, entryOnly: true&#125;);</span><br><span class="line">+    new webpack.BannerPlugin(&#123;banner: &apos;Banner&apos;, raw: true, entryOnly: true&#125;);</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></p><h2 id="OccurrenceOrderPlugin-被默认加载"><a href="#OccurrenceOrderPlugin-被默认加载" class="headerlink" title="OccurrenceOrderPlugin 被默认加载"></a>OccurrenceOrderPlugin 被默认加载</h2><p>我们不再需要在配置里指定它：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> plugins: [</span><br><span class="line">-   new webpack.optimize.OccurrenceOrderPlugin()</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></p><h2 id="ExtractTextWebpackPlugin-大改变"><a href="#ExtractTextWebpackPlugin-大改变" class="headerlink" title="ExtractTextWebpackPlugin - 大改变"></a>ExtractTextWebpackPlugin - 大改变</h2><p>ExtractTextPlugin 1.0.0 不能在 webpack v2 下工作。 你需要明确地安装 ExtractTextPlugin v2。</p><p>npm install –save-dev extract-text-webpack-plugin@beta</p><p>这一插件的配置变化主要体现在语法上。<br>ExtractTextPlugin.extract<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: /.css$/,</span><br><span class="line">-      loader: ExtractTextPlugin.extract(&quot;style-loader&quot;, &quot;css-loader&quot;, &#123; publicPath: &quot;/dist&quot; &#125;)</span><br><span class="line">+      use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">+        fallback: &quot;style-loader&quot;,</span><br><span class="line">+        use: &quot;css-loader&quot;,</span><br><span class="line">+        publicPath: &quot;/dist&quot;</span><br><span class="line">+      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>new ExtractTextPlugin({options})<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">-  new ExtractTextPlugin(&quot;bundle.css&quot;, &#123; allChunks: true, disable: false &#125;)</span><br><span class="line">+  new ExtractTextPlugin(&#123;</span><br><span class="line">+    filename: &quot;bundle.css&quot;,</span><br><span class="line">+    disable: false,</span><br><span class="line">+    allChunks: true</span><br><span class="line">+  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h2 id="全动态-requires-现在默认会失败"><a href="#全动态-requires-现在默认会失败" class="headerlink" title="全动态 requires 现在默认会失败"></a>全动态 requires 现在默认会失败</h2><p>只有一个表达式的依赖（例如 require(expr)）将创建一个空的 context 而不是一个完整目录的 context。</p><p>如果有上面那样的代码，最好把它重构了，因为在 ES2015 模块下它不可以用。如果你确定不会有 ES2015 模块，你可以使用 ContextReplacementPlugin 来提示编译器进行正确的处理。</p><h2 id="在-CLI-和配置中使用自定义参数"><a href="#在-CLI-和配置中使用自定义参数" class="headerlink" title="在 CLI 和配置中使用自定义参数"></a>在 CLI 和配置中使用自定义参数</h2><p>如果你之前滥用 CLI 来传自定义参数到配置中，比如：</p><p>webpack –custom-stuff</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// webpack.config.js</span><br><span class="line">var customStuff = process.argv.indexOf(&quot;--custom-stuff&quot;) &gt;= 0;</span><br><span class="line">/* ... */</span><br><span class="line">module.exports = config;</span><br></pre></td></tr></table></figure><p>你将会发现新版中不再允许这么做。CLI 现在更加严格了。</p><p>替代地，现在提供了一个接口来传递参数给配置。我们应该采用这种新方式，在未来许多工具将可能依赖它。</p><p>webpack –env.customStuff<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function(env) &#123;</span><br><span class="line">  var customStuff = env.customStuff;</span><br><span class="line">  /* ... */</span><br><span class="line">  return config;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="require-ensure-以及-AMD-require-的异步"><a href="#require-ensure-以及-AMD-require-的异步" class="headerlink" title="require.ensure 以及 AMD require 的异步"></a>require.ensure 以及 AMD require 的异步</h2><p>现在这些函数总是异步的，而不是当 chunk 已经加载过的时候同步调用它们的 callback。</p><p>注意 require.ensure 现在依赖于原生的 Promise。如果在不支持 Promise 的环境里使用 require.ensure，你需要添加 polyfill。</p><h2 id="通过-options-配置-loader"><a href="#通过-options-配置-loader" class="headerlink" title="通过 options 配置 loader"></a>通过 options 配置 loader</h2><p>你不能再通过 webpack.config.js 的自定义属性来配置 loader。只能通过 options 来配置。下面配置的 ts 属性在 webpack 2 下不再有效：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: /\.tsx?$/,</span><br><span class="line">      loader: &apos;ts-loader&apos;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  // does not work with webpack 2</span><br><span class="line">  ts: &#123; transpileOnly: false &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>什么是 options?</p><p>好问题。严格来说，有两种办法，都可以用来配置 webpack 的 loader。典型的 options 被称为 query，是一个可以被添加到 loader 名之后的字符串。它比较像一个 query string，但是实际上有更强大的能力：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: /\.tsx?$/,</span><br><span class="line">      loader: &apos;ts-loader?&apos; + JSON.stringify(&#123; transpileOnly: false &#125;)</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不过它也可以分开来，写成一个单独的对象，紧跟在 loader 属性后面：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: /\.tsx?$/,</span><br><span class="line">      loader: &apos;ts-loader&apos;,</span><br><span class="line">      options:  &#123; transpileOnly: false &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="LoaderOptionsPlugin-context"><a href="#LoaderOptionsPlugin-context" class="headerlink" title="LoaderOptionsPlugin context"></a>LoaderOptionsPlugin context</h2><p>有的 loader 需要从配置中读取一些 context 信息。在未来很长一段时间里，这将需要通过 loader options 传入。详见 loader 文档的相关选项。</p><p>为了保持对旧 loaders 的兼容，这些信息可以通过插件传进来：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  plugins: [</span><br><span class="line">+   new webpack.LoaderOptionsPlugin(&#123;</span><br><span class="line">+     options: &#123;</span><br><span class="line">+       context: __dirname</span><br><span class="line">+     &#125;</span><br><span class="line">+   &#125;)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></p><h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h2><p>在 webpack 1 中 debug 配置项切换 loaders 到 debug 模式。在未来很长一段时间里，这将需要通过 loader 配置项传递。详见 loader 文档的相关选项。</p><p>loaders 的 debug 模式将在 webpack 3 或后续版本中取消。</p><p>为了保持对旧 loaders 的兼容，loader 可以通过插件来切换到 debug 模式：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- debug: true,</span><br><span class="line">  plugins: [</span><br><span class="line">+   new webpack.LoaderOptionsPlugin(&#123;</span><br><span class="line">+     debug: true</span><br><span class="line">+   &#125;)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></p><h2 id="ES2015-的代码分割"><a href="#ES2015-的代码分割" class="headerlink" title="ES2015 的代码分割"></a>ES2015 的代码分割</h2><p>在 webpack v1 中，你能使用 require.ensure 作为方法来懒加载 chunks 到你的应用中：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require.ensure([], function(require) &#123;</span><br><span class="line">  var foo = require(&quot;./module&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>ES2015 模块加载规范定义了 import() 方法来运行时动态地加载 ES2015 模块。</p><p>webpack 将 import() 作为分割点并将被请求的模块放到一个单独的 chunk 中。</p><p>import() 接收模块名作为参数，并返回一个 Promise。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function onClick() &#123;</span><br><span class="line">  import(&quot;./module&quot;).then(module =&gt; &#123;</span><br><span class="line">    return module.default;</span><br><span class="line">  &#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(&quot;Chunk loading failed&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好消息是：如果加载 chunk 失败，我们可以进行处理，因为现在它基于 Promise。</p><p>警告：require.ensure 允许用可选的第三个参数为 chunk 简单命名，但是 import API 还未提供这个能力。如果你想要保留这个功能，你可以继续使用 require.ensure。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require.ensure([], function(require) &#123;</span><br><span class="line">  var foo = require(&quot;./module&quot;);</span><br><span class="line">&#125;, &quot;custom-chunk-name&quot;);</span><br></pre></td></tr></table></figure></p><p>（注意废弃的 System.import：webpack 对 System.import 的使用不符合新提出的标准，所以它在 v2.1.0-beta.28 版本中被废弃，转向支持 import()）</p><p>由于这个建议还在 Stage 3，如果你想要同时使用 import 和 Babel，你需要安装/添加 dynamic-import 语法插件来绕过解析错误。当建议被添加到规范之后，就不再需要这个语法插件了。</p><h2 id="动态表达式"><a href="#动态表达式" class="headerlink" title="动态表达式"></a>动态表达式</h2><p>可以传递部分表达式给 import()。这与 CommonJS 对表达式的处理方式一致（webpack 为所有可能匹配的文件创建 context）。</p><p>import() 为每一个可能的模块创建独立的 chunk。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function route(path, query) &#123;</span><br><span class="line">  return import(`./routes/$&#123;path&#125;/route`)</span><br><span class="line">    .then(route =&gt; new route.Route(query));</span><br><span class="line">&#125;</span><br><span class="line">// 上面代码为每个可能的路由创建独立的 chunk</span><br></pre></td></tr></table></figure></p><h2 id="混合使用-ES2015、AMD-和-CommonJS"><a href="#混合使用-ES2015、AMD-和-CommonJS" class="headerlink" title="混合使用 ES2015、AMD 和 CommonJS"></a>混合使用 ES2015、AMD 和 CommonJS</h2><p>你可以自由混合使用三种模块类型（甚至在同一个文件中）。在这个情况中 webpack 的行为和 babel 以及 node-eps 一致：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// CommonJS consuming ES2015 Module</span><br><span class="line">var book = require(&quot;./book&quot;);</span><br><span class="line"></span><br><span class="line">book.currentPage;</span><br><span class="line">book.readPage();</span><br><span class="line">book.default === &quot;This is a book&quot;;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// ES2015 Module consuming CommonJS</span><br><span class="line">import fs from &quot;fs&quot;; // module.exports map to default</span><br><span class="line">import &#123; readFileSync &#125; from &quot;fs&quot;; // named exports are read from returned object+</span><br><span class="line"></span><br><span class="line">typeof fs.readFileSync === &quot;function&quot;;</span><br><span class="line">typeof readFileSync === &quot;function&quot;;</span><br></pre></td></tr></table></figure><p>需要注意的是，您需要告诉Babel不要解析这些模块符号，这样webpack就可以使用它们。您可以通过在您的程序中设置以下内容来实现这一点。babelrc或babel-loader选项。</p><h3 id="babelrc"><a href="#babelrc" class="headerlink" title=".babelrc"></a>.babelrc</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    [&quot;es2015&quot;, &#123; &quot;modules&quot;: false &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>webpack 现在支持表达式中的模板字符串了。这意味着你可以在 webpack 构建中使用它们：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- require(&quot;./templates/&quot; + name);</span><br><span class="line">+ require(`./templates/$&#123;name&#125;`);</span><br></pre></td></tr></table></figure></p><h2 id="配置中使用-Promise"><a href="#配置中使用-Promise" class="headerlink" title="配置中使用 Promise"></a>配置中使用 Promise</h2><p>webpack 现在支持在配置文件中返回 Promise 了。这让你能在配置文件中做异步处理。</p><p>webpack.config.js<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function() &#123;</span><br><span class="line">  return fetchLangs().then(lang =&gt; (&#123;</span><br><span class="line">    entry: &quot;...&quot;,</span><br><span class="line">    // ...</span><br><span class="line">    plugins: [</span><br><span class="line">      new DefinePlugin(&#123; LANGUAGE: lang &#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="高级-loader-匹配"><a href="#高级-loader-匹配" class="headerlink" title="高级 loader 匹配"></a>高级 loader 匹配</h2><p>webpack 现在支持对 loader 进行更多方式的匹配。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      resource: /filename/, // matches &quot;/path/filename.js&quot;</span><br><span class="line">      resourceQuery: /querystring/, // matches &quot;/filename.js?querystring&quot;</span><br><span class="line">      issuer: /filename/, // matches &quot;/path/something.js&quot; if requested from &quot;/path/filename.js&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更多的-CLI-参数项"><a href="#更多的-CLI-参数项" class="headerlink" title="更多的 CLI 参数项"></a>更多的 CLI 参数项</h2><p>你可以使用一些新的 CLI 参数项：</p><p>–define process.env.NODE_ENV=”production” 见 DefinePlugin。</p><p>–display-depth 显示每个模块到入口的距离。</p><p>–display-used-exports 显示一个模块中被使用的 exports 信息。</p><p>–display-max-modules 设置输出时显示的模块数量（默认是 15）。</p><p>-p 能够定义 process.env.NODE_ENV 为 “production”。</p><h2 id="Cacheable"><a href="#Cacheable" class="headerlink" title="Cacheable"></a>Cacheable</h2><p>Loaders 现在默认可被缓存。Loaders 如果不想被缓存，需要选择不被缓存。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> // Cacheable loader</span><br><span class="line">  module.exports = function(source) &#123;</span><br><span class="line">-   this.cacheable();</span><br><span class="line">    return source;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> // Not cacheable loader</span><br><span class="line">  module.exports = function(source) &#123;</span><br><span class="line">+   this.cacheable(false);</span><br><span class="line">    return source;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="复合-options"><a href="#复合-options" class="headerlink" title="复合 options"></a>复合 options</h2><p>webpack 1 只支持能够 JSON.stringify 的对象作为配置项。webpack 2 现在支持任意 JS 对象作为 loader 配置项。</p><p>使用复合 options 只有一个附加条件。你需要在 options 对象上添加一个 ident，让它能够被其他 loader 引用。</p><p>options 对象上有了 ident ，内联的 loader 就可以引用这个 options 对象。下面是个例子：</p><p>require(“some-loader??by-ident!resource”)<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: /.../,</span><br><span class="line">  loader: &quot;...&quot;,</span><br><span class="line">  options: &#123;</span><br><span class="line">    ident: &quot;by-ident&quot;,</span><br><span class="line">    magic: () =&gt; return Math.random()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种内联风格在常规的代码里一般用不着，但是在 loader 生成的代码里比较常见。比如，style-loader 生成一个模块，通过 require 加载其余的请求（它们输出 CSS）。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// style-loader generated code (simplified)</span><br><span class="line">var addStyle = require(&quot;./add-style&quot;);</span><br><span class="line">var css = require(&quot;-!css-loader?&#123;&quot;modules&quot;:true&#125;!postcss-loader??postcss-ident&quot;);</span><br><span class="line"></span><br><span class="line">addStyle(css);</span><br></pre></td></tr></table></figure></p><p>所以如果你使用复合 options，告诉你的用户你使用的 ident。</p>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> webpack </tag>
            
            <tag> packaging </tag>
            
            <tag> webpack2.x的变化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Router使用教程</title>
      <link href="/2019/07/13/React/router/"/>
      <url>/2019/07/13/React/router/</url>
      
        <content type="html"><![CDATA[<h1 id="React-Router使用教程"><a href="#React-Router使用教程" class="headerlink" title="React Router使用教程"></a>React Router使用教程</h1><h2 id="一、基本用法"><a href="#一、基本用法" class="headerlink" title="一、基本用法"></a>一、基本用法</h2><p>React Router 安装命令如下。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -S react-router</span><br></pre></td></tr></table></figure><p>使用时，路由器 Router 就是React的一个组件。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Router &#125; from &apos;react-router&apos;;</span><br><span class="line">render(&lt;Router/&gt;, document.getElementById(&apos;app&apos;));</span><br></pre></td></tr></table></figure><p>Router 组件本身只是一个容器，真正的路由要通过 Route 组件定义。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Router, Route, hashHistory &#125; from &apos;react-router&apos;;</span><br><span class="line"></span><br><span class="line">render((</span><br><span class="line">  &lt;Router history=&#123;hashHistory&#125;&gt;</span><br><span class="line">    &lt;Route path=&quot;/&quot; component=&#123;App&#125;/&gt;</span><br><span class="line">  &lt;/Router&gt;</span><br><span class="line">), document.getElementById(&apos;app&apos;));</span><br></pre></td></tr></table></figure><p>上面代码中，用户访问根路由 / （比如 <a href="http://www.example.com/" target="_blank" rel="noopener">http://www.example.com/</a> ），组件 APP 就会加载到 document.getElementById(‘app’) 。</p><p>你可能还注意到， Router 组件有一个参数 history ，它的值 hashHistory 表示，路由的切换由URL的hash变化决定，即URL的 # 部分发生变化。举例来说，用户访问 <a href="http://www.example.com/" target="_blank" rel="noopener">http://www.example.com/</a> ，实际会看到的是 <a href="http://www.example.com/#/" target="_blank" rel="noopener">http://www.example.com/#/</a> 。</p><p>Route 组件定义了URL路径与组件的对应关系。你可以同时使用多个 Route 组件。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router history=&#123;hashHistory&#125;&gt;</span><br><span class="line">  &lt;Route path=&quot;/&quot; component=&#123;App&#125;/&gt;</span><br><span class="line">  &lt;Route path=&quot;/repos&quot; component=&#123;Repos&#125;/&gt;</span><br><span class="line">  &lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt;</span><br><span class="line">&lt;/Router&gt;</span><br></pre></td></tr></table></figure><p>上面代码中，用户访问 /repos （比如 <a href="http://localhost:8080/#/repos" target="_blank" rel="noopener">http://localhost:8080/#/repos</a> ）时，加载 Repos 组件；访问 /about （ <a href="http://localhost:8080/#/about" target="_blank" rel="noopener">http://localhost:8080/#/about</a> ）时，加载 About 组件。</p><h2 id="二、嵌套路由"><a href="#二、嵌套路由" class="headerlink" title="二、嵌套路由"></a>二、嵌套路由</h2><p>Route 组件还可以嵌套。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router history=&#123;hashHistory&#125;&gt;</span><br><span class="line">  &lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt;</span><br><span class="line">  &lt;Route path=&quot;/repos&quot; component=&#123;Repos&#125;/&gt;</span><br><span class="line">    &lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt;</span><br><span class="line">  &lt;/Route&gt;</span><br><span class="line">&lt;/Router&gt;</span><br></pre></td></tr></table></figure><p>上面代码中，用户访问 /repos 时，会先加载 App 组件，然后在它的内部再加载 Repos 组件。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;App&gt;</span><br><span class="line">  &lt;Repos/&gt;</span><br><span class="line">&lt;/App&gt;</span><br></pre></td></tr></table></figure><p>App 组件要写成下面的样子。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export default React.createClass(&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &#123;this.props.children&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面代码中， App 组件的 this.props.children 属性就是子组件。</p><p>子路由也可以不写在 Router 组件里面，单独传入 Router 组件的 routes 属性。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let routes = &lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt;</span><br><span class="line">  &lt;Route path=&quot;/repos&quot; component=&#123;Repos&#125;/&gt;</span><br><span class="line">  &lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt;</span><br><span class="line">&lt;/Route&gt;;</span><br><span class="line"></span><br><span class="line">&lt;Router routes=&#123;routes&#125; history=&#123;browserHistory&#125;/&gt;</span><br></pre></td></tr></table></figure><h2 id="三、-path-属性"><a href="#三、-path-属性" class="headerlink" title="三、 path 属性"></a>三、 path 属性</h2><p>Route 组件的 path 属性指定路由的匹配规则。这个属性是可以省略的，这样的话，不管路径是否匹配，总是会加载指定组件。</p><p>请看下面的例子。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&quot;inbox&quot; component=&#123;Inbox&#125;&gt;</span><br><span class="line">   &lt;Route path=&quot;messages/:id&quot; component=&#123;Message&#125; /&gt;</span><br><span class="line">&lt;/Route&gt;</span><br></pre></td></tr></table></figure><p>上面代码中，当用户访问 /inbox/messages/:id 时，会加载下面的组件。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Inbox&gt;</span><br><span class="line">  &lt;Message/&gt;</span><br><span class="line">&lt;/Inbox&gt;</span><br></pre></td></tr></table></figure><p>如果省略外层 Route 的 path 参数，写成下面的样子。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route component=&#123;Inbox&#125;&gt;</span><br><span class="line">  &lt;Route path=&quot;inbox/messages/:id&quot; component=&#123;Message&#125; /&gt;</span><br><span class="line">&lt;/Route&gt;</span><br></pre></td></tr></table></figure><p>现在用户访问 /inbox/messages/:id 时，组件加载还是原来的样子。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Inbox&gt;</span><br><span class="line">  &lt;Message/&gt;</span><br><span class="line">&lt;/Inbox&gt;</span><br></pre></td></tr></table></figure><h2 id="四、通配符"><a href="#四、通配符" class="headerlink" title="四、通配符"></a>四、通配符</h2><p>path 属性可以使用通配符。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&quot;/hello/:name&quot;&gt;</span><br><span class="line">// 匹配 /hello/michael</span><br><span class="line">// 匹配 /hello/ryan</span><br><span class="line"></span><br><span class="line">&lt;Route path=&quot;/hello(/:name)&quot;&gt;</span><br><span class="line">// 匹配 /hello</span><br><span class="line">// 匹配 /hello/michael</span><br><span class="line">// 匹配 /hello/ryan</span><br><span class="line"></span><br><span class="line">&lt;Route path=&quot;/files/*.*&quot;&gt;</span><br><span class="line">// 匹配 /files/hello.jpg</span><br><span class="line">// 匹配 /files/hello.html</span><br><span class="line"></span><br><span class="line">&lt;Route path=&quot;/files/*&quot;&gt;</span><br><span class="line">// 匹配 /files/</span><br><span class="line">// 匹配 /files/a</span><br><span class="line">// 匹配 /files/a/b</span><br><span class="line"></span><br><span class="line">&lt;Route path=&quot;/**/*.jpg&quot;&gt;</span><br><span class="line">// 匹配 /files/hello.jpg</span><br><span class="line">// 匹配 /files/path/to/file.jpg</span><br></pre></td></tr></table></figure><p>通配符的规则如下。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">（1） :paramName</span><br><span class="line"></span><br><span class="line">:paramName 匹配URL的一个部分，直到遇到下一个 / 、 ? 、 # 为止。这个路径参数可以通过 this.props.params.paramName 取出。</span><br><span class="line"></span><br><span class="line">（2） ()</span><br><span class="line"></span><br><span class="line">() 表示URL的这个部分是可选的。</span><br><span class="line"></span><br><span class="line">（3） *</span><br><span class="line"></span><br><span class="line">* 匹配任意字符，直到模式里面的下一个字符为止。匹配方式是非贪婪模式。</span><br><span class="line"></span><br><span class="line">（4） **</span><br><span class="line"></span><br><span class="line">** 匹配任意字符，直到下一个 / 、 ? 、 # 为止。匹配方式是贪婪模式。</span><br></pre></td></tr></table></figure></p><p>path 属性也可以使用相对路径（不以 / 开头），匹配时就会相对于父组件的路径，可以参考上一节的例子。嵌套路由如果想摆脱这个规则，可以使用绝对路由。</p><p>路由匹配规则是从上到下执行，一旦发现匹配，就不再其余的规则了。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&quot;/comments&quot; ... /&gt;</span><br><span class="line">&lt;Route path=&quot;/comments&quot; ... /&gt;</span><br></pre></td></tr></table></figure><p>上面代码中，路径 /comments 同时匹配两个规则，第二个规则不会生效。</p><p>设置路径参数时，需要特别小心这一点。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router&gt;</span><br><span class="line">  &lt;Route path=&quot;/:userName/:id&quot; component=&#123;UserPage&#125;/&gt;</span><br><span class="line">  &lt;Route path=&quot;/about/me&quot; component=&#123;About&#125;/&gt;</span><br><span class="line">&lt;/Router&gt;</span><br></pre></td></tr></table></figure><p>上面代码中，用户访问 /about/me 时，不会触发第二个路由规则，因为它会匹配 /:userName/:id 这个规则。因此，带参数的路径一般要写在路由规则的底部。</p><p>此外，URL的查询字符串 /foo?bar=baz ，可以用 this.props.location.query.bar 获取。</p><h2 id="五、IndexRoute-组件"><a href="#五、IndexRoute-组件" class="headerlink" title="五、IndexRoute 组件"></a>五、IndexRoute 组件</h2><p>下面的例子，你会不会觉得有一点问题？</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router&gt;</span><br><span class="line">  &lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt;</span><br><span class="line">    &lt;Route path=&quot;accounts&quot; component=&#123;Accounts&#125;/&gt;</span><br><span class="line">    &lt;Route path=&quot;statements&quot; component=&#123;Statements&#125;/&gt;</span><br><span class="line">  &lt;/Route&gt;</span><br><span class="line">&lt;/Router&gt;</span><br></pre></td></tr></table></figure><p>上面代码中，访问根路径 / ，不会加载任何子组件。也就是说， App 组件的 this.props.children ，这时是 undefined 。</p><p>因此，通常会采用 {this.props.children || &lt;Home/&gt;} 这样的写法。这时， Home 明明是 Accounts 和 Statements 的同级组件，却没有写在 Route 中。</p><p>IndexRoute 就是解决这个问题，显式指定 Home 是根路由的子组件，即指定默认情况下加载的子组件。你可以把 IndexRoute 想象成某个路径的 index.html 。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router&gt;</span><br><span class="line">  &lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt;</span><br><span class="line">    &lt;IndexRoute component=&#123;Home&#125;/&gt;</span><br><span class="line">    &lt;Route path=&quot;accounts&quot; component=&#123;Accounts&#125;/&gt;</span><br><span class="line">    &lt;Route path=&quot;statements&quot; component=&#123;Statements&#125;/&gt;</span><br><span class="line">  &lt;/Route&gt;</span><br><span class="line">&lt;/Router&gt;</span><br></pre></td></tr></table></figure><p>现在，用户访问 / 的时候，加载的组件结构如下。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;App&gt;</span><br><span class="line">  &lt;Home/&gt;</span><br><span class="line">&lt;/App&gt;</span><br></pre></td></tr></table></figure><p>这种组件结构就很清晰了： App 只包含下级组件的共有元素，本身的展示内容则由 Home 组件定义。这样有利于代码分离，也有利于使用React Router提供的各种API。</p><p>注意， IndexRoute 组件没有路径参数 path 。</p><h2 id="六、Redirect-组件"><a href="#六、Redirect-组件" class="headerlink" title="六、Redirect 组件"></a>六、Redirect 组件</h2><p><redirect> 组件用于路由的跳转，即用户访问一个路由，会自动跳转到另一个路由。</redirect></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&quot;inbox&quot; component=&#123;Inbox&#125;&gt;</span><br><span class="line">   &#123;/* 从 /inbox/messages/:id 跳转到 /messages/:id */&#125;</span><br><span class="line">   &lt;Redirect from=&quot;messages/:id&quot; to=&quot;/messages/:id&quot; /&gt;</span><br><span class="line">&lt;/Route&gt;</span><br></pre></td></tr></table></figure><p>现在访问 /inbox/messages/5 ，会自动跳转到 /messages/5 。</p><h2 id="七、IndexRedirect-组件"><a href="#七、IndexRedirect-组件" class="headerlink" title="七、IndexRedirect 组件"></a>七、IndexRedirect 组件</h2><p>IndexRedirect 组件用于访问根路由的时候，将用户重定向到某个子组件。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt;</span><br><span class="line">  &lt;IndexRedirect to=&quot;/welcome&quot; /&gt;</span><br><span class="line">  &lt;Route path=&quot;welcome&quot; component=&#123;Welcome&#125; /&gt;</span><br><span class="line">  &lt;Route path=&quot;about&quot; component=&#123;About&#125; /&gt;</span><br><span class="line">&lt;/Route&gt;</span><br></pre></td></tr></table></figure><p>上面代码中，用户访问根路径时，将自动重定向到子组件 welcome 。</p><h2 id="八、Link"><a href="#八、Link" class="headerlink" title="八、Link"></a>八、Link</h2><p>Link 组件用于取代 a标签，生成一个链接，允许用户点击后跳转到另一个路由。它基本上就是 a标签的React 版本，可以接收 Router 的状态。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  return &lt;div&gt;</span><br><span class="line">    &lt;ul role=&quot;nav&quot;&gt;</span><br><span class="line">      &lt;li&gt;&lt;Link to=&quot;/about&quot;&gt;About&lt;/Link&gt;&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;&lt;Link to=&quot;/repos&quot;&gt;Repos&lt;/Link&gt;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果希望当前的路由与其他路由有不同样式，这时可以使用 Link 组件的 activeStyle 属性。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=&quot;/about&quot; activeStyle=&#123;&#123;color: &apos;red&apos;&#125;&#125;&gt;About&lt;/Link&gt;</span><br><span class="line">&lt;Link to=&quot;/repos&quot; activeStyle=&#123;&#123;color: &apos;red&apos;&#125;&#125;&gt;Repos&lt;/Link&gt;</span><br></pre></td></tr></table></figure><p>上面代码中，当前页面的链接会红色显示。</p><p>另一种做法是，使用 activeClassName 指定当前路由的 Class 。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=&quot;/about&quot; activeClassName=&quot;active&quot;&gt;About&lt;/Link&gt;</span><br><span class="line">&lt;Link to=&quot;/repos&quot; activeClassName=&quot;active&quot;&gt;Repos&lt;/Link&gt;</span><br></pre></td></tr></table></figure><p>上面代码中，当前页面的链接的 class 会包含 active 。</p><p>在 Router 组件之外，导航到路由页面，可以使用浏览器的History API，像下面这样写。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; browserHistory &#125; from &apos;react-router&apos;;</span><br><span class="line">browserHistory.push(&apos;/some/path&apos;);</span><br></pre></td></tr></table></figure><h2 id="九、IndexLink"><a href="#九、IndexLink" class="headerlink" title="九、IndexLink"></a>九、IndexLink</h2><p>如果链接到根路由 / ，不要使用 Link 组件，而要使用 IndexLink 组件。</p><p>这是因为对于根路由来说， activeStyle 和 activeClassName 会失效，或者说总是生效，因为 / 会匹配任何子路由。而 IndexLink 组件会使用路径的精确匹配。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;IndexLink to=&quot;/&quot; activeClassName=&quot;active&quot;&gt;</span><br><span class="line">  Home</span><br><span class="line">&lt;/IndexLink&gt;</span><br></pre></td></tr></table></figure></p><p>上面代码中，根路由只会在精确匹配时，才具有 activeClassName 。</p><p>另一种方法是使用 Link 组件的 onlyActiveOnIndex 属性，也能达到同样效果。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=&quot;/&quot; activeClassName=&quot;active&quot; onlyActiveOnIndex=&#123;true&#125;&gt;</span><br><span class="line">  Home</span><br><span class="line">&lt;/Link&gt;</span><br></pre></td></tr></table></figure><p>实际上， IndexLink 就是对 Link 组件的 onlyActiveOnIndex 属性的包装。</p><h2 id="十、histroy-属性"><a href="#十、histroy-属性" class="headerlink" title="十、histroy 属性"></a>十、histroy 属性</h2><p>Router 组件的 history 属性，用来监听浏览器地址栏的变化，并将URL解析成一个地址对象，供 React Router 匹配。</p><p>history 属性，一共可以设置三种值。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">browserHistory</span><br><span class="line">hashHistory</span><br><span class="line">createMemoryHistory</span><br></pre></td></tr></table></figure></p><p>如果设为 hashHistory ，路由将通过URL的hash部分（ # ）切换，URL的形式类似 example.com/#/some/path 。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; hashHistory &#125; from &apos;react-router&apos;</span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  &lt;Router history=&#123;hashHistory&#125; routes=&#123;routes&#125; /&gt;,</span><br><span class="line">  document.getElementById(&apos;app&apos;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如果设为 browserHistory ，浏览器的路由就不再通过 Hash 完成了，而显示正常的路径 example.com/some/path ，背后调用的是浏览器的History API。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; browserHistory &#125; from &apos;react-router&apos;</span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  &lt;Router history=&#123;browserHistory&#125; routes=&#123;routes&#125; /&gt;,</span><br><span class="line">  document.getElementById(&apos;app&apos;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>但是，这种情况需要对 服务器改造 。否则用户直接向服务器请求某个子路由，会显示网页找不到的404错误。</p><p>如果开发服务器使用的是 webpack-dev-server ，加上 –history-api-fallback 参数就可以了。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ webpack-dev-server --inline --content-base . --history-api-fallback</span><br><span class="line"></span><br><span class="line">createMemoryHistory 主要用于服务器渲染。它创建一个内存中的 history 对象，不与浏览器URL互动。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const history = createMemoryHistory(location)</span><br></pre></td></tr></table></figure><h2 id="十一、表单处理"><a href="#十一、表单处理" class="headerlink" title="十一、表单处理"></a>十一、表单处理</h2><p>Link 组件用于正常的用户点击跳转，但是有时还需要表单跳转、点击按钮跳转等操作。这些情况怎么跟React Router对接呢？</p><p>下面是一个表单。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; placeholder=&quot;userName&quot;/&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; placeholder=&quot;repo&quot;/&gt;</span><br><span class="line">  &lt;button type=&quot;submit&quot;&gt;Go&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>第一种方法是使用 browserHistory.push</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; browserHistory &#125; from &apos;react-router&apos;</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    event.preventDefault()</span><br><span class="line">    const userName = event.target.elements[0].value</span><br><span class="line">    const repo = event.target.elements[1].value</span><br><span class="line">    const path = `/repos/$&#123;userName&#125;/$&#123;repo&#125;`</span><br><span class="line">    browserHistory.push(path)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>第二种方法是使用 context 对象。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">export default React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">  // ask for `router` from context</span><br><span class="line">  contextTypes: &#123;</span><br><span class="line">    router: React.PropTypes.object</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    // ...</span><br><span class="line">    this.context.router.push(path)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="十二、路由的钩子"><a href="#十二、路由的钩子" class="headerlink" title="十二、路由的钩子"></a>十二、路由的钩子</h2><p>每个路由都有 Enter 和 Leave 钩子，用户进入或离开该路由时触发。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&quot;about&quot; component=&#123;About&#125; /&gt;</span><br><span class="line">&lt;Route path=&quot;inbox&quot; component=&#123;Inbox&#125;&gt;</span><br><span class="line">  &lt;Redirect from=&quot;messages/:id&quot; to=&quot;/messages/:id&quot; /&gt;</span><br><span class="line">&lt;/Route&gt;</span><br></pre></td></tr></table></figure><p>上面的代码中，如果用户离开 /messages/:id ，进入 /about 时，会依次触发以下的钩子。</p><p>/messages/:id 的 onLeave<br>/inbox 的 onLeave<br>/about 的 onEnter<br>下面是一个例子，使用 onEnter 钩子替代 <redirect> 组件。</redirect></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&quot;inbox&quot; component=&#123;Inbox&#125;&gt;</span><br><span class="line">  &lt;Route</span><br><span class="line">    path=&quot;messages/:id&quot;</span><br><span class="line">    onEnter=&#123;</span><br><span class="line">      (&#123;params&#125;, replace) =&gt; replace(`/messages/$&#123;params.id&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">  /&gt;</span><br><span class="line">&lt;/Route&gt;</span><br></pre></td></tr></table></figure><p>下面是一个高级应用，当用户离开一个路径的时候，跳出一个提示框，要求用户确认是否离开。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const Home = withRouter(</span><br><span class="line">  React.createClass(&#123;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      this.props.router.setRouteLeaveHook(</span><br><span class="line">        this.props.route,</span><br><span class="line">        this.routerWillLeave</span><br><span class="line">      )</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    routerWillLeave(nextLocation) &#123;</span><br><span class="line">      // 返回 false 会继续停留当前页面，</span><br><span class="line">      // 否则，返回一个字符串，会显示给用户，让其自己决定</span><br><span class="line">      if (!this.state.isSaved)</span><br><span class="line">        return &apos;确认要离开？&apos;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>上面代码中， setRouteLeaveHook 方法为 Leave 钩子指定 routerWillLeave 函数。该方法如果返回 false ，将阻止路由的切换，否则就返回一个字符串，提示用户决定是否要切换。</p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> router </tag>
            
            <tag> 路由 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redux使用入门</title>
      <link href="/2019/07/13/React/redux/"/>
      <url>/2019/07/13/React/redux/</url>
      
        <content type="html"><![CDATA[<h1 id="Redux使用入门"><a href="#Redux使用入门" class="headerlink" title="Redux使用入门"></a>Redux使用入门</h1><p><a href="http://cn.redux.js.org/" target="_blank" rel="noopener">参考网站</a></p><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>随着WEB应用变得越来越复杂，再加上node前后端分离越来越流行，那么对数据流动的控制就显得越发重要。redux是在flux的基础上产生的，基本思想是保证数据的单向流动，同时便于控制、使用、测试。</p><p>redux不依赖于任意框架(库)，只要subscribe相应框架(库)的内部方法，就可以使用该应用框架保证数据流动的一致性。</p><p>那么如何使用redux呢？下面一步步进行解析，并带有源码说明，不仅做到 知其然 ，还要做到 知其所以然 。</p><h3 id="2-主干逻辑介绍-createStore"><a href="#2-主干逻辑介绍-createStore" class="headerlink" title="2. 主干逻辑介绍(createStore)"></a>2. 主干逻辑介绍(createStore)</h3><h4 id="2-1-简单demo入门"><a href="#2-1-简单demo入门" class="headerlink" title="2.1 简单demo入门"></a>2.1 简单demo入门</h4><p>先来一个直观的认识：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 首先定义一个改变数据的plain函数，成为reducer</span><br><span class="line">function count (state, action) &#123;</span><br><span class="line">  var defaultState = &#123;</span><br><span class="line">    year: 2015,</span><br><span class="line">  &#125;;</span><br><span class="line">  state = state || defaultState;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case &apos;add&apos;:</span><br><span class="line">      return &#123;</span><br><span class="line">        year: state.year + 1</span><br><span class="line">      &#125;;</span><br><span class="line">    case &apos;sub&apos;:</span><br><span class="line">      return &#123;</span><br><span class="line">        year: state.year - 1</span><br><span class="line">      &#125;</span><br><span class="line">    default :</span><br><span class="line">      return state;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">// store的创建</span><br><span class="line">var createStore = require(&apos;redux&apos;).createStore;</span><br><span class="line">var store = createStore(count);</span><br><span class="line"></span><br><span class="line">// store里面的数据发生改变时，触发的回调函数</span><br><span class="line">store.subscribe(function () &#123;</span><br><span class="line">  console.log(&apos;the year is: &apos;, store.getState().year);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// action: 触发state改变的唯一方法(按照redux的设计思路)</span><br><span class="line">var action1 = &#123; type: &apos;add&apos; &#125;;</span><br><span class="line">var action2 = &#123; type: &apos;add&apos; &#125;;</span><br><span class="line">var action3 = &#123; type: &apos;sub&apos; &#125;;</span><br><span class="line"></span><br><span class="line">// 改变store里面的方法</span><br><span class="line">store.dispatch(action1); // &apos;the year is: 2016</span><br><span class="line">store.dispatch(action2); // &apos;the year is: 2017</span><br><span class="line">store.dispatch(action3); // &apos;the year is: 2016</span><br></pre></td></tr></table></figure></p><h4 id="2-2-挖掘createStore实现"><a href="#2-2-挖掘createStore实现" class="headerlink" title="2.2 挖掘createStore实现"></a>2.2 挖掘createStore实现</h4><p>为了说明主要问题，仅列出其中的关键代码，全部代码，可以点击 这里 阅读。</p><p>a首先看createStore到底都返回的内容:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export default function createStore(reducer, initialState) &#123;</span><br><span class="line">  ...</span><br><span class="line">  return &#123;</span><br><span class="line">    dispatch,</span><br><span class="line">    subscribe,</span><br><span class="line">    getState,</span><br><span class="line">    replaceReducer</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每个属性的含义是: - dispatch: 用于action的分发，改变store里面的state - subscribe: 注册listener，store里面state发生改变后，执行该listener - getState: 读取store里面的state - replaceReducer: 替换reducer，改变state修改的逻辑</p><p>b关键代码解析<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">export default function createStore(reducer, initialState) &#123;</span><br><span class="line">  // 这些都是闭包变量</span><br><span class="line">  var currentReducer = reducer</span><br><span class="line">  var currentState = initialState</span><br><span class="line">  var listeners = []</span><br><span class="line">  var isDispatching = false;</span><br><span class="line"></span><br><span class="line">  // 返回当前的state</span><br><span class="line">  function getState() &#123;</span><br><span class="line">    return currentState</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 注册listener，同时返回一个取消事件注册的方法</span><br><span class="line">  function subscribe(listener) &#123;</span><br><span class="line">    listeners.push(listener)</span><br><span class="line">    var isSubscribed = true</span><br><span class="line"></span><br><span class="line">    return function unsubscribe() &#123;</span><br><span class="line">    if (!isSubscribed) &#123;</span><br><span class="line">   return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isSubscribed = false</span><br><span class="line">    var index = listeners.indexOf(listener)</span><br><span class="line">      listeners.splice(index, 1)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 通过action该改变state，然后执行subscribe注册的方法</span><br><span class="line">  function dispatch(action) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      isDispatching = true</span><br><span class="line">      currentState = currentReducer(currentState, action)</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      isDispatching = false</span><br><span class="line">    &#125;</span><br><span class="line">    listeners.slice().forEach(listener =&gt; listener())</span><br><span class="line">    return action</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 替换reducer，修改state变化的逻辑</span><br><span class="line">  function replaceReducer(nextReducer) &#123;</span><br><span class="line">    currentReducer = nextReducer</span><br><span class="line">    dispatch(&#123; type: ActionTypes.INIT &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  // 初始化时，执行内部一个dispatch，得到初始state</span><br><span class="line">  dispatch(&#123; type: ActionTypes.INIT &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果还按照2.1的方式进行开发，那跟flux没有什么大的区别，需要手动解决很多问题，那redux如何将整个流程模板化(Boilerplate)呢?</p><h3 id="3-保证store的唯一性"><a href="#3-保证store的唯一性" class="headerlink" title="3. 保证store的唯一性"></a>3. 保证store的唯一性</h3><p>随着应用越来越大，一方面，不能把所有的数据都放到一个reducer里面，另一方面，为每个reducer创建一个store，后续store的维护就显得比较麻烦。如何将二者统一起来呢？</p><h4 id="3-1-demo入手"><a href="#3-1-demo入手" class="headerlink" title="3.1 demo入手"></a>3.1 demo入手</h4><p>通过combineReducers将多个reducer合并成一个rootReducer: // 创建两个reducer: count year function count (state, action) { state = state || {count: 1} switch (action.type) { default: return state; } } function year (state, action) { state = state || {year: 2015} switch (action.type) { default: return state; } }<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 将多个reducer合并成一个</span><br><span class="line">var combineReducers = require(&apos;./&apos;).combineReducers;</span><br><span class="line">var rootReducer = combineReducers(&#123;</span><br><span class="line">  count: count,</span><br><span class="line">  year: year,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 创建store，跟2.1没有任何区别</span><br><span class="line">var createStore = require(&apos;./&apos;).createStore;</span><br><span class="line">var store = createStore(rootReducer);</span><br><span class="line"></span><br><span class="line">var util = require(&apos;util&apos;);</span><br><span class="line">console.log(util.inspect(store));</span><br><span class="line">//输出的结果，跟2.1的store在结构上不存在区别</span><br><span class="line">// &#123; dispatch: [Function: dispatch],</span><br><span class="line">//   subscribe: [Function: subscribe],</span><br><span class="line">//   getState: [Function: getState],</span><br><span class="line">//   replaceReducer: [Function: replaceReducer]</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-2-源码解析combineReducers"><a href="#3-2-源码解析combineReducers" class="headerlink" title="3.2 源码解析combineReducers"></a>3.2 源码解析combineReducers</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 高阶函数，最后返回一个reducer</span><br><span class="line">export default function combineReducers(reducers) &#123;</span><br><span class="line">  // 提出不合法的reducers, finalReducers就是一个闭包变量</span><br><span class="line">  var finalReducers = pick(reducers, (val) =&gt; typeof val === &apos;function&apos;)</span><br><span class="line">  // 将各个reducer的初始state均设置为undefined</span><br><span class="line">  var defaultState = mapValues(finalReducers, () =&gt; undefined)</span><br><span class="line"></span><br><span class="line">  // 一个总reducer，内部包含子reducer</span><br><span class="line">  return function combination(state = defaultState, action) &#123;</span><br><span class="line">    var finalState = mapValues(finalReducers, (reducer, key) =&gt; &#123;</span><br><span class="line">      var previousStateForKey = state[key]</span><br><span class="line">      var nextStateForKey = reducer(previousStateForKey, action)</span><br><span class="line">      hasChanged = hasChanged || nextStateForKey !== previousStateForKey</span><br><span class="line">      return nextStateForKey</span><br><span class="line">    );</span><br><span class="line">    return hasChanged ? finalState : state</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-自动实现dispatch"><a href="#4-自动实现dispatch" class="headerlink" title="4. 自动实现dispatch"></a>4. 自动实现dispatch</h3><h4 id="4-1-demo介绍"><a href="#4-1-demo介绍" class="headerlink" title="4.1 demo介绍"></a>4.1 demo介绍</h4><p>在2.1中，要执行state的改变，需要手动dispatch:</p><p>var action = { type: ‘<strong><em>‘, payload: ‘</em></strong>‘};<br>dispatch(action);<br>手动dispatch就显得啰嗦了，那么如何自动完成呢?<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var bindActionCreators = require(&apos;redux&apos;).bindActionCreators;</span><br><span class="line">// 可以在具体的应用框架隐式进行该过程(例如react-redux的connect组件中)</span><br><span class="line">bindActionCreators(action)</span><br></pre></td></tr></table></figure></p><h4 id="4-2-源码解析"><a href="#4-2-源码解析" class="headerlink" title="4.2 源码解析"></a>4.2 源码解析</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 隐式实现dispatch</span><br><span class="line">function bindActionCreator(actionCreator, dispatch) &#123;</span><br><span class="line">  return (...args) =&gt; dispatch(actionCreator(...args))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default function bindActionCreators(actionCreators, dispatch) &#123;</span><br><span class="line">  if (typeof actionCreators === &apos;function&apos;) &#123;</span><br><span class="line">    return bindActionCreator(actionCreators, dispatch)</span><br><span class="line">  &#125;</span><br><span class="line">  return mapValues(actionCreators, actionCreator =&gt;</span><br><span class="line">    bindAQctionCreator(actionCreator, dispatch)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-支持插件-对dispatch的改造"><a href="#5-支持插件-对dispatch的改造" class="headerlink" title="5. 支持插件 - 对dispatch的改造"></a>5. 支持插件 - 对dispatch的改造</h3><h4 id="5-1-插件使用demo"><a href="#5-1-插件使用demo" class="headerlink" title="5.1 插件使用demo"></a>5.1 插件使用demo</h4><p>一个action可以是同步的，也可能是异步的，这是两种不同的情况， dispatch执行的时机是不一样的:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 同步的action creator, store可以默认实现dispatch</span><br><span class="line">function add() &#123;</span><br><span class="line">  return &#123; tyle: &apos;add&apos; &#125;</span><br><span class="line">&#125;</span><br><span class="line">dispatch(add());</span><br><span class="line"></span><br><span class="line">// 异步的action creator，因为异步完成的时间不确定，只能手工dispatch</span><br><span class="line">function fetchDataAsync() &#123;</span><br><span class="line">  return function (dispatch) &#123;</span><br><span class="line">    requst(url).end(function (err, res) &#123;</span><br><span class="line">      if (err) return dispatch(&#123; type: &apos;SET_ERR&apos;, payload: err&#125;);</span><br><span class="line">      if (res.status === &apos;success&apos;) &#123;</span><br><span class="line">        dispatch(&#123; type: &apos;FETCH_SUCCESS&apos;, payload: res.data &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面的问题就变成了，如何根据实际情况实现不同的dispatch方法，也即是根据需要实现不同的moddleware:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 普通的dispatch创建方法</span><br><span class="line">var store = createStore(reducer, initialState);</span><br><span class="line">console.log(store.dispatch);</span><br><span class="line"></span><br><span class="line">// 定制化的dispatch</span><br><span class="line">var applyMiddleware = require(&apos;redux&apos;).applyMiddleware;</span><br><span class="line">// 实现action异步的middleware</span><br><span class="line">var thunk = requre(&apos;redux-thunk&apos;);</span><br><span class="line">var store = applyMiddleware([thunk])(createStore);</span><br><span class="line">// 经过处理的dispatch方法</span><br><span class="line">console.log(store.dispatch);</span><br></pre></td></tr></table></figure></p><h4 id="5-2-源码解析"><a href="#5-2-源码解析" class="headerlink" title="5.2 源码解析"></a>5.2 源码解析</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// next: 其实就是createStore</span><br><span class="line">export default function applyMiddleware(...middlewares) &#123;</span><br><span class="line">  return (next) =&gt; (reducer, initialState) =&gt; &#123;</span><br><span class="line">    var store = next(reducer, initialState)</span><br><span class="line">    var dispatch = store.dispatch</span><br><span class="line">    var chain = []</span><br><span class="line"></span><br><span class="line">    var middlewareAPI = &#123;</span><br><span class="line">      getState: store.getState,</span><br><span class="line">      dispatch: (action) =&gt; dispatch(action)</span><br><span class="line">    &#125;</span><br><span class="line">    chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))</span><br><span class="line">    dispatch = compose(...chain)(store.dispatch)</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      ...store,</span><br><span class="line">      dispatch // 实现新的dispatch方法</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 再看看redux-thunk的实现, next就是store里面的上一个dispatch</span><br><span class="line">function thunkMiddleware(&#123; dispatch, getState &#125;) &#123;</span><br><span class="line">  return function(next) &#123;</span><br><span class="line">    return function(action) &#123;</span><br><span class="line">      typeof action === &apos;function&apos; ? action(dispatch, getState) : next(action);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return next =&gt; action =&gt;</span><br><span class="line">    typeof action === &apos;function&apos; ?</span><br><span class="line">      action(dispatch, getState) :</span><br><span class="line">      next(action);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="6-与react框架的结合"><a href="#6-与react框架的结合" class="headerlink" title="6. 与react框架的结合"></a>6. 与react框架的结合</h3><p>####6.1 基本使用</p><p>目前已经有现成的工具 react-redux 来实现二者的结合:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var rootReducers = combineReducers(reducers);</span><br><span class="line">var store = createStore(rootReducers);</span><br><span class="line">var Provider = require(&apos;react-redux&apos;).Provider;</span><br><span class="line">// App 为上层的Component</span><br><span class="line">class App extend React.Component&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;Provier store=&#123;store&#125;&gt;</span><br><span class="line">        &lt;Container /&gt;</span><br><span class="line">      &lt;/Provider&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Container作用: 1. 获取store中的数据; 2.将dispatch与actionCreator结合起来</span><br><span class="line">var connect = require(&apos;react-redux&apos;).connect;</span><br><span class="line">var actionCreators = require(&apos;...&apos;);</span><br><span class="line">// MyComponent是与redux无关的组件</span><br><span class="line">var MyComponent = require(&apos;...&apos;);</span><br><span class="line"></span><br><span class="line">function select(state) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    count: state.count</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default connect(select, actionCreators)(MyComponent)</span><br></pre></td></tr></table></figure></p><h4 id="6-2-Provider-–-提供store"><a href="#6-2-Provider-–-提供store" class="headerlink" title="6.2 Provider – 提供store"></a>6.2 Provider – 提供store</h4><p>React通过Context属性，可以将属性(props)直接给子孙component，无须通过props层层传递, Provider仅仅起到获得store，然后将其传递给子孙元素而已:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">export default class Provider extends Component &#123;</span><br><span class="line">  getChildContext() &#123; // getChildContext: 将store传递给子孙component</span><br><span class="line">    return &#123; store: this.store &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  constructor(props, context) &#123;</span><br><span class="line">    super(props, context)</span><br><span class="line">    this.store = props.store</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">    const &#123; store &#125; = this</span><br><span class="line">    const &#123; store: nextStore &#125; = nextProps</span><br><span class="line"></span><br><span class="line">    if (store !== nextStore) &#123;</span><br><span class="line">      warnAboutReceivingStore()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    let &#123; children &#125; = this.props</span><br><span class="line">    return Children.only(children)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="6-3-connect-–-获得store及dispatch-actionCreator"><a href="#6-3-connect-–-获得store及dispatch-actionCreator" class="headerlink" title="6.3 connect – 获得store及dispatch(actionCreator)"></a>6.3 connect – 获得store及dispatch(actionCreator)</h4><p>connect是一个高阶函数，首先传入mapStateToProps、mapDispatchToProps，然后返回一个生产 Component 的函数(wrapWithConnect)，然后再将真正的Component作为参数传入wrapWithConnect(MyComponent)，这样就生产出一个经过包裹的Connect组件，该组件具有如下特点:</p><p>通过this.context获取祖先Component的store<br>props包括stateProps、dispatchProps、parentProps,合并在一起得到 nextState ，作为props传给真正的Component<br>componentDidMount时，添加事件this.store.subscribe(this.handleChange)，实现页面交互<br>shouldComponentUpdate时判断是否有避免进行渲染，提升页面性能，并得到nextState<br>componentWillUnmount时移除注册的事件this.handleChange<br>在非生产环境下，带有热重载功能<br>主要的代码逻辑:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">export default function connect(mapStateToProps, mapDispatchToProps, mergeProps, options = &#123;&#125;) &#123;</span><br><span class="line">  return function wrapWithConnect(WrappedComponent) &#123;</span><br><span class="line">    class Connect extends Component &#123;</span><br><span class="line">      constructor(props, context) &#123;</span><br><span class="line">        // 从祖先Component处获得store</span><br><span class="line">        this.store = props.store || context.store</span><br><span class="line">        this.stateProps = computeStateProps(this.store, props)</span><br><span class="line">        this.dispatchProps = computeDispatchProps(this.store, props)</span><br><span class="line">        this.state = &#123; storeState: null &#125;</span><br><span class="line">        // 对stateProps、dispatchProps、parentProps进行合并</span><br><span class="line">        this.updateState()</span><br><span class="line">      &#125;</span><br><span class="line">      shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">        // 进行判断，当数据发生改变时，Component重新渲染</span><br><span class="line">        if (propsChanged || mapStateProducedChange || dispatchPropsChanged) &#123;</span><br><span class="line">          this.updateState(nextProps)</span><br><span class="line">            return true</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        componentDidMount() &#123;</span><br><span class="line">          // 改变Component的state</span><br><span class="line">          this.store.subscribe(() = &#123;</span><br><span class="line">            this.setState(&#123;</span><br><span class="line">              storeState: this.store.getState()</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        render() &#123;</span><br><span class="line">          // 生成包裹组件Connect</span><br><span class="line">          return (</span><br><span class="line">            &lt;WrappedComponent &#123;...this.nextState&#125; /&gt;</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      Connect.contextTypes = &#123;</span><br><span class="line">        store: storeShape</span><br><span class="line">      &#125;</span><br><span class="line">      return Connect;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="7-redux与react-redux关系图"><a href="#7-redux与react-redux关系图" class="headerlink" title="7. redux与react-redux关系图"></a>7. redux与react-redux关系图</h3><p><img src="images/redux.png!web"></p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> 数据层 </tag>
            
            <tag> redux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MobX入坑</title>
      <link href="/2019/07/13/React/mobx/"/>
      <url>/2019/07/13/React/mobx/</url>
      
        <content type="html"><![CDATA[<h1 id="MobX入坑"><a href="#MobX入坑" class="headerlink" title="MobX入坑"></a>MobX入坑</h1><p>MobX 是一个简单、方便扩展、久经考验的状态管理解决方案。这个教程旨在十分钟内向你介绍 MobX 的一些重要概念。MobX 是一个独立的苦，不过大多数人都把它和 React 一起使用，所以本教程也就着眼于这个组合展开。</p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p>State 是每一个应用程序的核心部分，而使用一个不合规范的 State 则是让你的应用充满 bug 和失控的不二法门，或者就是局部变量环绕，让你的 state 失去了同步。有很多框架试图解决这个问题，比如使用不可变的 state，但是这样以来又带来了新的问题，比如数据必须规格化，完整性约束失效等等。</p><p>MobX 让整个事情又变简单了：它不允许产生失控的 state。它的理念也很简单：所有可以从 state 中派生的事物，都会自动的派生。</p><p>把 MobX 想象成 Excel 表格。</p><p>首先，有一个 state，它可以是一个object，array，primitives等等任何组成你程序的部分。你可以把这个想象成你应用程序的“单元格”。<br>然后就是 derivations，一般它是指可以从 state 中直接计算的来的结果。比如未完成的任务的数量，这个比较简单，也可以稍复杂一些比如渲染你的任务显示的html。它类似于你的应用程序中的“公式和图表”。<br>Reactions 和 derivations 很像，主要的区别在于 reactions 并不产生数据结果，而是自动完成一些任务，一般是和 I/O 相关的。他们保证了 DOM 和 网络请求会自动适时地出发。<br>最后是 actions。Actions 指的是所有会改变 state 的事情，MobX 保证所有 actions 都会有对应的 derivations 和 reactions 相伴，保证同步。<br>一个简单的 todo 的 state</p><p>理论说的够多的了，看一个例子也许会更明白一些。我们从一个简单的 todo 程序开始。</p><p>下面是一个简单直接的 TodoStore，没有鱼丸，没有粗面，没有 MobX ……</p><p>JavaScript<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class TodoStore &#123;</span><br><span class="line">todos = [];</span><br><span class="line"></span><br><span class="line">get completedTodosCount() &#123;</span><br><span class="line">    return this.todos.filter(</span><br><span class="line">todo =&gt; todo.completed === true</span><br><span class="line">).length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">report() &#123;</span><br><span class="line">if (this.todos.length === 0)</span><br><span class="line">return &quot;&lt;none&gt;&quot;;</span><br><span class="line">return `Next todo: &quot;$&#123;this.todos[0].task&#125;&quot;. ` +</span><br><span class="line">`Progress: $&#123;this.completedTodosCount&#125;/$&#123;this.todos.length&#125;`;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    addTodo(task) &#123;</span><br><span class="line">this.todos.push(&#123;</span><br><span class="line">task: task,</span><br><span class="line">completed: false,</span><br><span class="line">            assignee: null</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const todoStore = new TodoStore();</span><br></pre></td></tr></table></figure></p><p>我们创建了一个 todoStore，它拥有一个 todos 集合。现在我们往这个 todoStore 里添加一些东西，为了明显起见，我们每修改一个地方，就调用todoStore.report。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">todoStore.addTodo(&quot;read MobX tutorial&quot;);</span><br><span class="line">console.log(todoStore.report());</span><br><span class="line">​</span><br><span class="line">todoStore.addTodo(&quot;try MobX&quot;);</span><br><span class="line">console.log(todoStore.report());</span><br><span class="line">​</span><br><span class="line">todoStore.todos[0].completed = true;</span><br><span class="line">console.log(todoStore.report());</span><br><span class="line">​</span><br><span class="line">todoStore.todos[1].task = &quot;try MobX in own project&quot;;</span><br><span class="line">console.log(todoStore.report());</span><br><span class="line">​</span><br><span class="line">todoStore.todos[0].task = &quot;grok MobX tutorial&quot;;</span><br><span class="line">console.log(todoStore.report());</span><br></pre></td></tr></table></figure><p>到现在为止，没有什么特别的。不过如果我们可以不再手动调用 report 方法，事情会不会更美好一些？我们只需要在想要的地方修改这个 state，所有的汇报都自动来做。</p><p>太巧了，这就是 MobX 能为你做的事情。自动执行只在 state 改变的时候触发，就好像 Excel 中的图表只在单元格数据改变时更新一样。为了达到这个目标，TodoStore 必须成为可观测的（observable）才行，让我们来改一些代码。</p><p>同时，completedTodosCount 属性应该被自动派生，使用 @observable 和 @computed 装饰器来做这些事情：</p><p>JavaScript<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">class ObservableTodoStore &#123;</span><br><span class="line">    @observable todos = [];</span><br><span class="line">    @observable pendingRequests = 0;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        mobx.autorun(() =&gt; console.log(this.report));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @computed get completedTodosCount() &#123;</span><br><span class="line">    return this.todos.filter(</span><br><span class="line">todo =&gt; todo.completed === true</span><br><span class="line">).length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @computed get report() &#123;</span><br><span class="line">        if (this.todos.length === 0)</span><br><span class="line">            return &quot;&lt;none&gt;&quot;;</span><br><span class="line">return `Next todo: &quot;$&#123;this.todos[0].task&#125;&quot;. ` +</span><br><span class="line">    `Progress: $&#123;this.completedTodosCount&#125;/$&#123;this.todos.length&#125;`;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    addTodo(task) &#123;</span><br><span class="line">this.todos.push(&#123;</span><br><span class="line">    task: task,</span><br><span class="line">    completed: false,</span><br><span class="line">    assignee: null</span><br><span class="line">&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const observableTodoStore = new ObservableTodoStore();</span><br><span class="line"></span><br><span class="line">class ObservableTodoStore &#123;</span><br><span class="line">    @observable todos = [];</span><br><span class="line">    @observable pendingRequests = 0;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        mobx.autorun(() =&gt; console.log(this.report));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @computed get completedTodosCount() &#123;</span><br><span class="line">    return this.todos.filter(</span><br><span class="line">todo =&gt; todo.completed === true</span><br><span class="line">).length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @computed get report() &#123;</span><br><span class="line">        if (this.todos.length === 0)</span><br><span class="line">            return &quot;&lt;none&gt;&quot;;</span><br><span class="line">return `Next todo: &quot;$&#123;this.todos[0].task&#125;&quot;. ` +</span><br><span class="line">    `Progress: $&#123;this.completedTodosCount&#125;/$&#123;this.todos.length&#125;`;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    addTodo(task) &#123;</span><br><span class="line">this.todos.push(&#123;</span><br><span class="line">    task: task,</span><br><span class="line">    completed: false,</span><br><span class="line">    assignee: null</span><br><span class="line">&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const observableTodoStore = new ObservableTodoStore();</span><br></pre></td></tr></table></figure></p><p>运行它，太棒了，我们每次赋值都能获得输出结果了。</p><p>有个 pendingRequests 暂时没用到，我们后面会用。另外这个教程都用了 ES6 的写法，不过 MobX 也支持 ES5 的写法。</p><p>在这个构造器中，我们使用autorun包裹了一个打出report的小函数。Autorun里的东西首先会运行一次，然后当其中的函数有observable的数据发生变化时，会再次运行。 这里我们使用了todos属性，每次todos变化了我们就打印出新的东西。</p><p>JavaScript<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">observableTodoStore.addTodo(&quot;read MobX tutorial&quot;);</span><br><span class="line">observableTodoStore.addTodo(&quot;try MobX&quot;);</span><br><span class="line">observableTodoStore.todos[0].completed = true;</span><br><span class="line">observableTodoStore.todos[1].task = &quot;try MobX in own project&quot;;</span><br><span class="line">observableTodoStore.todos[0].task = &quot;grok MobX tutorial&quot;;</span><br></pre></td></tr></table></figure></p><p>（可以自己试试结果）</p><p>非常有趣是吧，report确实自己执行了，而且同步又精准。如果你仔细查看运行结果的话，你挥发性我们的第四句语句没有产生输出，因为我们修改了todos[1]的数据，而我们在report中指明的数据，并没有todos[1]的变化而发生变化。而第五句话修改了todos[0]的数据则输出了。这个例子很好的说明了，autorun不是简单的监视了todos，而是精确到了具体的一项。</p><p>让React更美好</p><p>好了，到目前未知，我们使report自动化了，是实话把react拉出来遛遛了。为了是的react 的组件可以识别mobx，我们需要使用mobx-react包来完成，使用autorun，自动的让组件和state同步，这个简直就和上面的让report自动输出一样简单。</p><p>下面是一个react 组件，唯一MobX出场的地方就是一个@observer修饰符，这已经足够了，你再也不用使用setState了，你也不需要指明这个组件需要关注state的哪个部分，也不许手动写什么高阶组件。一般来说，所有的部件都变成人工智能了，即使他被定义成一个木偶（纯展示）组件。</p><p>JavaScript<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">@observer</span><br><span class="line">class TodoList extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const store = this.props.store;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123; store.report &#125;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">          &#123; store.todos.map(</span><br><span class="line">            (todo, idx) =&gt; &lt;TodoView todo=&#123; todo &#125; key=&#123; idx &#125; /&gt;</span><br><span class="line">          ) &#125;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">        &#123; store.pendingRequests &gt; 0 ? &lt;marquee&gt;Loading...&lt;/marquee&gt; : null &#125;</span><br><span class="line">        &lt;button onClick=&#123; this.onNewTodo &#125;&gt;New Todo&lt;/button&gt;</span><br><span class="line">        &lt;small&gt; (double-click a todo to edit)&lt;/small&gt;</span><br><span class="line">      &lt;RenderCounter /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">​</span><br><span class="line">  onNewTodo = () =&gt; &#123;</span><br><span class="line">    this.props.store.addTodo(prompt(&apos;Enter a new todo:&apos;,&apos;coffee plz&apos;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">@observer</span><br><span class="line">class TodoView extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const todo = this.props.todo;</span><br><span class="line">    return (</span><br><span class="line">      &lt;li onDoubleClick=&#123; this.onRename &#125;&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=&apos;checkbox&apos;</span><br><span class="line">          checked=&#123; todo.completed &#125;</span><br><span class="line">          onChange=&#123; this.onToggleCompleted &#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &#123; todo.task &#125;</span><br><span class="line">        &#123; todo.assignee</span><br><span class="line">          ? &lt;small&gt;&#123; todo.assignee.name &#125;&lt;/small&gt;</span><br><span class="line">          : null</span><br><span class="line">        &#125;</span><br><span class="line">      &lt;RenderCounter /&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">​</span><br><span class="line">  onToggleCompleted = () =&gt; &#123;</span><br><span class="line">    const todo = this.props.todo;</span><br><span class="line">    todo.completed = !todo.completed;</span><br><span class="line">  &#125;</span><br><span class="line">​</span><br><span class="line">  onRename = () =&gt; &#123;</span><br><span class="line">    const todo = this.props.todo;</span><br><span class="line">    todo.task = prompt(&apos;Task name&apos;, todo.task) || todo.task;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;TodoList store=&#123; observableTodoStore &#125; /&gt;,</span><br><span class="line">  document.getElementById(&apos;reactjs-app&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>执行下面的语句，我们会发现MobX帮我们把数据的更改反应到界面上去了。</p><p>JavaScript<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">store.todos[0].completed = !store.todos[0].completed;</span><br><span class="line">store.todos[1].task = &quot;Random todo &quot; + Math.random();</span><br><span class="line">store.todos.push(&#123; task: &quot;Find a fine cheese&quot;, completed: true &#125;);</span><br><span class="line">// etc etc.. add your own statements here...</span><br></pre></td></tr></table></figure></p><p>使用引用（References)</p><p>到现在位置，我们已经使用 observable 创建了个数据类型了。也许你会想，MobX 能不能应付引用呢？在之前的例子里，你可能主意到了又一个 assignee 的属性，我们就在这里放另外的一个 store，然后把它赋值给 tasks。</p><p>JavaScript<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var peopleStore = mobx.observable([</span><br><span class="line">  &#123; name: &quot;Michel&quot; &#125;,</span><br><span class="line">  &#123; name: &quot;Me&quot; &#125;</span><br><span class="line">]);</span><br><span class="line">observableTodoStore.todos[0].assignee = peopleStore[0];</span><br><span class="line">observableTodoStore.todos[1].assignee = peopleStore[1];</span><br><span class="line">peopleStore[0].name = &quot;Michel Weststrate&quot;;</span><br></pre></td></tr></table></figure></p><p>毫无疑问的，MobX 把着一切打理的井井有条。使用 MobX ，不需要规格话数据，不需要指明控件，事实上你的数据在哪里都无所谓。只要 observale 了，什么都好了。</p><p>总结</p><p>好了，仅仅依靠一些简单的修饰器，我们就让 react 程序如此生动有趣。最后总结一些：</p><p>@observale 修饰器或者 observable 函数让对象可以被追踪；<br>@computed 修饰器创造了自动运算的表达式；<br>autorun 函数让依靠 observable 的函数自动执行，这个用来写 log，发请求很不错；<br>@observer 修饰器让 React 组建自动起来，它会自动更新，即便是在一个很大的程序里也会工作的很好；</p><p>最后，MobX 不是一个状态容器</p><p>很多人把 MobX 当作另外一个 Redux，但是它仅仅是一个库，不是一个什么架构。上面的例子还是需要程序员自己去组织逻辑和store或者控制器什么的。</p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> mobx </tag>
            
            <tag> 数据层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack项目搭建</title>
      <link href="/2019/07/13/React/webpack/"/>
      <url>/2019/07/13/React/webpack/</url>
      
        <content type="html"><![CDATA[<h1 id="webpack项目搭建"><a href="#webpack项目搭建" class="headerlink" title="webpack项目搭建"></a>webpack项目搭建</h1><h3 id="什么是-webpack？"><a href="#什么是-webpack？" class="headerlink" title="什么是 webpack？"></a>什么是 webpack？</h3><p>webpack是近期最火的一款模块加载器兼打包工具，它能把各种资源，例如JS（含JSX）、coffee、样式（含less/sass）、图片等都作为模块来使用和处理。<br>我们可以直接使用 require(XXX) 的形式来引入各模块，即使它们可能需要经过编译（比如JSX和sass），但我们无须在上面花费太多心思，因为 webpack 有着各种健全的加载器（loader）在默默处理这些事情，这块我们后续会提到。<br>你可以不打算将其用在你的项目上，但没有理由不去掌握它，因为以近期 Github 上各大主流的（React相关）项目来说，它们仓库上所展示的示例已经是基于 webpack 来开发的，比如 React-Boostrap 和 Redux。<br>webpack的官网是 <a href="http://webpack.github.io/" target="_blank" rel="noopener">http://webpack.github.io/</a> ，文档地址是 <a href="http://webpack.github.io/docs/" target="_blank" rel="noopener">http://webpack.github.io/docs/</a> ，想对其进行更详细了解的可以点进去瞧一瞧。</p><h3 id="webpack-的优势"><a href="#webpack-的优势" class="headerlink" title="webpack 的优势"></a>webpack 的优势</h3><p>其优势主要可以归类为如下几个：</p><ol><li>webpack 是以 commonJS 的形式来书写脚本滴，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移。</li><li>能被模块化的不仅仅是 JS 了。</li><li>开发便捷，能替代部分 grunt/gulp 的工作，比如打包、压缩混淆、图片转base64等。</li><li>扩展性强，插件机制完善，特别是支持 React 热插拔（见 react-hot-loader ）的功能让人眼前一亮。<br>我们谈谈第一点。以 AMD/CMD 模式来说，鉴于模块是异步加载的，所以我们常规需要使用 define 函数来帮我们搞回调：<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define([&apos;package/lib&apos;], function(lib)&#123;</span><br><span class="line">    function foo()&#123;</span><br><span class="line">        lib.log(&apos;hello world!&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">        foo: foo</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><p>另外为了可以兼容 commonJS 的写法，我们也可以将 define 这么写：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">define(function (require, exports, module)&#123;</span><br><span class="line">    var someModule = require(&quot;someModule&quot;);</span><br><span class="line">    var anotherModule = require(&quot;anotherModule&quot;);    </span><br><span class="line"></span><br><span class="line">    someModule.doTehAwesome();</span><br><span class="line">    anotherModule.doMoarAwesome();</span><br><span class="line"></span><br><span class="line">    exports.asplode = function ()&#123;</span><br><span class="line">        someModule.doTehAwesome();</span><br><span class="line">        anotherModule.doMoarAwesome();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>然而对 webpack 来说，我们可以直接在上面书写 commonJS 形式的语法，无须任何 define （毕竟最终模块都打包在一起，webpack 也会最终自动加上自己的加载器）：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var someModule = require(&quot;someModule&quot;);</span><br><span class="line">    var anotherModule = require(&quot;anotherModule&quot;);    </span><br><span class="line"></span><br><span class="line">    someModule.doTehAwesome();</span><br><span class="line">    anotherModule.doMoarAwesome();</span><br><span class="line"></span><br><span class="line">    exports.asplode = function ()&#123;</span><br><span class="line">        someModule.doTehAwesome();</span><br><span class="line">        anotherModule.doMoarAwesome();</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>这样撸码自然更简单，跟回调神马的说 byebye~<br>不过即使你保留了之前 define 的写法也是可以滴，毕竟 webpack 的兼容性相当出色，方便你旧项目的模块直接迁移过来。</p><h3 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h3><h5 id="一-安装"><a href="#一-安装" class="headerlink" title="一. 安装"></a>一. 安装</h5><p>我们常规直接使用 npm 的形式来安装：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install webpack -g</span><br></pre></td></tr></table></figure></p><p>当然如果常规项目还是把依赖写入 package.json 包去更人性化：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm init</span><br><span class="line">$ npm install webpack --save-dev</span><br></pre></td></tr></table></figure></p><h5 id="二-配置"><a href="#二-配置" class="headerlink" title="二. 配置"></a>二. 配置</h5><p>每个项目下都必须配置有一个 webpack.config.js ，它的作用如同常规的 gulpfile.js/Gruntfile.js ，就是一个配置项，告诉 webpack 它需要做什么。<br>我们看看下方的示例：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">var webpack = require(&apos;webpack&apos;);</span><br><span class="line">var commonsPlugin = new webpack.optimize.CommonsChunkPlugin(&apos;common.js&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //插件项</span><br><span class="line">    plugins: [commonsPlugin],</span><br><span class="line">    //页面入口文件配置</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index : &apos;./src/js/page/index.js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    //入口文件输出配置</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: &apos;dist/js/page&apos;,</span><br><span class="line">        filename: &apos;[name].js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        //加载器配置</span><br><span class="line">        loaders: [</span><br><span class="line">            &#123; test: /\.css$/, loader: &apos;style-loader!css-loader&apos; &#125;,</span><br><span class="line">            &#123; test: /\.js$/, loader: &apos;jsx-loader?harmony&apos; &#125;,</span><br><span class="line">            &#123; test: /\.scss$/, loader: &apos;style!css!sass?sourceMap&apos;&#125;,</span><br><span class="line">            &#123; test: /\.(png|jpg)$/, loader: &apos;url-loader?limit=8192&apos;&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    //其它解决方案配置</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        root: &apos;E:/github/flux-example/src&apos;, //绝对路径</span><br><span class="line">        extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.json&apos;, &apos;.scss&apos;],</span><br><span class="line">        alias: &#123;</span><br><span class="line">            AppStore : &apos;js/stores/AppStores.js&apos;,</span><br><span class="line">            ActionType : &apos;js/actions/ActionType.js&apos;,</span><br><span class="line">            AppAction : &apos;js/actions/AppAction.js&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>⑴ plugins 是插件项，这里我们使用了一个 CommonsChunkPlugin 的插件，它用于提取多个入口文件的公共脚本部分，然后生成一个 common.js 来方便多页面之间进行复用。<br>⑵ entry 是页面入口文件配置，output 是对应输出项配置（即入口文件最终要生成什么名字的文件、存放到哪里），其语法大致为：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        page1: &quot;./page1&quot;,</span><br><span class="line">        //支持数组形式，将加载数组中的所有模块，但以最后一个模块作为输出</span><br><span class="line">        page2: [&quot;./entry1&quot;, &quot;./entry2&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: &quot;dist/js/page&quot;,</span><br><span class="line">        filename: &quot;[name].bundle.js&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该段代码最终会生成一个 page1.bundle.js 和 page2.bundle.js，并存放到 ./dist/js/page 文件夹下。<br>⑶ module.loaders 是最关键的一块配置。它告知 webpack 每一种文件都需要使用什么加载器来处理：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">        //加载器配置</span><br><span class="line">        loaders: [</span><br><span class="line">            //.css 文件使用 style-loader 和 css-loader 来处理</span><br><span class="line">            &#123; test: /\.css$/, loader: &apos;style-loader!css-loader&apos; &#125;,</span><br><span class="line">            //.js 文件使用 jsx-loader 来编译处理</span><br><span class="line">            &#123; test: /\.js$/, loader: &apos;jsx-loader?harmony&apos; &#125;,</span><br><span class="line">            //.scss 文件使用 style-loader、css-loader 和 sass-loader 来编译处理</span><br><span class="line">            &#123; test: /\.scss$/, loader: &apos;style!css!sass?sourceMap&apos;&#125;,</span><br><span class="line">            //图片文件使用 url-loader 来处理，小于8kb的直接转为base64</span><br><span class="line">            &#123; test: /\.(png|jpg)$/, loader: &apos;url-loader?limit=8192&apos;&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>如上，”-loader”其实是可以省略不写的，多个loader之间用“!”连接起来。<br>注意所有的加载器都需要通过 npm 来加载，并建议查阅它们对应的 readme 来看看如何使用。<br>拿最后一个 url-loader 来说，它会将样式中引用到的图片转为模块来处理，使用该加载器需要先进行安装：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install url-loader -save-dev</span><br></pre></td></tr></table></figure></p><p>配置信息的参数“?limit=8192”表示将所有小于8kb的图片都转为base64形式（其实应该说超过8kb的才使用 url-loader 来映射到文件，否则转为data url形式）。<br>⑷ 最后是 resolve 配置，这块很好理解，直接写注释了：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">        //查找module的话从这里开始查找</span><br><span class="line">        root: &apos;E:/github/flux-example/src&apos;, //绝对路径</span><br><span class="line">        //自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名</span><br><span class="line">        extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.json&apos;, &apos;.scss&apos;],</span><br><span class="line">        //模块别名定义，方便后续直接引用别名，无须多写长长的地址</span><br><span class="line">        alias: &#123;</span><br><span class="line">            AppStore : &apos;js/stores/AppStores.js&apos;,//后续直接 require(&apos;AppStore&apos;) 即可</span><br><span class="line">            ActionType : &apos;js/actions/ActionType.js&apos;,</span><br><span class="line">            AppAction : &apos;js/actions/AppAction.js&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>关于 webpack.config.js 更详尽的配置可以参考这里。<br>运行 webpack<br>webpack 的执行也很简单，直接执行<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ webpack --display-error-details</span><br></pre></td></tr></table></figure></p><p>即可，后面的参数“–display-error-details”是推荐加上的，方便出错时能查阅更详尽的信息（比如 webpack 寻找模块的过程），从而更好定位到问题。<br>其他主要的参数有：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ webpack --config XXX.js   //使用另一份配置文件（比如webpack.config2.js）来打包</span><br><span class="line"></span><br><span class="line">$ webpack --watch   //监听变动并自动打包</span><br><span class="line"></span><br><span class="line">$ webpack -p    //压缩混淆脚本，这个非常非常重要！</span><br><span class="line"></span><br><span class="line">$ webpack -d    //生成map映射文件，告知哪些模块被最终打包到哪里了</span><br></pre></td></tr></table></figure></p><p>其中的 -p 是很重要的参数，曾经一个未压缩的 700kb 的文件，压缩后直接降到 180kb（主要是样式这块一句就独占一行脚本，导致未压缩脚本变得很大）。</p><h3 id="模块引入"><a href="#模块引入" class="headerlink" title="模块引入"></a>模块引入</h3><p>上面唠嗑了那么多配置和执行方法，下面开始说说寻常页面和脚本怎么使用呗。</p><h5 id="一-HTML"><a href="#一-HTML" class="headerlink" title="一. HTML"></a>一. HTML</h5><p>直接在页面引入 webpack 最终生成的页面脚本即可，不用再写什么 data-main 或 seajs.use 了：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;demo&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;script src=&quot;dist/js/page/common.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script src=&quot;dist/js/page/index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>可以看到我们连样式都不用引入，毕竟脚本执行时会动态生成<style>并标签打到head里。</p><h5 id="二-JS"><a href="#二-JS" class="headerlink" title="二. JS"></a>二. JS</h5><p>各脚本模块可以直接使用 commonJS 来书写，并可以直接引入未经编译的模块，比如 JSX、sass、coffee等（只要你在 webpack.config.js 里配置好了对应的加载器）。<br>我们再看看编译前的页面入口文件（index.js）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">require(&apos;../../css/reset.scss&apos;); //加载初始化样式</span><br><span class="line">require(&apos;../../css/allComponent.scss&apos;); //加载组件样式</span><br><span class="line">var React = require(&apos;react&apos;);</span><br><span class="line">var AppWrap = require(&apos;../component/AppWrap&apos;); //加载组件</span><br><span class="line">var createRedux = require(&apos;redux&apos;).createRedux;</span><br><span class="line">var Provider = require(&apos;redux/react&apos;).Provider;</span><br><span class="line">var stores = require(&apos;AppStore&apos;);</span><br><span class="line"></span><br><span class="line">var redux = createRedux(stores);</span><br><span class="line"></span><br><span class="line">var App = React.createClass(&#123;</span><br><span class="line">    render: function() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;Provider redux=&#123;redux&#125;&gt;</span><br><span class="line">                &#123;function() &#123; return &lt;AppWrap /&gt;; &#125;&#125;</span><br><span class="line">            &lt;/Provider&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">React.render(</span><br><span class="line">    &lt;App /&gt;, document.body</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>一切就是这么简单么么哒~ 后续各种有的没的，webpack 都会帮你进行处理。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>至此我们已经基本上手了 webpack 的使用，下面是补充一些有用的技巧。</p><h5 id="一-shimming"><a href="#一-shimming" class="headerlink" title="一. shimming"></a>一. shimming</h5><p>在 AMD/CMD 中，我们需要对不符合规范的模块（比如一些直接返回全局变量的插件）进行 shim 处理，这时候我们需要使用 exports-loader 来帮忙：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; test: require.resolve(&quot;./src/js/tool/swipe.js&quot;),  loader: &quot;exports?swipe&quot;&#125;</span><br></pre></td></tr></table></figure></p><p>之后在脚本中需要引用该模块的时候，这么简单地来使用就可以了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">require(&apos;./tool/swipe.js&apos;);</span><br><span class="line">swipe();</span><br></pre></td></tr></table></figure></p><h5 id="二-自定义公共模块提取"><a href="#二-自定义公共模块提取" class="headerlink" title="二. 自定义公共模块提取"></a>二. 自定义公共模块提取</h5><p>在文章开始我们使用了 CommonsChunkPlugin 插件来提取多个页面之间的公共模块，并将该模块打包为 common.js 。<br>但有时候我们希望能更加个性化一些，我们可以这样配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var CommonsChunkPlugin = require(&quot;webpack/lib/optimize/CommonsChunkPlugin&quot;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        p1: &quot;./page1&quot;,</span><br><span class="line">        p2: &quot;./page2&quot;,</span><br><span class="line">        p3: &quot;./page3&quot;,</span><br><span class="line">        ap1: &quot;./admin/page1&quot;,</span><br><span class="line">        ap2: &quot;./admin/page2&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &quot;[name].js&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new CommonsChunkPlugin(&quot;admin-commons.js&quot;, [&quot;ap1&quot;, &quot;ap2&quot;]),</span><br><span class="line">        new CommonsChunkPlugin(&quot;commons.js&quot;, [&quot;p1&quot;, &quot;p2&quot;, &quot;admin-commons.js&quot;])</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line">// &lt;script&gt;s required:</span><br><span class="line">// page1.html: commons.js, p1.js</span><br><span class="line">// page2.html: commons.js, p2.js</span><br><span class="line">// page3.html: p3.js</span><br><span class="line">// admin-page1.html: commons.js, admin-commons.js, ap1.js</span><br><span class="line">// admin-page2.html: commons.js, admin-commons.js, ap2.js</span><br></pre></td></tr></table></figure></p><h5 id="三-独立打包样式文件"><a href="#三-独立打包样式文件" class="headerlink" title="三. 独立打包样式文件"></a>三. 独立打包样式文件</h5><p>有时候可能希望项目的样式能不要被打包到脚本中，而是独立出来作为.css，然后在页面中以<link>标签引入。这时候我们需要 extract-text-webpack-plugin 来帮忙：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var webpack = require(&apos;webpack&apos;);</span><br><span class="line">    var commonsPlugin = new webpack.optimize.CommonsChunkPlugin(&apos;common.js&apos;);</span><br><span class="line">    var ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);</span><br><span class="line"></span><br><span class="line">    module.exports = &#123;</span><br><span class="line">        plugins: [commonsPlugin, new ExtractTextPlugin(&quot;[name].css&quot;)],</span><br><span class="line">        entry: &#123;</span><br><span class="line">        //...省略其它配置</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>最终 webpack 执行后会乖乖地把样式文件提取出来：</p><h5 id="四-使用CDN-远程文件"><a href="#四-使用CDN-远程文件" class="headerlink" title="四. 使用CDN/远程文件"></a>四. 使用CDN/远程文件</h5><p>有时候我们希望某些模块走CDN并以<script>的形式挂载到页面上来加载，但又希望能在 webpack 的模块中使用上。<br>这时候我们可以在配置文件里使用 externals 属性来帮忙：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    externals: &#123;</span><br><span class="line">        // require(&quot;jquery&quot;) 是引用自外部模块的</span><br><span class="line">        // 对应全局变量 jQuery</span><br><span class="line">        &quot;jquery&quot;: &quot;jQuery&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要留意的是，得确保 CDN 文件必须在 webpack 打包文件引入之前先引入。<br>我们倒也可以使用 script.js 在脚本中来加载我们的模块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var $script = require(&quot;scriptjs&quot;);</span><br><span class="line">$script(&quot;//ajax.googleapis.com/ajax/libs/jquery/2.0.0/jquery.min.js&quot;, function() &#123;</span><br><span class="line">  $(&apos;body&apos;).html(&apos;It works!&apos;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h5 id="五-与-grunt-gulp-配合"><a href="#五-与-grunt-gulp-配合" class="headerlink" title="五. 与 grunt/gulp 配合"></a>五. 与 grunt/gulp 配合</h5><p>以 gulp 为示例，我们可以这样混搭：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(&quot;webpack&quot;, function(callback) &#123;</span><br><span class="line">    // run webpack</span><br><span class="line">    webpack(&#123;</span><br><span class="line">        // configuration</span><br><span class="line">    &#125;, function(err, stats) &#123;</span><br><span class="line">        if(err) throw new gutil.PluginError(&quot;webpack&quot;, err);</span><br><span class="line">        gutil.log(&quot;[webpack]&quot;, stats.toString(&#123;</span><br><span class="line">            // output options</span><br><span class="line">        &#125;));</span><br><span class="line">        callback();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>当然我们只需要把配置写到 webpack({ … }) 中去即可，无须再写 webpack.config.js 了。<br>更多参照信息请参阅：grunt配置 / gulp配置 。</p><h5 id="六-React-相关"><a href="#六-React-相关" class="headerlink" title="六. React 相关"></a>六. React 相关</h5><p>⑴ 推荐使用 npm install react 的形式来安装并引用 React 模块，而不是直接使用编译后的 react.js，这样最终编译出来的 React 部分的脚本会减少 10-20 kb左右的大小。<br>⑵ react-hot-loader 是一款非常好用的 React 热插拔的加载插件，通过它可以实现修改-运行同步的效果，配合 webpack-dev-server 使用更佳！</p></style></p>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目搭建 </tag>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github上的协议知识普及</title>
      <link href="/2019/07/13/IDE/agreement/"/>
      <url>/2019/07/13/IDE/agreement/</url>
      
        <content type="html"><![CDATA[<h1 id="github上的协议知识普及"><a href="#github上的协议知识普及" class="headerlink" title="github上的协议知识普及"></a>github上的协议知识普及</h1><h3 id="选择一分协议的好处"><a href="#选择一分协议的好处" class="headerlink" title="选择一分协议的好处"></a>选择一分协议的好处</h3><blockquote><p>你的作品如果不是定性为全商业性质，可以考虑选择一分流行度比较高的开源协议。具体来说的话，你肯定希望作品能够被多数人分享查阅吧，不但提高自己业界的知名度，同时也方便了需要的人为开源做出了贡献。换句话说，你不分享出来的话你的作品的意义何在呢（当然，自己捣腾的私人东西还是自己保留吧）？可是一旦你把你的代码贴出来，这就表示任何人都可以看到并获取，之后发生的事情你无法控制，有的人或许稍微修改一下放进自己的代码中，有的把你的软件改个名字拿去贩卖，有的甚至会拿去把作者名字改为自己然后拿去找工作什么的，而不会有人知道这个作品的原作者，背后辛勤付出了的人。所以为了公开分享你的代码，同时又让你对代码保留一定权利，在作品中声明一个许可协议是非常有必要的，这是很多新人所忽略的问题，同时很多人在使用别人的劳动成果时也会忽视协议的存在，这样不好。所以你会看到我的博客里面时不时会给出连接指向来源页面，同时文末也会列出所有参考过的文章。我相信我做到了这点，别人在转载我的文章的时候，也可以做到这点，这样营造出来的氛围一定会非常和谐，互相尊重/Show Respect。</p></blockquote><p>多说一句，一个事实让你了解国外开发者在尊重他人劳动成果方面做得是如何的到位，如果A的作品是因为B的作品的启发而来，A甚至都没有使用B任何一句代码，但A会在他的作品里面指明是受到了B的启发”Inspired by XXX link :<a href="http://www.blah.com&quot;。" target="_blank" rel="noopener">http://www.blah.com&quot;。</a></p><p>当然有人会觉得，有了一分协议声明在那里，我就需要鸟你么，我拿来用了把作者名字去掉同时还要加上我的名字，你咬我？！这是后话，只是在利益很小的情况下，或者作者不知情的情况下，作者不会追究什么责任，但如果你的产品做成功了，那就不一定了。另外就是，有协议和没声明协议的裸代码是有非常重要区别的，一般作品当中没声明协议的默认为Copy right的，也就是版权保留。此种情况表明他人没有任何授权，不得复制分发修改使用等等，但一如上面所讨论的，这样的话还何来开源，何来分享呢。有了协议的声明，在未来你的维权上面会方便很多，让你的作品在分享的同时保留了自身的一些权利。</p><h3 id="快速选择"><a href="#快速选择" class="headerlink" title="快速选择"></a>快速选择</h3><blockquote><p>目前流行的开源协议有很多，并且同一款协议有很多变种，比如你或许看到过’ CC Attribution-NoDerivs’,’ CC Attribution-NonCommercial’同属CC协议（后面会有介绍）。如此纷繁的协议该如何选择？协议太宽松会导致作者丧失对作品的很多权利，太严格又不便于使用者使用及作品的传播。所以除了协议多之外，你还要考虑你对作品想保留哪些权利，放开哪些限制。</p></blockquote><p>如果你不想了解太多，只是想要一个简直直接的答案，下面给出的建议或许适合你。下方关于协议的选择及表格来自GitHub choosealicence项目。</p><h4 id="简单宽松的协议"><a href="#简单宽松的协议" class="headerlink" title="简单宽松的协议"></a>简单宽松的协议</h4><blockquote><p>如果你只想要一个简单点的协议不想太麻烦的话。</p></blockquote><p>MIT协议相对宽松但还是抓住了要点的。此协议允许别人以任何方式使用你的代码同时署名原作者，但原作者不承担代码使用后的风险，当然也没有技术支持的义务。jQuery和Rails就是MIT协议。</p><h4 id="代码分享与促进"><a href="#代码分享与促进" class="headerlink" title="代码分享与促进"></a>代码分享与促进</h4><p>如果你在乎作品的传播和别人的修改，希望别人也以相同的协议分享出来。</p><p>GPL（V2或V3）是一种版本自由的协议（可以参照copy right来理解，后者是版本保留，那copyleft便是版权自由，或者无版权，但无版权不代表你可以不遵守软件中声明的协议）。此协议要求代码分发者或者以此代码为基础开发出来的衍生作品需要以同样的协议来发布。此协议的版本3与版本2相近，只是多3中加了条对于不支持修改后代码运行的硬件的限制（没太明白此句话的内涵）。</p><h3 id="各协议授权详情"><a href="#各协议授权详情" class="headerlink" title="各协议授权详情"></a>各协议授权详情</h3><blockquote><p>下面是更多开源协议的一个表格任君选择，总有一款是你的菜。<br>不过先来了解一些下方表格中出现的用词的解释：<br>协议和版权信息(License and copyright notice)：在代码中保留作者提供的协议和版权信息<br>声明变更(State Changes)：在代码中声明对原来代码的重大修改及变更<br>公开源码(Disclose Source)：代码必需公开。如果是基于LGPL协议 下，则只需使用的开源代码公开，不必将整个软件源码公开<br>库引用(Library usage)：该库可以用于商业软件中<br>责任承担(Hold Liable)：代码的作者承担代码使用后的风险及产生的后果<br>商标使用(Use Trademark)：可以使用作者的姓名，作品的Logo，或商标<br>附加协议(Sublicensing)：允许在软件分发传播过程中附加上原来没有的协议条款等</p></blockquote><table><thead><tr><th style="text-align:left">协议</th><th style="text-align:left">描述</th><th style="text-align:left">要求</th><th style="text-align:left">允许</th><th style="text-align:left">禁止</th></tr></thead><tbody><tr><td style="text-align:left">Apache</td><td style="text-align:left">一个较宽松且简明地指出了专利授权的协议。</td><td style="text-align:left">○协议和版权信息<br> ○声明变更</td><td style="text-align:left">○商用<br>○分发<br>○修改<br>○专利授权<br>○私用<br>○附加协议</td><td style="text-align:left">○责任承担（禁止让作者承担责任，可以理解为免责<br>○商标使用</td></tr><tr><td style="text-align:left">GPL</td><td style="text-align:left">此协议是应用最为广泛的开源协议，拥有较强的版权自由( copyleft )要求。衍生代码的分发需开源并且也要遵守此协议。此协议有许多变种，不同变种的要求略有不同</td><td style="text-align:left">○公开源码<br>○协议和版权信息<br>○声明变更</td><td style="text-align:left">○商用<br>○分发<br>○修改<br>○专利授权<br>○私用</td><td style="text-align:left">○责任承担<br>○附加协议</td></tr><tr><td style="text-align:left">MIT</td><td style="text-align:left">宽松简单且精要的一个协议。在适当标明来源及免责的情况下，它允许你对代码进行任何形式的使用</td><td style="text-align:left">○协议和版权信息</td><td style="text-align:left">○商用<br>○分发<br>○修改<br>○私用<br>○附加协议</td><td style="text-align:left">○责任承担</td></tr><tr><td style="text-align:left">Artistic</td><td style="text-align:left">Perl社区尤为钟爱此协议。要求更改后的软件不能影响原软件的使用。</td><td style="text-align:left">○协议和版权信息<br>○声明变更</td><td style="text-align:left">○商用<br>○分发<br>○修改<br>○私用<br>○附加协议</td><td style="text-align:left">○责任承担<br>○商标使用</td></tr><tr><td style="text-align:left">BSD</td><td style="text-align:left">较为宽松的协议，包含两个变种BSD 2-Clause 和BSD3-Clause，两者都与MIT协议只存在细微差异。</td><td style="text-align:left">○协议和版权信息</td><td style="text-align:left">○商用<br>○分发<br>○修改<br>○私用<br>○附加协议</td><td style="text-align:left">○责任承担</td></tr><tr><td style="text-align:left">Eclipse</td><td style="text-align:left">对商用非常友好的一种协议，可以用于软件的商业授权。包含对专利的优雅授权，并且也可以对相关代码应用商业协议。</td><td style="text-align:left">○公开源码<br>○协议和版权信息</td><td style="text-align:left">○商用<br>○分发<br>○修改<br>○专利授权<br>○私用<br>○附加协议</td><td style="text-align:left">○责任承担</td></tr><tr><td style="text-align:left">LGPL</td><td style="text-align:left">主要用于一些代码库。衍生代码可以以此协议发布（言下之意你可以用其他协议），但与此协议相关的代码必需遵循此协议</td><td style="text-align:left">○公开源码<br>○库引用<br>○协议和版权信息</td><td style="text-align:left">○商用<br>○分发<br>○修改<br>○专利授权<br>○私用<br>○附加协议</td><td style="text-align:left">○责任承担</td></tr><tr><td style="text-align:left">Mozilla</td><td style="text-align:left">Mozilla Public License(MPL 2.0)是由Mozilla基金创建维护的。此协议旨在较为宽松的BSD协议和更加互惠的GPL协议中寻找一个折衷点。</td><td style="text-align:left">○公开源码<br>○协议和版权信息</td><td style="text-align:left">○商用<br>○分发<br>○修改<br>○专利授权<br>○私用<br>○附加协议</td><td style="text-align:left">○责任承担<br>○商标使用</td></tr><tr><td style="text-align:left">No license</td><td style="text-align:left">你保留所有权利，不允许他人分发，复制或者创造衍生物。当你将代码发表在一些网站上时需要遵守该网站的协议，此协议可能包含了一些对你劳动成果的授权许可。比如你将代码发布到GitHub，那么你就必需同意别人可以查看和Fork你的代码。</td><td style="text-align:left">○协议和版权信息</td><td style="text-align:left">○商用<br>○私用</td><td style="text-align:left">○分发<br>○修改<br>○附加协议</td></tr><tr><td style="text-align:left">Public domain dedication</td><td style="text-align:left">在许多国家，默认版权归作者自动拥有，所以Unlicense协议提供了一种通用的模板，此协议表明你放弃版权，将劳动成果无私贡献出来。你将丧失对作品的全部权利，包括在MIT/X11中定义的无担保权利。</td><td style="text-align:left">N/A</td><td style="text-align:left">○商用<br>○分发<br>○修改<br>○私用</td><td style="text-align:left">○责任承担</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 辅助知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> 辅助知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-router</title>
      <link href="/2019/07/13/vue/router/"/>
      <url>/2019/07/13/vue/router/</url>
      
        <content type="html"><![CDATA[<h1 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h1><blockquote><p>Vue.js的一大特色就是构建单页面应用十分方便，既然要方便构建单页面应用那么自然少不了路由，vue-router就是vue官方提供的一个路由框架。总体来说，vue-router设计得简单好用，下面就来聊聊我实际用到过的一些方法，文章没有提到的可以去查看官方文档。vue-router的安装这里就不提了，相信会来看这篇博客同学，这些基本能力都是有的。</p></blockquote><p>先上例子<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- html部分，省略head --&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">        &lt;router-link to=&quot;/goods&quot;&gt;商品&lt;/router-link&gt;</span><br><span class="line">        &lt;router-link to=&quot;/ratings&quot;&gt;评论&lt;/router-link&gt;</span><br><span class="line">        &lt;router-link to=&quot;/seller&quot;&gt;商家&lt;/router-link&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script src=&quot;path-to-vue&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;path-to-vue-router&quot;&gt;&lt;/script&gt;</span><br><span class="line">// 首先定义或者引入路由的组件</span><br><span class="line">// 方法一：直接定义路由组件</span><br><span class="line">const goods = &#123; template: &apos;&lt;p&gt;goods&lt;/p&gt;&apos; &#125;;</span><br><span class="line">const ratings = &#123; template: &apos;&lt;p&gt;ratings&lt;/p&gt;&apos; &#125;;</span><br><span class="line">const seller = &#123; template: &apos;&lt;p&gt;seller&lt;/p&gt;&apos; &#125;;</span><br><span class="line">// 方法二：import引入路由组件</span><br><span class="line">import goods from &apos;components/goods/goods&apos;;</span><br><span class="line">import ratings from &apos;components/ratings/ratings&apos;;</span><br><span class="line">import seller from &apos;components/seller/seller&apos;;</span><br><span class="line">// 然后定义路由(routes)，components还可以是Vue.extend()创建的</span><br><span class="line">const routes = [</span><br><span class="line">  &#123; path: &apos;/goods&apos;, component: goods &#125;,</span><br><span class="line">  &#123; path: &apos;/ratings&apos;, component: ratings &#125;,</span><br><span class="line">  &#123; path: &apos;/seller&apos;, component: seller &#125;</span><br><span class="line">];</span><br><span class="line">// 接着创建路由实例</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  // ES6缩写语法，相当于routes:routes</span><br><span class="line">  routes  </span><br><span class="line">&#125;);</span><br><span class="line">// 最后创建vue实例并挂载</span><br><span class="line">const app = new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  router</span><br><span class="line">&#125;);</span><br><span class="line">// 或者</span><br><span class="line">const app = new Vue(&#123;</span><br><span class="line">  router</span><br><span class="line">&#125;).$mount(&apos;#app&apos;)</span><br></pre></td></tr></table></figure></p><p>到这里就可以用vue-router轻松搭建一个单页面应用了。我一般都是使用模块化编程的形式，用.vue单文件，不知道在模块化编程里怎么加载vue-router的可以参考我的某个项目源码。</p><p>router-link和router-view<br>看了上面的例子，一定对router-link和router-view很感兴趣。</p><h3 id="router-link"><a href="#router-link" class="headerlink" title="router-link"></a>router-link</h3><p>从上面例子中的书写形式就可以看出，router-link是一个组件，它默认会被渲染成一个带有链接的a标签，通过to属性指定链接地址。<br>注意：被选中的router-link将自动添加一个class属性值.router-link-active。</p><h5 id="router-link属性配置"><a href="#router-link属性配置" class="headerlink" title="router-link属性配置"></a>router-link属性配置</h5><h5 id="to"><a href="#to" class="headerlink" title="to"></a>to</h5><p>这是一个必须设置的属性，否则路由无法生效。它表示路由的链接，可以是一个字符串也可以是一个描述目标位置的对象。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link to=&quot;goods&quot;&gt;&lt;/router-link&gt;</span><br><span class="line">&lt;router-link to=&quot;&#123;path=&apos;goods&apos;&#125;&quot;&gt;&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></p><h5 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h5><p>一个布尔类型，默认为false。如果replace设置为true，那么导航不会留下history记录，点击浏览器回退按钮不会再回到这个路由。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link to=&quot;goods&quot; replace&gt;&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></p><h5 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h5><p>router-link默认渲染成a标签，也有方法让它渲染成其他标签，tag属性就用来设置router-link渲染成什么标签的。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 渲染成li标签 --&gt;</span><br><span class="line">&lt;router-link to=&quot;goods&quot; tag=&quot;li&quot;&gt;&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></p><h5 id="active-class"><a href="#active-class" class="headerlink" title="active-class"></a>active-class</h5><p>上面说了被选中的router-link将自动添加一个class属性值.router-link-active，这个属性就是来修改这个class值的。</p><h3 id="router-view"><a href="#router-view" class="headerlink" title="router-view"></a>router-view</h3><p>这个组件十分关键，它就是用来渲染匹配到的路由的。<br>可以给router-view组件设置transition过渡，具体用法见Vue2.0 Transition常见用法全解惑。<br>还可以配合<keep-alive>使用，keep-alive可以缓存数据，这样不至于重新渲染路由组件的时候，之前那个路由组件的数据被清除了。比如对当前的路由组件a进行了一些DOM操作之后，点击进入另一个路由组件b，再回到路由组件a的时候之前的DOM操作还保存在，如果不加keep-alive再回到路由组件a时，之前的DOM操作就没有了，得重新进行。如果你的应用里有一个购物车组件，就需要用到keep-alive。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition&gt;</span><br><span class="line">  &lt;keep-alive&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">  &lt;/keep-alive&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure></keep-alive></p><h3 id="一些小需求怎么实现"><a href="#一些小需求怎么实现" class="headerlink" title="一些小需求怎么实现"></a>一些小需求怎么实现</h3><p>不同路由不同页面标题<br>多页面应用我们可以给每一个页面都设置一个不同的标题，但是如果是单页面应用的路由呢？其实也是可以实现的，实现的方法不止一种，我之前用的是结合命名路由和导航钩子函数的方法。如下：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 定义路由的时候如下定义，name也可为中文</span><br><span class="line">const routes = [</span><br><span class="line">  &#123; path: &apos;/goods&apos;, component: goods, name: &apos;goods&apos; &#125;,</span><br><span class="line">  &#123; path: &apos;/ratings&apos;, component: ratings, name: &apos;ratings&apos; &#125;,</span><br><span class="line">  &#123; path: &apos;/seller&apos;, component: seller, name: &apos;seller&apos; &#125;</span><br><span class="line">];</span><br><span class="line">// 创建路由实例</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: routes</span><br><span class="line">&#125;)</span><br><span class="line">// 关键在这里，设置afterEach钩子函数</span><br><span class="line">router.afterEach((to, from, next) =&gt; &#123;</span><br><span class="line">  document.title = to.name;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h3><p>既然用到了命名路由，这里就提一下吧。命名路由就是用一个名称来标识一个路由，在定义路由的时候设置一个name属性即可。在router-link中也可以用路由的名字来链接到一个路由。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to=&quot;&#123; name: &apos;seller&apos;&#125;&quot;&gt;seller&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></p><p>导航钩子<br>这个我还没怎么用过，它主要是用来拦截导航的，想使用的参考官方文档吧。</p><p>怎么刚进入应用就渲染某个路由组件<br>刚进入应用都是进入到“/”这个路由的，如果想直接进入到“/goods”怎么办，这里提供两种方法。一种是利用重定向，另一种是利用vue-router的导航式编程。</p><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const routes = [</span><br><span class="line">  &#123; path: &apos;/&apos;, redirect: &apos;/goods&apos;&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>是不是很简单呢？重定向的目标也可以是一个命名的路由。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const routes = [</span><br><span class="line">  &#123; path: &apos;/&apos;, redirect: &#123; name: &apos;goods&apos; &#125;&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="导航式编程"><a href="#导航式编程" class="headerlink" title="导航式编程"></a>导航式编程</h3><p>利用vue-router的导航式编程的router.push方法也可以实现上面的需求。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 在创建vue实例并挂载后调用</span><br><span class="line">router.push(&apos;/goods&apos;)</span><br></pre></td></tr></table></figure></p><p>router.push方法就是用来动态导航到不同的链接的。它会向history栈添加一个新的记录，点击<router-link :to="...">等同于调用router.push(…)。</router-link></p><p>vue-router中还有router.replace方法和router.go方法，概念及用法可参考<a href="https://router.vuejs.org/zh-cn/" target="_blank" rel="noopener">https://router.vuejs.org/zh-cn</a>。</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue生命周期</title>
      <link href="/2019/07/13/vue/lifecyce/"/>
      <url>/2019/07/13/vue/lifecyce/</url>
      
        <content type="html"><![CDATA[<h1 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h1><h3 id="下面的表格是1-0-版本与2-0-版本的对比"><a href="#下面的表格是1-0-版本与2-0-版本的对比" class="headerlink" title="下面的表格是1.0+版本与2.0+版本的对比"></a>下面的表格是1.0+版本与2.0+版本的对比</h3><table><thead><tr><th>vue1.0+</th><th>vue2.0</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td>init</td><td>beforeCreate</td><td style="text-align:center">组件实例刚被创建，组件属性计算之前，如data属性</td></tr><tr><td>created</td><td>created</td><td style="text-align:center">组件实例创建完成，属性已绑定，但DOM还没生成,$el属性还不存在</td></tr><tr><td>beforeCompile</td><td>beforeMount</td><td style="text-align:center">模板编译/挂载之前</td></tr><tr><td>compiled</td><td>mounted</td><td style="text-align:center">模板编译/挂载之后</td></tr><tr><td>ready</td><td>mounted</td><td style="text-align:center">模板编译/挂载之后</td></tr><tr><td>-</td><td>beforeUpdate</td><td style="text-align:center">组件更新之前</td></tr><tr><td>-</td><td>updated</td><td style="text-align:center">组件更新之后</td></tr><tr><td>-</td><td>activated</td><td style="text-align:center">for keep-alive，组件被激活时调用</td></tr><tr><td>-</td><td>deactivated</td><td style="text-align:center">for keep-alive，组件被移除时调用</td></tr><tr><td>activated</td><td>-</td><td style="text-align:center">不做解释</td></tr><tr><td>detached</td><td>-</td><td style="text-align:center">不做解释</td></tr><tr><td>beforeDestroy</td><td>beforeDestroy</td><td style="text-align:center">组件销毁前调用</td></tr><tr><td>destroyed</td><td>destroyed</td><td style="text-align:center">组件销毁后调用</td></tr></tbody></table><h3 id="用代码说清这些"><a href="#用代码说清这些" class="headerlink" title="用代码说清这些"></a>用代码说清这些</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.jsdelivr.net/vue/2.1.3/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">     &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">  var app = new Vue(&#123;</span><br><span class="line">      el: &apos;#app&apos;,</span><br><span class="line">      data: &#123;</span><br><span class="line">          message : &quot;xuxiao is boy&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">       beforeCreate: function () &#123;</span><br><span class="line">                console.group(&apos;beforeCreate 创建前状态===============》&apos;);</span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot; , &quot;el     : &quot; + this.$el); //undefined</span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data); //undefined</span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message)  </span><br><span class="line">        &#125;,</span><br><span class="line">        created: function () &#123;</span><br><span class="line">            console.group(&apos;created 创建完毕状态===============》&apos;);</span><br><span class="line">            console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el     : &quot; + this.$el); //undefined</span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data); //已被初始化</span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); //已被初始化</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeMount: function () &#123;</span><br><span class="line">            console.group(&apos;beforeMount 挂载前状态===============》&apos;);</span><br><span class="line">            console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el     : &quot; + (this.$el)); //已被初始化</span><br><span class="line">            console.log(this.$el);</span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data); //已被初始化  </span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); //已被初始化  </span><br><span class="line">        &#125;,</span><br><span class="line">        mounted: function () &#123;</span><br><span class="line">            console.group(&apos;mounted 挂载结束状态===============》&apos;);</span><br><span class="line">            console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el     : &quot; + this.$el); //已被初始化</span><br><span class="line">            console.log(this.$el);    </span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data); //已被初始化</span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); //已被初始化</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeUpdate: function () &#123;</span><br><span class="line">            console.group(&apos;beforeUpdate 更新前状态===============》&apos;);</span><br><span class="line">            console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el     : &quot; + this.$el);</span><br><span class="line">            console.log(this.$el);   </span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data);</span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message);</span><br><span class="line">        &#125;,</span><br><span class="line">        updated: function () &#123;</span><br><span class="line">            console.group(&apos;updated 更新完成状态===============》&apos;);</span><br><span class="line">            console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el     : &quot; + this.$el);</span><br><span class="line">            console.log(this.$el);</span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data);</span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message);</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeDestroy: function () &#123;</span><br><span class="line">            console.group(&apos;beforeDestroy 销毁前状态===============》&apos;);</span><br><span class="line">            console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el     : &quot; + this.$el);</span><br><span class="line">            console.log(this.$el);    </span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data);</span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message);</span><br><span class="line">        &#125;,</span><br><span class="line">        destroyed: function () &#123;</span><br><span class="line">            console.group(&apos;destroyed 销毁完成状态===============》&apos;);</span><br><span class="line">            console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el     : &quot; + this.$el);</span><br><span class="line">            console.log(this.$el);  </span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data   : &quot; + this.$data);</span><br><span class="line">               console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="附一张图后面慢慢理解"><a href="#附一张图后面慢慢理解" class="headerlink" title="附一张图后面慢慢理解"></a>附一张图后面慢慢理解</h3><p><img src="./images/lifecyce/lifecyce.png" alt="生命周期"></p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生命周期 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue项目搭建</title>
      <link href="/2019/07/13/vue/start/"/>
      <url>/2019/07/13/vue/start/</url>
      
        <content type="html"><![CDATA[<h3 id="Vue项目搭建"><a href="#Vue项目搭建" class="headerlink" title="Vue项目搭建"></a>Vue项目搭建</h3><p>Vue项目搭建非常简单这里就只说一下命令操作<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 全局安装 vue-cli</span><br><span class="line">$ npm install --global vue-cli</span><br><span class="line"># 创建一个基于 webpack 模板的新项目</span><br><span class="line">$ vue init webpack my-project</span><br><span class="line"># 安装依赖，走你</span><br><span class="line">$ cd my-project</span><br><span class="line">$ npm install</span><br><span class="line">$ npm run dev</span><br></pre></td></tr></table></figure></p><p><a href="https://cn.vuejs.org/v2/guide/installation.html" target="_blank" rel="noopener">Vue项目搭建原文地址</a></p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目搭建 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>chrome扩展开发</title>
      <link href="/2019/07/13/other/chrome/"/>
      <url>/2019/07/13/other/chrome/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在平时的前端开发中chrome的扩展应用是非常常见的我平常应用的chrome扩展程序用Postman、React Developer Tools、Redux DevTools 等使用了这么长时间了扩展就想开发一款属于自己的chrome扩展，下面来介绍一下一个简单的扩展开发。</p></blockquote><h2 id="chrome扩展与chrome应用的区别"><a href="#chrome扩展与chrome应用的区别" class="headerlink" title="chrome扩展与chrome应用的区别"></a>chrome扩展与chrome应用的区别</h2><p>Chrome应用更强调是独立的程序，你可以不打开Chrome浏览器而运行这些程序。同时这些程序可以调用更加底层的系统接口，比如串口、USB、本地文件读写等等。同时Chrome应用可以拥有样式更加自由的独立窗口，而Chrome扩展的界面只能限定在浏览器窗口中。</p><p>Chrome扩展是一系列文件的集合，这些文件包括HTML文件、CSS样式文件、JavaScript脚本文件、图片等静态文件以及manifest.json。个别扩展还会包含二进制文件，如DLL动态库和so动态库等，但这需要调用NPAPI，而Google出于安全性考虑已经决定逐渐淘汰NPAPI</p><h2 id="一个简单的chrome扩展"><a href="#一个简单的chrome扩展" class="headerlink" title="一个简单的chrome扩展"></a>一个简单的chrome扩展</h2><p>新建文件夹 my_chrome 为项目目录<br>开发目录<br>——   images<br>——   js<br>——   css<br>——   index.html<br>——   manifest.json</p><p>项目目录搭建完毕</p><h2 id="manifest-json-文件"><a href="#manifest-json-文件" class="headerlink" title="manifest.json 文件"></a>manifest.json 文件</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;manifest_version&quot;: 2,</span><br><span class="line">    &quot;name&quot;: &quot;my_chrome&quot;,//扩展名称</span><br><span class="line">    &quot;version&quot;: &quot;1.0&quot;,//版本号</span><br><span class="line">    &quot;description&quot;: &quot;我的第一个Chrome扩展&quot;,//项目描述</span><br><span class="line">    &quot;icons&quot;: &#123;  //icons定义了扩展相关图标文件的位置</span><br><span class="line">        &quot;16&quot;: &quot;images/icon.png&quot;,</span><br><span class="line">        &quot;48&quot;: &quot;images/icon.png&quot;,</span><br><span class="line">        &quot;128&quot;: &quot;images/icon.png&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;browser_action&quot;: &#123;</span><br><span class="line">        &quot;default_icon&quot;: &#123; //定义了相应图标文件的位置</span><br><span class="line">            &quot;19&quot;: &quot;images/icon.png&quot;,</span><br><span class="line">            &quot;38&quot;: &quot;images/icon.png&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;default_title&quot;: &quot;我的时钟&quot;,//当用户鼠标悬停于扩展图标上所显示的文字</span><br><span class="line">        &quot;default_popup&quot;: &quot;index.html&quot; //当用户单击扩展图标时所显示页面的文件位置。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="html的代码"><a href="#html的代码" class="headerlink" title="html的代码"></a>html的代码</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            * &#123;</span><br><span class="line">                margin: 0;</span><br><span class="line">                padding: 0;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            body &#123;</span><br><span class="line">                width: 200px;</span><br><span class="line">                height: 100px;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            div &#123;</span><br><span class="line">                line-height: 100px;</span><br><span class="line">                font-size: 42px;</span><br><span class="line">                text-align: center;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div id=&quot;clock_div&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;script src=&quot;js/my_clock.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="js-代码"><a href="#js-代码" class="headerlink" title="js 代码"></a>js 代码</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function my_clock(el)&#123;</span><br><span class="line">    var today=new Date();</span><br><span class="line">    var h=today.getHours();</span><br><span class="line">    var m=today.getMinutes();</span><br><span class="line">    var s=today.getSeconds();</span><br><span class="line">    m=m&gt;=10?m:(&apos;0&apos;+m);</span><br><span class="line">    s=s&gt;=10?s:(&apos;0&apos;+s);</span><br><span class="line">    el.innerHTML = h+&quot;:&quot;+m+&quot;:&quot;+s;</span><br><span class="line">    setTimeout(function()&#123;my_clock(el)&#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var clock_div = document.getElementById(&apos;clock_div&apos;);</span><br><span class="line">my_clock(clock_div);</span><br></pre></td></tr></table></figure><h2 id="扩展导入"><a href="#扩展导入" class="headerlink" title="扩展导入"></a>扩展导入</h2><img src="/2019/07/13/other/chrome/play.png" title="扩展导入"><h2 id="到这了一个简单的chrome扩展就完成了"><a href="#到这了一个简单的chrome扩展就完成了" class="headerlink" title="到这了一个简单的chrome扩展就完成了"></a>到这了一个简单的chrome扩展就完成了</h2>]]></content>
      
      
      <categories>
          
          <category> chrome </category>
          
      </categories>
      
      
        <tags>
            
            <tag> chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js异常处理机制详解</title>
      <link href="/2019/07/13/javaScript/try-catch/"/>
      <url>/2019/07/13/javaScript/try-catch/</url>
      
        <content type="html"><![CDATA[<blockquote><p>​ 从ES3开始，js也提供了类似的异常处理机制，从而让js代码变的更健壮，及时执行的过程中出现了异常，也可以让程序具有了一部分的异常恢复能力。</p></blockquote><h3 id="一、Javascript的异常捕获机制"><a href="#一、Javascript的异常捕获机制" class="headerlink" title="一、Javascript的异常捕获机制"></a>一、Javascript的异常捕获机制</h3><h4 id="1-1-基本的try…catch语句"><a href="#1-1-基本的try…catch语句" class="headerlink" title="1.1 基本的try…catch语句"></a>1.1 基本的try…catch语句</h4><p>ES3开始引入了 try-catch 语句，是 JavaScript 中处理异常的标准方式。</p><p>语法：<br>try{ </p><pre><code>可能发生异常的代码 </code></pre><p>}catch(error){ </p><pre><code>发生错误执行的代码 </code></pre><p>}</p><p>看下面的代码：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    try&#123;</span><br><span class="line">        console.log(b);</span><br><span class="line">        console.log(&quot;我不会输出的，不要找了&quot;)</span><br><span class="line"></span><br><span class="line">    &#125;catch(error)&#123;</span><br><span class="line">        console.log(&quot;发生错误了&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&quot;我try catch后面的代码&quot;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="./images/try-catch/try-catch0.png" alt="控制台："><br><strong> 说明：</strong></p><ol><li><p>把有可能出的问题的代码放在 try语句中。try语句中可以理论上可以写任何的代码，只要有一行代码出现问题，整个程序的执行流程就会立即调到catch语句中执行。</p></li><li><p>一旦try中有一行代码发生异常，则这行出错代码的后面的try中的其他语句都不会再执行。比如上面代码中的console.log(b);这行代码会出错，则立即去执行catch中的代码。所以console.log(“我不会输出的，不要找了”)这行代码则不会再执行</p></li><li><p>在执行catch中的代码之前，js引擎会首先根据错误类型自动创建一个错误，并通过catch后面的参数传递到catch中。不同的浏览器创建的error对象不一样，但是同创他们都包含一个message属性，值是这个错误的一些信息。</p></li><li><p>catch中的代码执行完毕之后，会继续执行后面的代码，程序不会停止下来。</p></li></ol><h4 id="1-2-finally语句"><a href="#1-2-finally语句" class="headerlink" title="1.2 finally语句"></a>1.2 finally语句</h4><p>在 try…catch 中，try 中一旦出现错误则其他语句不能执行，如果不出现错误则 catch 中的语句不会执行。</p><p>Javascript 参考其他编程语言，也提供了一种 finally 语句：不管 try 中的语句有没有错误，在最后都会执行 finally 中的语句。</p><p>即：try 中语句不发生错误执行完毕后会执行 finally 中的语句，try 中的语句发生错误，则执行 catch中的语句，catch 中的语句执行完毕后也会执行 finally 中的语句。</p><p>语法：</p><p>try{</p><p>}catch(error){</p><p>}finally{</p><p>}</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    try&#123;</span><br><span class="line">        console.log(b);</span><br><span class="line">        console.log(&quot;我不会输出的，不要找了&quot;)</span><br><span class="line"></span><br><span class="line">    &#125;catch(error)&#123;</span><br><span class="line">        console.log(&quot;发生错误了&quot;)</span><br><span class="line">    &#125;finally &#123;</span><br><span class="line">        console.log(&quot;不管发生不发生错误，我都会执行&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&quot;我try catch后面的代码&quot;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="./images/try-catch/try-catch1.png" alt="控制台："></p><blockquote><p>所以在 finally 中我们可以放置我们必须要执行的代码。</p></blockquote><p><strong>注意：</strong></p><ol><li>在js中，如果添加了 finally 语句，则 catch 语句可以省略。所以下面的代码也是正确的。</li><li>如果没有 catch 语句，则一旦发生错误就无法捕获这个错误，所以在执行完 finally 中的语句后，程序就会立即停止了。</li><li>所以，在实际使用中，最好一直带着 catch 语句。</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    try&#123;</span><br><span class="line">        console.log(b);</span><br><span class="line">        console.log(&quot;我不会输出的，不要找了&quot;)</span><br><span class="line"></span><br><span class="line">    &#125;finally &#123;</span><br><span class="line">        console.log(&quot;不管发生不发生错误，我都会执行&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&quot;我try catch后面的代码&quot;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="./images/try-catch/try-catch2.png" alt="控制台："></p><h4 id="1-3-合理使用try…catch"><a href="#1-3-合理使用try…catch" class="headerlink" title="1.3 合理使用try…catch"></a>1.3 合理使用try…catch</h4><p>当 try-catch 语句中发生错误时，浏览器会认为错误已经被处理了，浏览器就不再报告错误了。这也是最简单的一种情况。</p><p>​ 使用 try-catch 最适合处理那些我们无法控制的错误。假设你在使用一个大型 JavaScript 库中的 函数，该函数可能会有意无意地抛出一些错误。由于我们不能修改这个库的源代码，所以大可将对该函 数的调用放在 try-catch 语句当中，一有什么错误发生，也好可以恰当地处理它们。</p><p>​ 在明明知道自己的代码会发生错误时，再使用 try-catch 语句就不太合适了。例如，如果 传给函数的参数是字符串而非数值，就会造成函数出错，那么就应该先检查参数的类型，然后再决定 如何去做。在这种情况下，不应用使用 try-catch 语句。因为try…catch语句比较是比较好资源的事情。</p><h3 id="二、throw主动抛出异常"><a href="#二、throw主动抛出异常" class="headerlink" title="二、throw主动抛出异常"></a>二、throw主动抛出异常</h3><h4 id="2-1-抛出js内置错误类型的对象"><a href="#2-1-抛出js内置错误类型的对象" class="headerlink" title="2.1 抛出js内置错误类型的对象"></a>2.1 抛出js内置错误类型的对象</h4><blockquote><p>在大部分的代码执行过程中，都是出现错误的时候，由浏览器(javascript引擎)抛出异常，然后程序或者停止执行，或被try…catch 捕获。</p></blockquote><p>​ 然而有时候我们在检测到一些不合理的情况发生的时候也可以主动抛出错误。</p><p>​ 使用 throw 关键字抛出来主动抛出异常。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    throw new Error(&quot;你好坏&quot;);</span><br><span class="line">    console.log(&quot;执行不到这里的&quot;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="./images/try-catch/try-catch3.png" alt="控制台："><br><strong>注意：</strong></p><ol><li><p>thow后面就是我们要抛出的异常对象。在以前的时候都是出现错误的时候浏览器抛出异常对象，只是现在是我们自己主动抛出的异常对象。</p></li><li><p>只要有异常对象抛出，不管是浏览器抛出的，还是代码主动抛出，都会让程序停止执行。如果想让程序继续执行，则有也可以用try…catch来捕获。</p></li><li><p>每一个错误类型都可以传入一个参数，表示实际的错误信息。</p></li><li><p>我们可以在适当的时候抛出任何我们想抛出的异常类型。throw new SyntaxError(“语法错误…”);</p></li></ol><p>看下面的代码:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    /*该函数接收一个数字，返回他的平方。*/</span><br><span class="line">    function foo(num) &#123;</span><br><span class="line">        if(typeof num == &quot;number&quot;)&#123;</span><br><span class="line">            return num * num;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            throw new TypeError(&quot;类型错误，你应该传入一个数字...&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(foo(33))</span><br><span class="line">    console.log(foo(&quot;abc&quot;))</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="./images/try-catch/try-catch4.png" alt="控制台："></p><h4 id="2-2-抛出自定义类型的错误对象"><a href="#2-2-抛出自定义类型的错误对象" class="headerlink" title="2.2 抛出自定义类型的错误对象"></a>2.2 抛出自定义类型的错误对象</h4><p>我们不仅仅可以抛出js内置的错误类型的对象，也可以自定义错误类型，然后抛出自定义错误类型的对象。</p><p>​ 如果要自定义错误类型，只需要继承任何一个自定义错误类型都可以。一般直接继承Error即可。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    function MyError(message) &#123;</span><br><span class="line">        this.message = &quot;注意：这是自定义的错误&quot;</span><br><span class="line">        this.name = &quot;自定义错误&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    MyError.prototype = new Error();</span><br><span class="line">    try &#123;</span><br><span class="line">        throw new MyError(&quot;注意：这是自定义错误类型&quot;)</span><br><span class="line">    &#125;catch (error)&#123;</span><br><span class="line">        console.log(error.message)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="./images/try-catch/try-catch5.png" alt="控制台："></p>]]></content>
      
      
      <categories>
          
          <category> javaScript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
            <tag> 异常处理 </tag>
            
            <tag> try-catch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>thinkjs项目目录解析</title>
      <link href="/2019/07/13/node/application/"/>
      <url>/2019/07/13/node/application/</url>
      
        <content type="html"><![CDATA[<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><img src="/2019/07/13/node/application/directory.png" title="目录结构"><p>注：指定不同的模式创建的项目目录机构可能有细微的差别，但总体是类似的</p><h3 id="nginx-conf"><a href="#nginx-conf" class="headerlink" title="nginx.conf"></a>nginx.conf</h3><p>nginx 的配置文件，建议线上使用 nginx 做反向代理。</p><h3 id="src"><a href="#src" class="headerlink" title="src"></a>src</h3><p>源代码目录，使用 –es6 参数创建项目才有该目录。项目启动时会自动将 src 目录下的文件编译到 app 目录下。</p><p>如果没有使用 ES6 特性创建项目，则直接有 app/ 目录。</p><h3 id="src-common"><a href="#src-common" class="headerlink" title="src/common"></a>src/common</h3><p>通用模块目录，项目目录都是按模块来划分的，common 模块下存放一些通用的处理逻辑。</p><h3 id="src-common-bootstrap"><a href="#src-common-bootstrap" class="headerlink" title="src/common/bootstrap"></a>src/common/bootstrap</h3><p>项目启动目录，该目录下的文件会自动加载，无需手动 require 。</p><p>可以在这个目录下文件里定义一些全局函数、注册中间件等常用的功能。</p><p>定义全局函数<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// src/common/bootstrap/fn.js global.formatDate = obj =&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里定义了一个全局函数 formatDate，那么项目里任何地方都可以直接使用该函数。</p><p>注册中间件<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// src/common/bootstrap/middleware.js think.middleware(&quot;replace_image&quot;, http =&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这里定义了一个中间件 replace_image，那么就可以在配置文件 hook.js 里将该中间件注册进去了。</p><p>注：bootstrap 只能放在 common 模块里。</p><h3 id="src-common-config"><a href="#src-common-config" class="headerlink" title="src/common/config"></a>src/common/config</h3><p>配置文件，这里放一些通用的配置。</p><p>其中：路由配置、hook 配置、本地化配置等必须放在这里。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;; /**</span><br><span class="line"> * config</span><br><span class="line"> */ export default &#123; //key: value &#125;;</span><br></pre></td></tr></table></figure></p><h3 id="src-common-controller"><a href="#src-common-controller" class="headerlink" title="src/common/controller"></a>src/common/controller</h3><p>控制器，放一些通用的控制器。其中 error.js 里错误处理的不同行为，项目里可以根据需要进行修改。</p><h3 id="src-common-runtime"><a href="#src-common-runtime" class="headerlink" title="src/common/runtime"></a>src/common/runtime</h3><p>项目运行时生成的一些目录，如：缓存文件目录，用户上传的文件临时存放的目录。</p><h3 id="src-home"><a href="#src-home" class="headerlink" title="src/home"></a>src/home</h3><p>home 模块，项目默认模块。可以在 src/common/config/config.js 中修改配置 default_module 来重新定义默认模块。</p><h3 id="src-home-logic"><a href="#src-home-logic" class="headerlink" title="src/home/logic"></a>src/home/logic</h3><p>逻辑处理。每个操作执行前可以先进行逻辑校验，可以包含：参数是否合法、提交的数据是否正常、当前用户是否已经登录、当前用户是否有权限等。这样可以降低 controller 里的 action 的复杂度。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;; /**</span><br><span class="line"> * logic</span><br><span class="line"> * @param  &#123;&#125; []</span><br><span class="line"> * @return &#123;&#125;     []</span><br><span class="line"> */ export default class extends think.logic.base &#123; /**</span><br><span class="line">   * index action logic</span><br><span class="line">   * @return &#123;&#125; []</span><br><span class="line">   */ indexAction()&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="src-home-controller"><a href="#src-home-controller" class="headerlink" title="src/home/controller"></a>src/home/controller</h3><p>控制器。一个 url 对应一个 controller 下的 action。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;; import Base from &quot;./base.js&quot;; export default class extends Base &#123; /**</span><br><span class="line">   * index action</span><br><span class="line">   * @return &#123;Promise&#125; []</span><br><span class="line">   */ indexAction()&#123; //auto render template file index_index.html return this.display();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="src-home-model"><a href="#src-home-model" class="headerlink" title="src/home/model"></a>src/home/model</h3><p>模型。数据库相关操作。</p><h3 id="view"><a href="#view" class="headerlink" title="view"></a>view</h3><p>视图目录，存放对应的模版文件。如果支持国际化和多主题，那么视图目录下需要有对应的子目录。</p><h3 id="www"><a href="#www" class="headerlink" title="www"></a>www</h3><p>项目的可访问根目录，nginx 里的根目录会配置到此目录下。</p><h3 id="www-development-js"><a href="#www-development-js" class="headerlink" title="www/development.js"></a>www/development.js</h3><p>开发模式下项目的入口文件，可以根据项目需要进行修改。www/production.js 为线上的入口文件。</p><p>入口文件的代码类似如下，可以根据项目需要进行修改。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var thinkjs = require(&quot;thinkjs&quot;); var path = require(&quot;path&quot;); var rootPath = path.dirname(__dirname); var instance = new thinkjs(&#123;</span><br><span class="line">  APP_PATH: rootPath + &quot;/app&quot;,</span><br><span class="line">  ROOT_PATH: rootPath,</span><br><span class="line">  RESOURCE_PATH: __dirname,</span><br><span class="line">  env: &quot;development&quot; &#125;);</span><br><span class="line"></span><br><span class="line">instance.compile(&#123;retainLines: true, log: true&#125;);</span><br><span class="line"></span><br><span class="line">instance.run();</span><br></pre></td></tr></table></figure></p><h3 id="www-static"><a href="#www-static" class="headerlink" title="www/static"></a>www/static</h3><p>存放一些静态资源文件。</p>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> 目录结构 </tag>
            
            <tag> thinkjs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义命令行配置</title>
      <link href="/2019/07/13/other/cmd/"/>
      <url>/2019/07/13/other/cmd/</url>
      
        <content type="html"><![CDATA[<p>平常在开发的时候因为项目多集合项目之间频繁切换非常浪费时间，因为启动项目是命令行所以想配置一个自定义命令来快速的进行项目切换和编辑器打开以及启动。</p><h3 id="mac下自定义命令的配置"><a href="#mac下自定义命令的配置" class="headerlink" title="mac下自定义命令的配置"></a>mac下自定义命令的配置</h3><p>在命令行里用 VSCode 打开 .zshrc 文件如图：<br><img src="/2019/07/13/other/cmd/zshrc.jpg" title="mac的path路径文件"></p><p>上图是我自定的自定义命令</p><h3 id="window-下自定义命令"><a href="#window-下自定义命令" class="headerlink" title="window 下自定义命令"></a>window 下自定义命令</h3>]]></content>
      
      
      <categories>
          
          <category> 命令行 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
            <tag> window </tag>
            
            <tag> cmd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nuxt服务端项目集成引入iView</title>
      <link href="/2019/07/13/nuxt/init/"/>
      <url>/2019/07/13/nuxt/init/</url>
      
        <content type="html"><![CDATA[<p>Nuxt.js 是一个基于 Vue.js 的通用应用框架。</p><p>通过对客户端/服务端基础架构的抽象组织，Nuxt.js 主要关注的是应用的 UI渲染。</p><p>我们的目标是创建一个灵活的应用框架，你可以基于它初始化新项目的基础结构代码，或者在已有 Node.js 项目中使用 Nuxt.js。</p><p>Nuxt.js 预设了利用Vue.js开发服务端渲染的应用所需要的各种配置。</p><p>除此之外，我们还提供了一种命令叫：nuxt generate，为基于 Vue.js 的应用提供生成对应的静态站点的功能。</p><p>我们相信这个命令所提供的功能，是向开发集成各种微服务（microservices）的 Web 应用迈开的新一步。</p><p>作为框架，Nuxt.js 为 客户端/服务端 这种典型的应用架构模式提供了许多有用的特性，例如异步数据加载、中间件支持、布局支持等。</p><h2 id="Nuxt-项目–构建"><a href="#Nuxt-项目–构建" class="headerlink" title="Nuxt 项目–构建"></a>Nuxt 项目–构建</h2><p>因为Nuxt是基于vue的通用应用框架所以构建Nuxt项目可以同vue-cil来构建</p><h3 id="1-安装vue-cil"><a href="#1-安装vue-cil" class="headerlink" title="1. 安装vue-cil"></a>1. 安装vue-cil</h3><p>相信有vue使用经验的开发者对这款cil工具是非常熟悉的</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --global vue-cli</span><br></pre></td></tr></table></figure><h3 id="2-用vue-cil搭建项目"><a href="#2-用vue-cil搭建项目" class="headerlink" title="2. 用vue-cil搭建项目"></a>2. 用vue-cil搭建项目</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ vue init nuxt-community/starter-template nuxt </span><br><span class="line">//(你要构建的项目名称我的项目叫做nuxt)</span><br><span class="line">$ cd nuxt</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><h3 id="3-接着通过以下命令启动项目"><a href="#3-接着通过以下命令启动项目" class="headerlink" title="3. 接着通过以下命令启动项目"></a>3. 接着通过以下命令启动项目</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run dev</span><br></pre></td></tr></table></figure><p>访问 <a href="http://localhost:3000" target="_blank" rel="noopener">http://localhost:3000</a><br><img src="/2019/07/13/nuxt/init/init.png" title="启动页"></p><h3 id="集成-iview-UI框架"><a href="#集成-iview-UI框架" class="headerlink" title="集成 iview UI框架"></a>集成 iview UI框架</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 安装 iview</span><br><span class="line">$ npm install iview --save</span><br></pre></td></tr></table></figure><h3 id="在根目录的-plugins-中新建-iview-js"><a href="#在根目录的-plugins-中新建-iview-js" class="headerlink" title="在根目录的 plugins 中新建 iview.js"></a>在根目录的 plugins 中新建 iview.js</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import iView from &apos;iview&apos;</span><br><span class="line">Vue.use(iView)</span><br></pre></td></tr></table></figure><p>这里有个大坑因为Nuxt语法检测机制在Vue.use(iView)的后面要加一个回车要不会报一下错误，这个问题当时让我很郁闷</p><img src="/2019/07/13/nuxt/init/error.png" title="启动页"><h3 id="修改-nuxt-config-js"><a href="#修改-nuxt-config-js" class="headerlink" title="修改 nuxt.config.js"></a>修改 nuxt.config.js</h3><p>在module.exports最后添加如下内容：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plugins: [ &#123; src: &apos;~plugins/iview&apos;, ssr: false &#125; ],</span><br><span class="line">css: [&apos;iview/dist/styles/iview.css&apos;],</span><br></pre></td></tr></table></figure></p><img src="/2019/07/13/nuxt/init/add.png" title="添加"><h3 id="在pages-index-vue-加入-Button-标签"><a href="#在pages-index-vue-加入-Button-标签" class="headerlink" title="在pages/index.vue,加入 Button 标签"></a>在pages/index.vue,加入 Button 标签</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button type=&quot;primary&quot;&gt;Primary&lt;/Button&gt;</span><br></pre></td></tr></table></figure><img src="/2019/07/13/nuxt/init/add.png" title="按钮"><h3 id="再次启动页面"><a href="#再次启动页面" class="headerlink" title="再次启动页面"></a>再次启动页面</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run dev</span><br></pre></td></tr></table></figure><p>效果页面如下：</p><img src="/2019/07/13/nuxt/init/end.png" title="最后的效果"><h3 id="大功告成-后续会添加nuxt的相关内容"><a href="#大功告成-后续会添加nuxt的相关内容" class="headerlink" title="大功告成 后续会添加nuxt的相关内容"></a>大功告成 后续会添加nuxt的相关内容</h3>]]></content>
      
      
      <categories>
          
          <category> nuxt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> nuxt </tag>
            
            <tag> 服务端项目集成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路由实现原理解析</title>
      <link href="/2016/08/25/javaScript/router/"/>
      <url>/2016/08/25/javaScript/router/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/joeyguo/blog/issues/2" target="_blank" rel="noopener">原文地址</a></p><p>在单页应用上，前端路由并不陌生。很多前端框架也会有独立开发或推荐配套使用的路由系统。那么，当我们在谈前端路由的时候，还可以谈些什么？本文将简要分析并实现一个的前端路由，并对 react-router 进行分析。</p><h3 id="一个极简前端路由实现"><a href="#一个极简前端路由实现" class="headerlink" title="一个极简前端路由实现"></a>一个极简前端路由实现</h3><p>说一下前端路由实现的简要原理，以 hash 形式（也可以使用 History API 来处理）为例，当 url 的 hash 发生变化时，触发 hashchange 注册的回调，回调中去进行不同的操作，进行不同的内容的展示。直接看代码或许更直观。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Router() &#123;</span><br><span class="line">    this.routes = &#123;&#125;;</span><br><span class="line">    this.currentUrl = &apos;&apos;;</span><br><span class="line">&#125;</span><br><span class="line">Router.prototype.route = function(path, callback) &#123;</span><br><span class="line">    this.routes[path] = callback || function()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">Router.prototype.refresh = function() &#123;</span><br><span class="line">    this.currentUrl = location.hash.slice(1) || &apos;/&apos;;</span><br><span class="line">    this.routes[this.currentUrl]();</span><br><span class="line">&#125;;</span><br><span class="line">Router.prototype.init = function() &#123;</span><br><span class="line">    window.addEventListener(&apos;load&apos;, this.refresh.bind(this), false);</span><br><span class="line">    window.addEventListener(&apos;hashchange&apos;, this.refresh.bind(this), false);</span><br><span class="line">&#125;</span><br><span class="line">window.Router = new Router();</span><br><span class="line">window.Router.init();</span><br></pre></td></tr></table></figure></p><p>上面路由系统 Router 对象实现，主要提供三个方法<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">init 监听浏览器 url hash 更新事件</span><br><span class="line">route 存储路由更新时的回调到回调数组routes中，回调函数将负责对页面的更新</span><br><span class="line">refresh 执行当前url对应的回调函数，更新页面</span><br><span class="line">Router 调用方式以及呈现效果如下：点击触发 url 的 hash 改变，并对应地更新内容（这里为 body 背景色）</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;#/&quot;&gt;turn white&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;#/blue&quot;&gt;turn blue&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;#/green&quot;&gt;turn green&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">var content = document.querySelector(&apos;body&apos;);</span><br><span class="line">// change Page anything</span><br><span class="line">function changeBgColor(color) &#123;</span><br><span class="line">    content.style.backgroundColor = color;</span><br><span class="line">&#125;</span><br><span class="line">Router.route(&apos;/&apos;, function() &#123;</span><br><span class="line">    changeBgColor(&apos;white&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">Router.route(&apos;/blue&apos;, function() &#123;</span><br><span class="line">    changeBgColor(&apos;blue&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">Router.route(&apos;/green&apos;, function() &#123;</span><br><span class="line">    changeBgColor(&apos;green&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>以上为一个前端路由的简单实现，点击查看完整代码，虽然简单，但实际上很多路由系统的根基都立于此，其他路由系统主要是对自身使用的框架机制的进行配套及优化，如与 react 配套的 react-router。</p><h3 id="react-router-分析"><a href="#react-router-分析" class="headerlink" title="react-router 分析"></a>react-router 分析</h3><p>react-router 与 history 结合形式</p><p>react-router 是基于 history 模块提供的 api 进行开发的，结合的形式本文记为 包装方式。所以在开始对其分析之前，先举一个简单的例子来说明如何进行对象的包装。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// 原对象</span><br><span class="line">var historyModule = &#123;</span><br><span class="line">    listener: [],</span><br><span class="line">    listen: function (listener) &#123;</span><br><span class="line">        this.listener.push(listener);</span><br><span class="line">        console.log(&apos;historyModule listen..&apos;)</span><br><span class="line">    &#125;,</span><br><span class="line">    updateLocation: function()&#123;</span><br><span class="line">        this.listener.forEach(function(listener)&#123;</span><br><span class="line">            listener(&apos;new localtion&apos;);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// Router 将使用 historyModule 对象，并对其包装</span><br><span class="line">var Router = &#123;</span><br><span class="line">    source: &#123;&#125;,</span><br><span class="line">    init: function(source)&#123;</span><br><span class="line">        this.source = source;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 对 historyModule的listen进行了一层包装</span><br><span class="line">    listen: function(listener) &#123;</span><br><span class="line">        return this.source.listen(function(location)&#123;</span><br><span class="line">            console.log(&apos;Router listen tirgger.&apos;);</span><br><span class="line">            listener(location);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 将 historyModule 注入进 Router 中</span><br><span class="line">Router.init(historyModule);</span><br><span class="line">// Router 注册监听</span><br><span class="line">Router.listen(function(location)&#123;</span><br><span class="line">    console.log(location + &apos;-&gt; Router setState.&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">// historyModule 触发回调</span><br><span class="line">historyModule.updateLocation();</span><br><span class="line"></span><br><span class="line">返回：</span><br><span class="line">22</span><br></pre></td></tr></table></figure></p><p>可看到 historyModule 中含有机制：historyModule.updateLocation() -&gt; listener( )，Router 通过对其进行包装开发，针对 historyModule 的机制对 Router 也起到了作用，即historyModule.updateLocation() 将触发 Router.listen 中的回调函数 。点击查看完整代码<br>这种包装形式能够充分利用原对象（historyModule ）的内部机制，减少开发成本，也更好的分离包装函数（Router）的逻辑，减少对原对象的影响。</p><h3 id="react-router-使用方式"><a href="#react-router-使用方式" class="headerlink" title="react-router 使用方式"></a>react-router 使用方式</h3><p>react-router 以 react component 的组件方式提供 API， 包含 Router，Route，Redirect，Link 等等，这样能够充分利用 react component 提供的生命周期特性，同时也让定义路由跟写 react component 达到统一，如下<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">render((</span><br><span class="line">  &lt;Router history=&#123;browserHistory&#125;&gt;</span><br><span class="line">    &lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt;</span><br><span class="line">      &lt;Route path=&quot;about&quot; component=&#123;About&#125;/&gt;</span><br><span class="line">      &lt;Route path=&quot;users&quot; component=&#123;Users&#125;&gt;</span><br><span class="line">        &lt;Route path=&quot;/user/:userId&quot; component=&#123;User&#125;/&gt;</span><br><span class="line">      &lt;/Route&gt;</span><br><span class="line">      &lt;Route path=&quot;*&quot; component=&#123;NoMatch&#125;/&gt;</span><br><span class="line">    &lt;/Route&gt;</span><br><span class="line">  &lt;/Router&gt;</span><br><span class="line">), document.body)</span><br></pre></td></tr></table></figure></p><p>就这样，声明了一份含有 path to component 的各个映射的路由表。<br>react-router 还提供的 Link 组件（如下），作为提供更新 url 的途径，触发 Link 后最终将通过如上面定义的路由表进行匹配，并拿到对应的 component 及 state 进行 render 渲染页面。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=&#123;`/user/89757`&#125;&gt;&apos;joey&apos;&lt;/Link&gt;</span><br></pre></td></tr></table></figure></p><p>这里不细讲 react-router 的使用，详情可见：<a href="https://github.com/reactjs/react-router" target="_blank" rel="noopener">https://github.com/reactjs/react-router</a></p><p>从点击 Link 到 render 对应 component ，路由中发生了什么</p><p>为何能够触发 render component ？</p><p>主要是因为触发了 react setState 的方法从而能够触发 render component。<br>从顶层组件 Router 出发（下面代码从 react-router/Router 中摘取），可看到 Router 在 react component 生命周期之组件被挂载前 componentWillMount 中使用 this.history.listen 去注册了 url 更新的回调函数。回调函数将在 url 更新时触发，回调中的 setState 起到 render 了新的 component 的作用。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Router.prototype.componentWillMount = function componentWillMount() &#123;</span><br><span class="line">    // .. 省略其他</span><br><span class="line">    var createHistory = this.props.history;</span><br><span class="line"></span><br><span class="line">    this.history = _useRoutes2[&apos;default&apos;](createHistory)(&#123;</span><br><span class="line">      routes: _RouteUtils.createRoutes(routes || children),</span><br><span class="line">      parseQueryString: parseQueryString,</span><br><span class="line">      stringifyQuery: stringifyQuery</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    this._unlisten = this.history.listen(function (error, state) &#123;</span><br><span class="line">        _this.setState(state, _this.props.onUpdate);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p><p>上面的 _useRoutes2 对 history 操作便是对其做一层包装，所以调用的 this.history 实际为包装以后的对象，该对象含有 _useRoutes2 中的 listen 方法，如下<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function listen(listener) &#123;</span><br><span class="line">      return history.listen(function (location) &#123;</span><br><span class="line">          // .. 省略其他</span><br><span class="line">          match(location, function (error, redirectLocation, nextState) &#123;</span><br><span class="line">            listener(null, nextState);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可看到，上面代码中，主要分为两部分</p><p>使用了 history 模块的 listen 注册了一个含有 setState 的回调函数（这样就能使用 history 模块中的机制）<br>回调中的 match 方法为 react-router 所特有，match 函数根据当前 location 以及前面写的 Route 路由表匹配出对应的路由子集得到新的路由状态值 state，具体实现可见 react-router/matchRoutes ，再根据 state 得到对应的 component ，最终执行了 match 中的回调 listener(null, nextState) ，即执行了 Router 中的监听回调（setState），从而更新了展示。<br>以上，为起始注册的监听，及回调的作用。</p><p>如何触发监听的回调函数的执行？</p><p>这里还得从如何更新 url 说起。一般来说，url 更新主要有两种方式：简单的 hash 更新或使用 history api 进行地址更新。在 react-router 中，其提供了 Link 组件，该组件能在 render 中使用，最终会表现为 a 标签，并将 Link 中的各个参数组合放它的 href 属性中。可以从 react-router/ Link 中看到，对该组件的点击事件进行了阻止了浏览器的默认跳转行为，而改用 history 模块的 pushState 方法去触发 url 更新。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Link.prototype.render = function render() &#123;</span><br><span class="line">    // .. 省略其他</span><br><span class="line">    props.onClick = function (e) &#123;</span><br><span class="line">      return _this.handleClick(e);</span><br><span class="line">    &#125;;</span><br><span class="line">    if (history) &#123;</span><br><span class="line">     // .. 省略其他</span><br><span class="line">      props.href = history.createHref(to, query);</span><br><span class="line">    &#125;</span><br><span class="line">    return _react2[&apos;default&apos;].createElement(&apos;a&apos;, props);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Link.prototype.handleClick = function handleClick(event) &#123;</span><br><span class="line">    // .. 省略其他</span><br><span class="line">    event.preventDefault();</span><br><span class="line">    this.context.history.pushState(this.props.state, this.props.to, this.props.query);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>对 history 模块的 pushState 方法对 url 的更新形式，同样分为两种，分别在 history/createBrowserHistory 及 history/createHashHistory 各自的 finishTransition 中，如 history/createBrowserHistory 中使用的是 window.history.replaceState(historyState, null, path); 而 history/createHashHistory 则使用 window.location.hash = url，调用哪个是根据我们一开始创建 history 的方式。</p><p>更新 url 的显示是一部分，另一部分是根据 url 去更新展示，也就是触发前面的监听。这是在前面 finishTransition 更新 url 之后实现的，调用的是 history/createHistory 中的 updateLocation 方法，changeListeners 中为 history/createHistory 中的 listen 中所添加的，如下<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function updateLocation(newLocation) &#123;</span><br><span class="line">   // 示意代码</span><br><span class="line">    location = newLocation;</span><br><span class="line">    changeListeners.forEach(function (listener) &#123;</span><br><span class="line">      listener(location);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">function listen(listener) &#123;</span><br><span class="line">     // 示意代码</span><br><span class="line">    changeListeners.push(listener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>###总结</p><p>可以将以上 react-router 的整个包装闭环总结为</p><p>回调函数：含有能够更新 react UI 的 react setState 方法。<br>注册回调：在 Router componentWillMount 中使用 history.listen 注册的回调函数，最终放在 history 模块的 回调函数数组 changeListeners 中。<br>触发回调：Link 点击触发 history 中回调函数数组 changeListeners 的执行，从而触发原来 listen 中的 setState 方法，更新了页面<br>至于前进与后退的实现，是通过监听 popstate 以及 hashchange 的事件，当前进或后退 url 更新时，触发这两个事件的回调函数，回调的执行方式 Link 大致相同，最终同样更新了 UI ，这里就不再说明。</p><p>react-router 主要是利用底层 history 模块的机制，通过结合 react 的架构机制做一层包装，实际自身的内容并不多，但其包装的思想笔者认为很值得学习，有兴趣的建议阅读下源码，相信会有其他收获。</p>]]></content>
      
      
      <categories>
          
          <category> javaScript原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS省略号实现</title>
      <link href="/2016/08/25/CSS/ellipsis/"/>
      <url>/2016/08/25/CSS/ellipsis/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS实现单行多行添加省略号"><a href="#CSS实现单行多行添加省略号" class="headerlink" title="CSS实现单行多行添加省略号"></a>CSS实现单行多行添加省略号</h1><p>先介绍一下单行文本添加省略号的css代码</p><p>以下代码实现的效果为下图<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">overflow: hidden;</span><br><span class="line">text-overflow:ellipsis;</span><br><span class="line">white-space: nowrap;</span><br></pre></td></tr></table></figure></p><img src="/2016/08/25/CSS/ellipsis/ellipsis1.png" title="单行省略"><p>先介绍一下多行文本添加省略号的css代码</p><p>以下代码实现的效果为下图<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">display: -webkit-box;</span><br><span class="line">-webkit-box-orient: vertical;</span><br><span class="line">-webkit-line-clamp: 3;</span><br><span class="line">overflow: hidden;</span><br></pre></td></tr></table></figure></p><img src="/2016/08/25/CSS/ellipsis/ellipsis2.png" title="多行省略"><p>先介绍一下多行文本添加省略号的css代码的优化</p><p>以下代码实现的效果为下图<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">div&#123;position: relative; line-height: 20px; max-height: 40px;overflow: hidden;&#125;</span><br><span class="line">div::after&#123;content: &quot;...&quot;; position: absolute; bottom: 0; right: 0; padding-left: 40px;</span><br><span class="line">background: -webkit-linear-gradient(left, transparent, #fff 55%);</span><br><span class="line">background: -o-linear-gradient(right, transparent, #fff 55%);</span><br><span class="line">background: -moz-linear-gradient(right, transparent, #fff 55%);</span><br><span class="line">background: linear-gradient(to right, transparent, #fff 55%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> css应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> clamp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你不知道的js（上）</title>
      <link href="/2016/08/25/javaScript/you-dont-know-js/"/>
      <url>/2016/08/25/javaScript/you-dont-know-js/</url>
      
        <content type="html"><![CDATA[<h3 id="LHS与RHS"><a href="#LHS与RHS" class="headerlink" title="LHS与RHS"></a>LHS与RHS</h3><blockquote><p>LHS可以理解为某变量被赋值，RHS可以理解为被调用</p></blockquote><h5 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function foo(a)&#123;</span><br><span class="line">  console.log(a); //2</span><br><span class="line">&#125;</span><br><span class="line">foo(2)</span><br></pre></td></tr></table></figure><blockquote><p>foo进行RHS  foo的形参相当于a=2  所以a进行LHS  console是RHS  console里的a是RHS</p></blockquote><h3 id="理解作用于"><a href="#理解作用于" class="headerlink" title="理解作用于"></a>理解作用于</h3><h5 id="作用于嵌套"><a href="#作用于嵌套" class="headerlink" title="作用于嵌套"></a>作用于嵌套</h5><blockquote><p>现在当前作用于找某变量，找不到时引擎会向外层嵌套的作用于中继续寻找，直到找到该变量，或抵达最外层的作用域（也就是全局作用于）为止。</p></blockquote><h5 id="注意一下代码"><a href="#注意一下代码" class="headerlink" title="注意一下代码"></a>注意一下代码</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo (a)&#123;</span><br><span class="line">  console.log(a + b);  //4</span><br><span class="line">&#125;</span><br><span class="line">var b = 2;</span><br><span class="line">foo(2);</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function foo (a)&#123;</span><br><span class="line">  console.log(a + b);  //NaN</span><br><span class="line">&#125;</span><br><span class="line">foo(2);</span><br><span class="line">var b = 2;</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo (a)&#123;</span><br><span class="line">  console.log(a + b); //NaN</span><br><span class="line">  var b = 2</span><br><span class="line">&#125;</span><br><span class="line">foo(2);</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo (a)&#123;</span><br><span class="line">  console.log(a + b); //ReferenceError: b is not defined</span><br><span class="line">  b = 2</span><br><span class="line">&#125;</span><br><span class="line">foo(2);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javaScript阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>滚到底部加载</title>
      <link href="/2016/08/25/javaScript/to-bottom/"/>
      <url>/2016/08/25/javaScript/to-bottom/</url>
      
        <content type="html"><![CDATA[<blockquote><p>其实这个功能的实现就是监听滚动条是否滚动到底部，如果滚动到底部则向后后台获取数据废话不多说上代码</p></blockquote><p>浏览器视口的高度<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">getWindowHeight = () =&gt; &#123;</span><br><span class="line">　　var windowHeight = 0;</span><br><span class="line">　　if(document.compatMode == &quot;CSS1Compat&quot;)&#123;</span><br><span class="line">　　　　windowHeight = document.documentElement.clientHeight;</span><br><span class="line">　　&#125;else&#123;</span><br><span class="line">　　　　windowHeight = document.body.clientHeight;</span><br><span class="line">　　&#125;</span><br><span class="line">　　return windowHeight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>文档的总高度<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">getScrollHeight = () =&gt; &#123;</span><br><span class="line">　　var scrollHeight = 0, bodyScrollHeight = 0, documentScrollHeight = 0;</span><br><span class="line">　　if(document.body)&#123;</span><br><span class="line">　　　　bodyScrollHeight = document.body.scrollHeight;</span><br><span class="line">　　&#125;</span><br><span class="line">　　if(document.documentElement)&#123;</span><br><span class="line">　　　　documentScrollHeight = document.documentElement.scrollHeight;</span><br><span class="line">　　&#125;</span><br><span class="line">　　scrollHeight = (bodyScrollHeight - documentScrollHeight &gt; 0) ? bodyScrollHeight : documentScrollHeight;</span><br><span class="line">　　return scrollHeight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>滚动条在Y轴上的滚动距离<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">getScrollTop = () =&gt; &#123;</span><br><span class="line">　　var scrollTop = 0, bodyScrollTop = 0, documentScrollTop = 0;</span><br><span class="line">　　if(document.body)&#123;</span><br><span class="line">　　　　bodyScrollTop = document.body.scrollTop;</span><br><span class="line">　　&#125;</span><br><span class="line">　　if(document.documentElement)&#123;</span><br><span class="line">　　　　documentScrollTop = document.documentElement.scrollTop;</span><br><span class="line">　　&#125;</span><br><span class="line">　　scrollTop = (bodyScrollTop - documentScrollTop &gt; 0) ? bodyScrollTop : documentScrollTop;</span><br><span class="line">　　return scrollTop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么剩下的就是在js里边进行判断这里主要说在react里的用法<br>这里把所有的操作写在一个方法里<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">onScrollListener = () =&gt;&#123;</span><br><span class="line">  if(getScrollTop() + getWindowHeight() == getScrollHeight())&#123;</span><br><span class="line">    alert(&quot;滚动条已经滚动到了底部&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在react的componentDidMount生命周期里写一下代码<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount()&#123;</span><br><span class="line">//滚轮监听</span><br><span class="line">addEventListener(&quot;scroll&quot;,this.onscrollListener,false)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在react的componentWillUnmount生命周期里写一下代码(注册事件要在组件销毁以后注销这样可以提高性能)</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">componentWillUnmount()&#123;</span><br><span class="line">window.removeEventListener(&quot;scroll&quot;,this.onscrollListener)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javaScript应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 上拉加载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型到原型链</title>
      <link href="/2016/08/25/javaScript/prototype/"/>
      <url>/2016/08/25/javaScript/prototype/</url>
      
        <content type="html"><![CDATA[<h3 id="构造函数创建对象"><a href="#构造函数创建对象" class="headerlink" title="构造函数创建对象"></a>构造函数创建对象</h3><p>我们先使用构造函数创建一个对象：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var person = new Person();</span><br><span class="line">person.name = &apos;Kevin&apos;;</span><br><span class="line">console.log(person.name) // Kevin</span><br></pre></td></tr></table></figure></p><p>在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。</p><p>很简单吧，接下来进入正题：</p><ul><li>prototype</li></ul><p>每个函数都有一个 prototype 属性，就是我们经常在各种例子中看到的那个 prototype ，比如：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 虽然写在注释里，但是你要注意：</span><br><span class="line">// prototype是函数才会有的属性</span><br><span class="line">Person.prototype.name = &apos;Kevin&apos;;</span><br><span class="line">var person1 = new Person();</span><br><span class="line">var person2 = new Person();</span><br><span class="line">console.log(person1.name) // Kevin</span><br><span class="line">console.log(person2.name) // Kevin</span><br></pre></td></tr></table></figure><p>那这个函数的 prototype 属性到底指向的是什么呢？是这个函数的原型吗？</p><p>其实，函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是这个例子中的 person1 和 person2 的原型。</p><p>那什么是原型呢？你可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。</p><p>让我们用一张图表示构造函数和实例原型之间的关系：<br><img src="/2016/08/25/javaScript/prototype/prototype.png" title="让我们用一张图表示构造函数和实例原型之间的关系"></p><p>在这张图中我们用 Object.prototype 表示实例原型。</p><p>那么我们该怎么表示实例与实例原型，也就是 person 和 Person.prototype 之间的关系呢，这时候我们就要讲到第二个属性：</p><ul><li><strong>proto</strong></li></ul><p>这是每一个JavaScript对象(除了 null )都具有的一个属性，叫<strong>proto</strong>，这个属性会指向该对象的原型。</p><p>为了证明这一点,我们可以在火狐或者谷歌中输入：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var person = new Person();</span><br><span class="line">console.log(person.__proto__ === Person.prototype); // true</span><br></pre></td></tr></table></figure></p><p>于是我们更新下关系图：<br><img src="/2016/08/25/javaScript/prototype/proto.png" title="于是我们更新下关系图"></p><p>既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？</p><ul><li>constructor</li></ul><p>指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：constructor﻿，每个原型都有一个 constructor 属性指向关联的构造函数。</p><p>为了验证这一点，我们可以尝试：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">console.log(Person === Person.prototype.constructor); // true</span><br></pre></td></tr></table></figure></p><p>所以再更新下关系图：<br><img src="/2016/08/25/javaScript/prototype/constructor.png" title="于是我们更新下关系图"></p><p>综上我们已经得出：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person();</span><br><span class="line"></span><br><span class="line">console.log(person.__proto__ == Person.prototype) // true</span><br><span class="line">console.log(Person.prototype.constructor == Person) // true</span><br><span class="line">// 顺便学习一个ES5的方法,可以获得对象的原型</span><br><span class="line">console.log(Object.getPrototypeOf(person) === Person.prototype) // true</span><br></pre></td></tr></table></figure></p><p>了解了构造函数、实例原型、和实例之间的关系，接下来我们讲讲实例和原型的关系：</p><p>实例与原型<br>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。</p><p>举个例子：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = &apos;Kevin&apos;;</span><br><span class="line"></span><br><span class="line">var person = new Person();</span><br><span class="line"></span><br><span class="line">person.name = &apos;Daisy&apos;;</span><br><span class="line">console.log(person.name) // Daisy</span><br><span class="line"></span><br><span class="line">delete person.name;</span><br><span class="line">console.log(person.name) // Kevin</span><br><span class="line">在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。</span><br><span class="line"></span><br><span class="line">但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.__proto__ ，也就是 Person.prototype中查找，幸运的是我们找到了 name 属性，结果为 Kevin。</span><br></pre></td></tr></table></figure></p><p>但是万一还没有找到呢？原型的原型又是什么呢？</p><p>原型的原型<br>在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = new Object();</span><br><span class="line">obj.name = &apos;Kevin&apos;</span><br><span class="line">console.log(obj.name) // Kevin</span><br></pre></td></tr></table></figure></p><p>所以原型对象是通过 Object 构造函数生成的，结合之前所讲，实例的 <strong>proto</strong> 指向构造函数的 prototype ，所以我们再更新下关系图：<br><img src="/2016/08/25/javaScript/prototype/obj.png" title="于是我们更新下关系图"></p><p>原型链<br>那 Object.prototype 的原型呢？</p><p>null，不信我们可以打印：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.prototype.__proto__ === null) // true</span><br></pre></td></tr></table></figure></p><p>所以查到属性的时候查到 Object.prototype 就可以停止查找了。</p><p>所以最后一张关系图就是<br><img src="/2016/08/25/javaScript/prototype/objEnd.png" title="于是我们更新下关系图"></p><p>顺便还要说一下，图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。</p><p>补充<br>最后，补充三点大家可能不会注意的地方：</p><p>constructor</p><p>首先是 constructor 属性，我们看个例子：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var person = new Person();</span><br><span class="line">console.log(person.constructor === Person); // true</span><br></pre></td></tr></table></figure></p><p>当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person.constructor === Person.prototype.constructor</span><br></pre></td></tr></table></figure></p><p><strong>proto</strong></p><p>其次是 <strong>proto</strong> ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.<strong>proto</strong> 时，可以理解成返回了<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.getPrototypeOf(obj)。</span><br></pre></td></tr></table></figure></p><p>真的是继承吗？<br>最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是：</p><blockquote><p>继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> javaScript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> prototype </tag>
            
            <tag> 原型链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式 - 语法</title>
      <link href="/2016/08/25/javaScript/regular-expression/"/>
      <url>/2016/08/25/javaScript/regular-expression/</url>
      
        <content type="html"><![CDATA[<h3 id="正则表达式-语法"><a href="#正则表达式-语法" class="headerlink" title="正则表达式 - 语法"></a>正则表达式 - 语法</h3><p><a href="http://www.runoob.com/regexp/regexp-syntax.html" target="_blank" rel="noopener">正则表达式 - 语法</a></p>]]></content>
      
      
      <categories>
          
          <category> javaScript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javasript </tag>
            
            <tag> 正则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取鼠标的位置</title>
      <link href="/2016/08/25/javaScript/mouse/"/>
      <url>/2016/08/25/javaScript/mouse/</url>
      
        <content type="html"><![CDATA[<h3 id="获取鼠标的位置"><a href="#获取鼠标的位置" class="headerlink" title="获取鼠标的位置"></a>获取鼠标的位置</h3><h4 id="获取鼠标的位置可以分为多个情况"><a href="#获取鼠标的位置可以分为多个情况" class="headerlink" title="获取鼠标的位置可以分为多个情况"></a>获取鼠标的位置可以分为多个情况</h4><ol><li><p>获取鼠标相对于浏览器窗口的位置</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let x = event.clientX;</span><br><span class="line">let y = event.clientY;</span><br></pre></td></tr></table></figure></li><li><p>获取鼠标相对于整个页面的位置</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let x = event.pageX;</span><br><span class="line">let y = event.pageY;</span><br></pre></td></tr></table></figure></li><li><p>获取鼠标相对点击元素的位置</p><p>这一个获取有点难度，因为在JavaScript原生方法中没有这个方法，那么需要分析如何获取，突破点一获取点击元素的相对其父本元素的偏移量这个属性在event的target属性下边绑定可以循环的方法获取点击元素相对于页面的位置方法如下</p></li></ol>  <figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  /*</span><br><span class="line">  *该方法是获取点击元素相对于页面的距离</span><br><span class="line">  *传入的参数为event.target</span><br><span class="line">  */</span><br><span class="line">  function getOffset(obj)&#123;</span><br><span class="line">   var tmp=&#123;</span><br><span class="line">      val:obj.offsetParent, //获取点击元素的父本</span><br><span class="line">      x:obj.offsetLeft, //获取点击元素的相对于父本的水平偏移</span><br><span class="line">      y:obj.offsetTop, //获取点击元素的相对于父本的垂直偏移</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   while(tmp.val != null)&#123; //当父级不存在是停止循环</span><br><span class="line">    tmp.x += tmp.val.offsetLeft; //水平偏移量累计</span><br><span class="line">    tmp.y += tmp.val.offsetTop; //垂直偏移量累计</span><br><span class="line">    tmp.val = tmp.val.offsetParent; //获取父本</span><br><span class="line">   &#125;</span><br><span class="line">   return tmp; //返回点击元素相对于页面的偏移值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上函数是获取了点击元素相对于页面的水平和垂直偏移，依赖以上获得的值，只需要鼠标相对于页面的偏移减去点击元素相对于页面的偏移方法如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">*该方法是获取鼠标相对于点击元素的位移</span><br><span class="line">*传入的参数为event</span><br><span class="line">*/</span><br><span class="line">function getCurrent(elem)&#123;</span><br><span class="line">  let off = getOffset(elem.target); //获取元素相对于页面的位置</span><br><span class="line">  let tmp = &#123;&#125;;</span><br><span class="line">  return tmp = &#123;</span><br><span class="line">    x:elem.pageX - off.x,</span><br><span class="line">    y:elem.pageY - off.y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.getBoundingClientRect用于获取某个html元素相对于页面的位置集合<br>执行 object.getBoundingClientRect();会得到元素的top、right、bottom、left、width、height属性，这些属性以一个对象的方式返回。</p><p>主要是left和bottom要解释一下，left是指右边到页面最左边的距离，bottom是指底边到页面顶边的距离。</p><h6 id="ie5以上都能支持，但是又一点点地方需要修正一下，IE67的left、top会少2px-并且没有width、height属性。"><a href="#ie5以上都能支持，但是又一点点地方需要修正一下，IE67的left、top会少2px-并且没有width、height属性。" class="headerlink" title="(ie5以上都能支持，但是又一点点地方需要修正一下，IE67的left、top会少2px,并且没有width、height属性。)"></a>(ie5以上都能支持，但是又一点点地方需要修正一下，IE67的left、top会少2px,并且没有width、height属性。)</h6><p><img src="http://www.51xuediannao.com/uploads/allimg/160811/2340295W5-0.jpg?_=6179964" alt="图解"></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;test&quot; style=&quot;width: 100px; height: 100px; background: #ddd;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    function getObjXy(obj)&#123;</span><br><span class="line">        var xy = obj.getBoundingClientRect();</span><br><span class="line">        var top = xy.top-document.documentElement.clientTop+document.documentElement.scrollTop,//document.documentElement.clientTop 在IE67中始终为2，其他高级点的浏览器为0</span><br><span class="line">            bottom = xy.bottom,</span><br><span class="line">            left = xy.left-document.documentElement.clientLeft+document.documentElement.scrollLeft,//document.documentElement.clientLeft 在IE67中始终为2，其他高级点的浏览器为0</span><br><span class="line">            right = xy.right,</span><br><span class="line">            width = xy.width||right - left, //IE67不存在width 使用right - left获得</span><br><span class="line">            height = xy.height||bottom - top;</span><br><span class="line"></span><br><span class="line">        return &#123;</span><br><span class="line">            top:top,</span><br><span class="line">            right:right,</span><br><span class="line">            bottom:bottom,</span><br><span class="line">            left:left,</span><br><span class="line">            width:width,</span><br><span class="line">            height:height</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var test = getObjXy(document.getElementById(&apos;test&apos;));</span><br><span class="line">    alert(&quot;top:&quot; + test.top + &quot;, right:&quot; + test.right + &quot;, bottom:&quot; + test.bottom + &quot;, left:&quot; + test.left);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>以上就是常用的获取鼠标位置的方法</p>]]></content>
      
      
      <categories>
          
          <category> javaScript应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 鼠标相关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS常见布局解决方案</title>
      <link href="/2016/08/25/CSS/layout/"/>
      <url>/2016/08/25/CSS/layout/</url>
      
        <content type="html"><![CDATA[<h3 id="水平居中布局"><a href="#水平居中布局" class="headerlink" title="水平居中布局"></a>水平居中布局</h3><hr><h5 id="1-margin-定宽"><a href="#1-margin-定宽" class="headerlink" title="1.margin + 定宽"></a>1.margin + 定宽</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .child &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h5 id="2-table-margin"><a href="#2-table-margin" class="headerlink" title="2. table + margin"></a>2. table + margin</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .child &#123;</span><br><span class="line">    display: table;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>display: table 在表现上类似 block 元素，但是宽度为内容宽。</p><ul><li>无需设置父元素样式 （支持 IE 8 及其以上版本）兼容 IE 8 一下版本需要调整为 table</li></ul><h5 id="3-inline-block-text-align"><a href="#3-inline-block-text-align" class="headerlink" title="3.inline-block + text-align"></a>3.inline-block + text-align</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .child &#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">  &#125;</span><br><span class="line">  .parent &#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ul><li>兼容性佳（甚至可以兼容 IE 6 和 IE 7）<h5 id="4-absolute-margin-left"><a href="#4-absolute-margin-left" class="headerlink" title="4.absolute + margin-left"></a>4.absolute + margin-left</h5></li></ul><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.parent &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">  &#125;</span><br><span class="line">  .child &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 50%;</span><br><span class="line">    width: 100px;</span><br><span class="line">    margin-left: -50px;  /* width/2 */</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ul><li>宽度固定</li><li>相比于使用transform ，有兼容性更好</li></ul><h5 id="5-absolute-transform"><a href="#5-absolute-transform" class="headerlink" title="5. absolute + transform"></a>5. absolute + transform</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .parent &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">  &#125;</span><br><span class="line">  .child &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 50%;</span><br><span class="line">    transform: translateX(-50%);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ul><li>绝对定位脱离文档流，不会对后续元素的布局造成影响。</li><li>transform 为 CSS3 属性，有兼容性问题</li></ul><h5 id="6-flex-justify-content"><a href="#6-flex-justify-content" class="headerlink" title="6. flex + justify-content"></a>6. flex + justify-content</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .parent &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: center;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ul><li>只需设置父节点属性，无需设置子元素</li><li>flex有兼容性问题</li></ul><h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><hr><h5 id="1-table-cell-vertical-align"><a href="#1-table-cell-vertical-align" class="headerlink" title="1.table-cell + vertical-align"></a>1.table-cell + vertical-align</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .parent &#123;</span><br><span class="line">    display: table-cell;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ul><li>兼容性好(IE 8以下版本需要调整页面结构至 table</li></ul><h5 id="2-absolute-transform"><a href="#2-absolute-transform" class="headerlink" title="2.absolute + transform"></a>2.absolute + transform</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .parent &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">  &#125;</span><br><span class="line">  .child &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 50%;</span><br><span class="line">    transform: translateY(-50%);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ul><li>绝对定位脱离文档流，不会对后续元素的布局造成影响。但如果绝对定位元素是唯一的元素则父元素也会失去高度。</li><li>transform 为 CSS3 属性，有兼容性问题</li></ul><h5 id="3-flex-align-items"><a href="#3-flex-align-items" class="headerlink" title="3.flex + align-items"></a>3.flex + align-items</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .parent &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    align-items: center;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h3><hr><h5 id="1-absolute-transform"><a href="#1-absolute-transform" class="headerlink" title="1. absolute + transform"></a>1. absolute + transform</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .parent &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">  &#125;</span><br><span class="line">  .child &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 50%;</span><br><span class="line">    top: 50%;</span><br><span class="line">    transform: translate(-50%, -50%);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ul><li>绝对定位脱离文档流，不会对后续元素的布局造成影响。</li><li>transform 为 CSS3 属性，有兼容性问题</li></ul><h5 id="2-inline-block-text-align-table-cell-vertical-align"><a href="#2-inline-block-text-align-table-cell-vertical-align" class="headerlink" title="2. inline-block + text-align + table-cell + vertical-align"></a>2. inline-block + text-align + table-cell + vertical-align</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .parent &#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">    display: table-cell;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line">  &#125;</span><br><span class="line">  .child &#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ul><li>兼容性好</li></ul><h5 id="3-flex-justify-content-align-items"><a href="#3-flex-justify-content-align-items" class="headerlink" title="3. flex + justify-content + align-items"></a>3. flex + justify-content + align-items</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .parent &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: center; /* 水平居中 */</span><br><span class="line">    align-items: center; /*垂直居中*/</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ul><li>只需设置父节点属性，无需设置子元素</li><li>蛋疼的兼容性问题</li></ul><h3 id="一列定宽，一列自适应"><a href="#一列定宽，一列自适应" class="headerlink" title="一列定宽，一列自适应"></a>一列定宽，一列自适应</h3><hr><h5 id="1-float-margin"><a href="#1-float-margin" class="headerlink" title="1.float + margin"></a>1.float + margin</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;left&quot;&gt;</span><br><span class="line">    &lt;p&gt;left&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;right&quot;&gt;</span><br><span class="line">    &lt;p&gt;right&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;right&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .left &#123;</span><br><span class="line">    float: left;</span><br><span class="line">    width: 100px;</span><br><span class="line">  &#125;</span><br><span class="line">  .right &#123;</span><br><span class="line">    margin-left: 100px</span><br><span class="line">    /*间距可再加入 margin-left */</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h6 id="IE-6-中会有3像素的-BUG，解决方法可以在-left-加入-margin-left-3px-当然也有解决这个小bug的方案如下："><a href="#IE-6-中会有3像素的-BUG，解决方法可以在-left-加入-margin-left-3px-当然也有解决这个小bug的方案如下：" class="headerlink" title="IE 6 中会有3像素的 BUG，解决方法可以在 .left 加入 margin-left:-3px 当然也有解决这个小bug的方案如下："></a>IE 6 中会有3像素的 BUG，解决方法可以在 .left 加入 margin-left:-3px 当然也有解决这个小bug的方案如下：</h6><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;left&quot;&gt;</span><br><span class="line">    &lt;p&gt;left&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;right-fix&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;right&quot;&gt;</span><br><span class="line">      &lt;p&gt;right&lt;/p&gt;</span><br><span class="line">      &lt;p&gt;right&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .left &#123;</span><br><span class="line">    float: left;</span><br><span class="line">    width: 100px;</span><br><span class="line">  &#125;</span><br><span class="line">  .right-fix &#123;</span><br><span class="line">    float: right;</span><br><span class="line">    width: 100%;</span><br><span class="line">    margin-left: -100px;</span><br><span class="line">  &#125;</span><br><span class="line">  .right &#123;</span><br><span class="line">    margin-left: 100px</span><br><span class="line">    /*间距可再加入 margin-left */</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ul><li>此方法不会存在 IE 6 中3像素的 BUG，但 .left 不可选择， 需要设置 .left {position: relative} 来提高层级。 注意此方法增加了不必要的 HTML 文本结构。</li></ul><h5 id="2-float-overflow"><a href="#2-float-overflow" class="headerlink" title="2.float + overflow"></a>2.float + overflow</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;left&quot;&gt;</span><br><span class="line">    &lt;p&gt;left&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;right&quot;&gt;</span><br><span class="line">    &lt;p&gt;right&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;right&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .left &#123;</span><br><span class="line">    float: left;</span><br><span class="line">    width: 100px;</span><br><span class="line">  &#125;</span><br><span class="line">  .right &#123;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ul><li>设置 overflow: hidden 会触发 BFC 模式（Block Formatting Context）块级格式上下文。BFC是什么呢。用通俗的来讲就是，随便你在BFC 里面干啥，外面都不会受到影响 。此方法样式简单但不支持 IE 6</li></ul><h5 id="3-table"><a href="#3-table" class="headerlink" title="3.table"></a>3.table</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;left&quot;&gt;</span><br><span class="line">    &lt;p&gt;left&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;right&quot;&gt;</span><br><span class="line">    &lt;p&gt;right&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;right&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .parent &#123;</span><br><span class="line">    display: table;</span><br><span class="line">    width: 100%;</span><br><span class="line">    table-layout: fixed;</span><br><span class="line">  &#125;</span><br><span class="line">  .left &#123;</span><br><span class="line">    display: table-cell;</span><br><span class="line">    width: 100px;</span><br><span class="line">  &#125;</span><br><span class="line">  .right &#123;</span><br><span class="line">    display: table-cell;</span><br><span class="line">    /*宽度为剩余宽度*/</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ul><li>table 的显示特性为每列的单元格宽度和一定等与表格宽度。 table-layout: fixed 可加速渲染，也是设定布局优先。table-cell 中不可以设置 margin 但是可以通过 padding 来设置间距</li></ul><h5 id="4-flex"><a href="#4-flex" class="headerlink" title="4.flex"></a>4.flex</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;left&quot;&gt;</span><br><span class="line">    &lt;p&gt;left&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;right&quot;&gt;</span><br><span class="line">    &lt;p&gt;right&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;right&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .parent &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">  &#125;</span><br><span class="line">  .left &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    margin-left: 20px;</span><br><span class="line">  &#125;</span><br><span class="line">  .right &#123;</span><br><span class="line">    flex: 1;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ul><li>低版本浏览器兼容问题</li><li>性能问题，只适合小范围布局</li></ul><h3 id="等分布局"><a href="#等分布局" class="headerlink" title="等分布局"></a>等分布局</h3><hr><h5 id="1-float"><a href="#1-float" class="headerlink" title="1.float"></a>1.float</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;column&quot;&gt;</span><br><span class="line">    &lt;p&gt;1&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;column&quot;&gt;</span><br><span class="line">    &lt;p&gt;2&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;column&quot;&gt;</span><br><span class="line">    &lt;p&gt;3&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;column&quot;&gt;</span><br><span class="line">    &lt;p&gt;4&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .parent &#123;</span><br><span class="line">    margin-left: -20px;</span><br><span class="line">  &#125;</span><br><span class="line">  .column &#123;</span><br><span class="line">    float: left;</span><br><span class="line">    width: 25%;</span><br><span class="line">    padding-left: 20px;</span><br><span class="line">    box-sizing: border-box;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ul><li>此方法可以完美兼容 IE8 以上版本</li></ul><h5 id="2-flex"><a href="#2-flex" class="headerlink" title="2.flex"></a>2.flex</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;column&quot;&gt;</span><br><span class="line">    &lt;p&gt;1&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;column&quot;&gt;</span><br><span class="line">    &lt;p&gt;2&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;column&quot;&gt;</span><br><span class="line">    &lt;p&gt;3&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;column&quot;&gt;</span><br><span class="line">    &lt;p&gt;4&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .parent &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">  &#125;</span><br><span class="line">  .column &#123;</span><br><span class="line">    flex: 1;</span><br><span class="line">  &#125;</span><br><span class="line">  .column+.column &#123; /* 相邻兄弟选择器 */</span><br><span class="line">    margin-left: 20px;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ul><li>强大简单，有兼容问题</li></ul><h5 id="3-table-1"><a href="#3-table-1" class="headerlink" title="3.table"></a>3.table</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&apos;parent-fix&apos;&gt;</span><br><span class="line">  &lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;column&quot;&gt;</span><br><span class="line">      &lt;p&gt;1&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;column&quot;&gt;</span><br><span class="line">      &lt;p&gt;2&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;column&quot;&gt;</span><br><span class="line">      &lt;p&gt;3&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;column&quot;&gt;</span><br><span class="line">      &lt;p&gt;4&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .parent-fix &#123;</span><br><span class="line">    margin-left: -20px;</span><br><span class="line">  &#125;</span><br><span class="line">  .parent &#123;</span><br><span class="line">    display: table;</span><br><span class="line">    width: 100%;</span><br><span class="line">    /*可以布局优先，也可以单元格宽度平分在没有设置的情况下*/</span><br><span class="line">    table-layout: fixed;</span><br><span class="line">  &#125;</span><br><span class="line">  .column &#123;</span><br><span class="line">    display: table-cell;</span><br><span class="line">    padding-left: 20px;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="等高布局"><a href="#等高布局" class="headerlink" title="等高布局"></a>等高布局</h3><hr><h5 id="1-table"><a href="#1-table" class="headerlink" title="1.table"></a>1.table</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;left&quot;&gt;</span><br><span class="line">    &lt;p&gt;left&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;right&quot;&gt;</span><br><span class="line">    &lt;p&gt;right&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;right&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .parent &#123;</span><br><span class="line">    display: table;</span><br><span class="line">    width: 100%;</span><br><span class="line">    table-layout: fixed;</span><br><span class="line">  &#125;</span><br><span class="line">  .left &#123;</span><br><span class="line">    display: table-cell;</span><br><span class="line">    width: 100px;</span><br><span class="line">  &#125;</span><br><span class="line">  .right &#123;</span><br><span class="line">    display: table-cell</span><br><span class="line">    /*宽度为剩余宽度*/</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h5 id="2-flex-1"><a href="#2-flex-1" class="headerlink" title="2.flex"></a>2.flex</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;left&quot;&gt;</span><br><span class="line">    &lt;p&gt;left&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;right&quot;&gt;</span><br><span class="line">    &lt;p&gt;right&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;right&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .parent &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">  &#125;</span><br><span class="line">  .left &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    margin-left: 20px;</span><br><span class="line">  &#125;</span><br><span class="line">  .right &#123;</span><br><span class="line">    flex: 1;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ul><li>注意这里实际上使用了 align-items: stretch，flex 默认的 align-items 的值为 stretch</li></ul><h5 id="3-float"><a href="#3-float" class="headerlink" title="3.float"></a>3.float</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;left&quot;&gt;</span><br><span class="line">    &lt;p&gt;left&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;right&quot;&gt;</span><br><span class="line">    &lt;p&gt;right&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;right&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .parent &#123;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">  &#125;</span><br><span class="line">  .left,</span><br><span class="line">  .right &#123;</span><br><span class="line">    padding-bottom: 9999px;</span><br><span class="line">    margin-bottom: -9999px;</span><br><span class="line">  &#125;</span><br><span class="line">  .left &#123;</span><br><span class="line">    float: left;</span><br><span class="line">    width: 100px;</span><br><span class="line">    margin-right: 20px;</span><br><span class="line">  &#125;</span><br><span class="line">  .right &#123;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h5 id="此方法为伪等高（只有背景显示高度相等），左右真实的高度其实不相等。-兼容性较好。"><a href="#此方法为伪等高（只有背景显示高度相等），左右真实的高度其实不相等。-兼容性较好。" class="headerlink" title="此方法为伪等高（只有背景显示高度相等），左右真实的高度其实不相等。 兼容性较好。"></a>此方法为伪等高（只有背景显示高度相等），左右真实的高度其实不相等。 兼容性较好。</h5><p>到此，我们了解常见的布局解决方案，这些只是参考，一样的布局实现方式多种多样。主要就使用position、flex 、table（从很久很久以前起，我们就抛弃了table布局页面，但display: table;是异常强大）、float等属性目前flex兼容性较差 傲娇的程序员应该放弃太低版本的浏览器</p>]]></content>
      
      
      <categories>
          
          <category> css应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 布局 </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>promise原理解析</title>
      <link href="/2016/08/25/javaScript/promise/"/>
      <url>/2016/08/25/javaScript/promise/</url>
      
        <content type="html"><![CDATA[<h5 id="promise模式"><a href="#promise模式" class="headerlink" title="promise模式"></a>promise模式</h5><p>这几种方式的可维护性逐级递增，理解难度也逐级递增。这篇总结也是针对promise模式的。</p><p>promise模式那么多中异步编程的方式，为什么选择promise, 因为前面几种方式不够灵活，用起来不够痛快，不优雅。为了降低异步编程的复杂性，所以promise。</p><p>promise的核心是有一个promise对象，这个对象有一个重要的then()方法, 它用于指定回调函数，如：<br>f1().then(f2);</p><p>promise模式在任何时刻都有三种状态：已完成（resolved），未完成（unfulfilled），那么then()方法就是为状态变化指定不同的回调函数，并总是返回一个promise对象，方便链式调用。</p><p>那promise模式下，返回的数据如何在各个回调函数之间传播呢，通过resolve方法，你可以将一个函数的返回值作为参数传递给另一个函数，并且将另一个函数的返回值作为参数再传递给下一个函数……像一条“链”一样无限的这么做下去。</p><h5 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//constructor</span><br><span class="line">var promise = function() &#123;</span><br><span class="line">this.callbacks = [];</span><br><span class="line">&#125;</span><br><span class="line">promise.prototype = &#123;</span><br><span class="line">  construct: promise,</span><br><span class="line">//成功的操作</span><br><span class="line">resolve: function(result) &#123;</span><br><span class="line">this.complete(&apos;resolve&apos;, result);</span><br><span class="line">&#125;,</span><br><span class="line">//失败</span><br><span class="line">reject: function(result) &#123;</span><br><span class="line">this.complete(&quot;reject&quot;, result);</span><br><span class="line">&#125;,</span><br><span class="line">//执行回调</span><br><span class="line">complete: function(type, result) &#123;</span><br><span class="line">while(this.callbacks[0]) &#123;</span><br><span class="line">this.callbacks.shift()[type](result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">then: function(successHandler, failedHandler) &#123;</span><br><span class="line">this.callbacks.push(&#123;</span><br><span class="line">resolve: successHandler,</span><br><span class="line">reject: failedHandler</span><br><span class="line">&#125;);</span><br><span class="line">return this;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行下边是方法的调用</span><br><span class="line">var pro = new promise();</span><br><span class="line">var delay1 = function() &#123;</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">pro.resolve(&apos;数据1&apos;);</span><br><span class="line">&#125;, 1000);</span><br><span class="line">return pro;</span><br><span class="line">&#125;;</span><br><span class="line">var callback1 = function(re) &#123;</span><br><span class="line">re = re + &apos;数据2&apos;;</span><br><span class="line">console.log(re);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delay1().then(callback1)</span><br><span class="line">console.log(&quot;我是最后吗&quot;);</span><br><span class="line"> /*</span><br><span class="line"> *以上方法输出的结果分别是</span><br><span class="line"> *我是最后吗</span><br><span class="line"> *数据1</span><br><span class="line"> *数据2</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>#####代码分析<br>我们可看到一个简单的promise对象的构造函数的结构：</p><pre><code>callbacks: 用于管理回调函数resolve: 请求成功时执行的方法reject:请求失败时执行的方法complete: 执行回调then：绑定回调函数</code></pre><h5 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var delay1 = function() &#123;</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">promise.resolve(‘数据1’);</span><br><span class="line">&#125;, 1000);</span><br><span class="line">return promise;</span><br><span class="line">&#125;;</span><br><span class="line">//这个函数通过setTimeout方法， 异步传递一个数据1， 并返回一个promise对象(必须)。</span><br></pre></td></tr></table></figure><p>#####第二步<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var callback1 = function(re) &#123;</span><br><span class="line">re = re + &apos;数据2&apos;;</span><br><span class="line">console.log(re);</span><br><span class="line">promise.resolve(re);</span><br><span class="line">&#125;;</span><br><span class="line">//callback1和callback2都是要通过then方法注册的回调函数， 其中callback1通过resolve方法把数据往下传递。</span><br></pre></td></tr></table></figure></p><h5 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delay1().then(callback1).then(callback2);</span><br><span class="line">//delay1() 方法执行完， 因为返回了一个promise对象， 所以可以再调用then() 方法为delay1() 的setTimeout异步执行操作指定回调函数, 又因为then() 方法也返回的是promise对象， 所以还可以再调用then方法</span><br></pre></td></tr></table></figure><h5 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function() &#123;</span><br><span class="line">promise.resolve(&apos;数据1&apos;);</span><br><span class="line">&#125;, 1000);</span><br><span class="line">//一秒之后， 当其他代码执行完成， 开始执行异步代码promise.resolve(‘数据1’);，</span><br><span class="line">//这里调用promise的resolve() 方法， 指定了一个成功状态， 并把数据1作为参数。</span><br></pre></td></tr></table></figure><h5 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resolve: function(result) &#123;</span><br><span class="line">  this.complete(&quot;resolve&quot;, result);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h5 id="第六步：循环执行回调，将上一个回调的结果传递给下一个回调"><a href="#第六步：循环执行回调，将上一个回调的结果传递给下一个回调" class="headerlink" title="第六步：循环执行回调，将上一个回调的结果传递给下一个回调"></a>第六步：循环执行回调，将上一个回调的结果传递给下一个回调</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">complete: function(type, result) &#123;</span><br><span class="line">while(this.callbacks[0]) &#123;</span><br><span class="line">this.callbacks.shift()[type](result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javaScript原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> promise </tag>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Number深入解析</title>
      <link href="/2016/08/25/javaScript/number/"/>
      <url>/2016/08/25/javaScript/number/</url>
      
        <content type="html"><![CDATA[<h3 id="Number简介"><a href="#Number简介" class="headerlink" title="Number简介"></a>Number简介</h3><blockquote><p>javaScript不区分整数值和浮点数值。javaScript中所有的数字均用浮点数值表示。javaScript应用的是IEEE754标准定义64位浮点格式表示的数字。它表示的最大值是+/-1.7976931348623157<em>10<sup>308</sup>,最小值是+/-5 </em>10<sup>-324</sup>。javaScript能够表示的正数范围是-2<sup>53</sup>~2<sup>53</sup>,包含界限。如果使用了超出此范围的整数，则无法保证低位数字的精度。还需要注意的是javaScript中实际的操作（比如数组索引）则是基于32位整数。在javaScript中直接出现的数值称之为数字直接量（numneric lieral）。</p></blockquote><h3 id="整型直接量"><a href="#整型直接量" class="headerlink" title="整型直接量"></a>整型直接量</h3><p>javaScript中识别十进制整数以及八进制（严格模式中是禁止使用八进制的）和十六进制</p><h3 id="浮点型直接量"><a href="#浮点型直接量" class="headerlink" title="浮点型直接量"></a>浮点型直接量</h3><p>浮点型直接量可以包含有小数点。下面是浮点型的书写方案：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3.14</span><br><span class="line">033.56</span><br><span class="line">.777</span><br><span class="line">6.7e33</span><br><span class="line">6.7E33</span><br><span class="line">6.7e-33</span><br><span class="line">6.7e3.3 //会报错 Uncaught SyntaxError: Unexpected number</span><br></pre></td></tr></table></figure></p><p>书写语法表示为：<br>[digits][.digits][(E|e)[+|-]digits]</p><h3 id="算数运算"><a href="#算数运算" class="headerlink" title="算数运算"></a>算数运算</h3><p>算数运算的运算符有：加法运算符（+）、减法运算符（-）、乘法运算符（*）、除法运算符（/）、求余运算符（%）。以及Math的属性和方法。</p><ol><li>Math对象的属性：</li></ol><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">E</td><td style="text-align:left">返回算术常量 e，即自然对数的底数（约等于2.718）。</td></tr><tr><td style="text-align:left">LN2</td><td style="text-align:left">返回 2 的自然对数（约等于0.693）。</td></tr><tr><td style="text-align:left">LN10</td><td style="text-align:left">返回 10 的自然对数（约等于2.302）。</td></tr><tr><td style="text-align:left">LOG2E</td><td style="text-align:left">返回以 2 为底的 e 的对数（约等于 1.414）。</td></tr><tr><td style="text-align:left">PI</td><td style="text-align:left">返回圆周率（约等于3.14159）。</td></tr><tr><td style="text-align:left">LOG10E</td><td style="text-align:left">返回以 10 为底的 e 的对数（约等于0.434）。</td></tr><tr><td style="text-align:left">SQRT1_2</td><td style="text-align:left">返回返回 2 的平方根的倒数（约等于 0.707）。</td></tr><tr><td style="text-align:left">SQRT2</td><td style="text-align:left">返回 2 的平方根（约等于 1.414）。</td></tr></tbody></table><ol start="2"><li>Math 对象方法</li></ol><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">abs(x)</td><td style="text-align:left">返回数的绝对值。</td></tr><tr><td style="text-align:left">acos(x)</td><td style="text-align:left">返回数的反余弦值。</td></tr><tr><td style="text-align:left">asin(x)</td><td style="text-align:left">返回数的反正弦值。</td></tr><tr><td style="text-align:left">atan(x)</td><td style="text-align:left">以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值。</td></tr><tr><td style="text-align:left">atan2(y,x)</td><td style="text-align:left">返回从 x 轴到点 (x,y) 的角度（介于 -PI/2 与 PI/2 弧度之间）。</td></tr><tr><td style="text-align:left">ceil(x)</td><td style="text-align:left">对数进行上舍入。</td></tr><tr><td style="text-align:left">cos(x)</td><td style="text-align:left">返回数的余弦</td></tr><tr><td style="text-align:left">exp(x)</td><td style="text-align:left">返回 e 的指数</td></tr><tr><td style="text-align:left">floor(x)</td><td style="text-align:left">对数进行下舍入</td></tr><tr><td style="text-align:left">log(x)</td><td style="text-align:left">返回数的自然对数（底为e）</td></tr><tr><td style="text-align:left">max(x,y)</td><td style="text-align:left">返回 x 和 y 中的最高值</td></tr><tr><td style="text-align:left">min(x,y)</td><td style="text-align:left">返回 x 和 y 中的最低值</td></tr><tr><td style="text-align:left">pow(x,y)</td><td style="text-align:left">返回 x 的 y 次幂</td></tr><tr><td style="text-align:left">random()</td><td style="text-align:left">返回 0 ~ 1 之间的随机数</td></tr><tr><td style="text-align:left">round(x)</td><td style="text-align:left">把数四舍五入为最接近的整数</td></tr><tr><td style="text-align:left">sin(x)</td><td style="text-align:left">返回数的正弦。</td></tr><tr><td style="text-align:left">sqrt(x)</td><td style="text-align:left">返回数的平方根</td></tr><tr><td style="text-align:left">tan(x)</td><td style="text-align:left">返回角的正切</td></tr><tr><td style="text-align:left">toSource()</td><td style="text-align:left">返回该对象的源代码</td></tr><tr><td style="text-align:left">valueOf()</td><td style="text-align:left">返回 Math 对象的原始值</td></tr></tbody></table><h3 id="Infinity与NAN"><a href="#Infinity与NAN" class="headerlink" title="Infinity与NAN"></a>Infinity与NAN</h3><p>在JavaScript的算术运算在溢出(overflow)、下益(underflow)或被零整除时不会报错。<br><strong>溢出</strong><br>当数字超出数字的上限结果用Infinity表示超出下线用-Infinity表示。关于无穷大的行为特性为：基于它们的加、减、乘、除运算的结果还是无穷大。<br><strong>下益</strong><br>当运算结果无限接近零并比JavaScript能表示的最小值还小的时候发生的一种情形。这种情况下JavaScript将会返回0，当负数发生下益时，JavaScript会返回一个特殊的值“负零”。</p><p>寄语：生活想让我们缴械，但是从这一刻起我们要做的是反击 。:)</p>]]></content>
      
      
      <categories>
          
          <category> javaScript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> number </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>new实现原理</title>
      <link href="/2016/08/25/javaScript/new/"/>
      <url>/2016/08/25/javaScript/new/</url>
      
        <content type="html"><![CDATA[<p>其实javascript的new关键字只不过做了五件事情。</p><p>1.创建Object</p><p>2.查找class的prototype上的所有方法、属性，复制一份给创建的Object（注意，如果prototype上有属性是function或者数组或者Object，那么只复制指针）</p><p>3.将构造函数classA内部的this指向创建的Object</p><p>4.创建的Object的<strong>proto</strong>指向class的prototype</p><p>5.执行构造函数class</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 定义类 类名字是 classA  </span><br><span class="line">function classA()&#123;  </span><br><span class="line">    this.b=1;  </span><br><span class="line">&#125;  </span><br><span class="line">classA.prototype.b=44;  </span><br><span class="line">classA.prototype.show = function()&#123;  </span><br><span class="line">    alert(this.b);  </span><br><span class="line">&#125;;  </span><br><span class="line">// 用new实例化  </span><br><span class="line">var b = new classA();  </span><br><span class="line">b.show();  </span><br><span class="line">// 用函数实例化  </span><br><span class="line">function newClass(cls,args)&#123;  </span><br><span class="line">    var obj = &#123;&#125;;  </span><br><span class="line">    for(var p in cls.prototype)  </span><br><span class="line">        obj[p] = cls.prototype[p];  </span><br><span class="line">    obj.__proto__ = cls.prototype;  </span><br><span class="line">    cls.apply(obj,args||[]);  </span><br><span class="line">    return obj;  </span><br><span class="line">&#125;;  </span><br><span class="line">var k = newClass(classA);  </span><br><span class="line">k.show();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javaScript原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> new </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>执行上下文</title>
      <link href="/2016/08/25/javaScript/context/"/>
      <url>/2016/08/25/javaScript/context/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在《JavaScript深入之执行上下文栈》中讲到，当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。</p></blockquote><p>对于每个执行上下文，都有三个重要属性：</p><ul><li>变量对象(Variable object，VO)</li><li>作用域链(Scope chain)</li><li>this</li></ul><p>然后分别在《JavaScript深入之变量对象》、《JavaScript深入之作用域链》、《JavaScript深入之从ECMAScript规范解读this》中讲解了这三个属性。</p><p>阅读本文前，如果对以上的概念不是很清楚，希望先阅读这些文章。</p><p>因为，这一篇，我们会结合着所有内容，讲讲执行上下文的具体处理过程。</p><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>在《JavaScript深入之词法作用域和动态作用域》中，提出这样一道思考题：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var scope = &quot;global scope&quot;;</span><br><span class="line">function checkscope()&#123;</span><br><span class="line">    var scope = &quot;local scope&quot;;</span><br><span class="line">    function f()&#123;</span><br><span class="line">        return scope;</span><br><span class="line">    &#125;</span><br><span class="line">    return f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br><span class="line">var scope = &quot;global scope&quot;;</span><br><span class="line">function checkscope()&#123;</span><br><span class="line">    var scope = &quot;local scope&quot;;</span><br><span class="line">    function f()&#123;</span><br><span class="line">        return scope;</span><br><span class="line">    &#125;</span><br><span class="line">    return f;</span><br><span class="line">&#125;</span><br><span class="line">checkscope()();</span><br></pre></td></tr></table></figure></p><p>两段代码都会打印’local scope’。虽然两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？</p><blockquote><p>紧接着就在下一篇《JavaScript深入之执行上下文栈》中，讲到了两者的区别在于执行上下文栈的变化不一样，然而，如果是这样笼统的回答，依然显得不够详细，本篇就会详细的解析执行上下文栈和执行上下文的具体变化过程。</p></blockquote><p>具体执行分析<br>我们分析第一段代码：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var scope = &quot;global scope&quot;;</span><br><span class="line">function checkscope()&#123;</span><br><span class="line">    var scope = &quot;local scope&quot;;</span><br><span class="line">    function f()&#123;</span><br><span class="line">        return scope;</span><br><span class="line">    &#125;</span><br><span class="line">    return f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br></pre></td></tr></table></figure></p><p>执行过程如下：</p><p>1.执行全局代码，创建全局执行上下文，全局上下文被压入执行上下文栈</p><pre><code>ECStack = [    globalContext];</code></pre><p>2.全局上下文初始化</p><pre><code>globalContext = {    VO: [global, scope, checkscope],    Scope: [globalContext.VO],    this: globalContext.VO}</code></pre><p>2.初始化的同时，checkscope 函数被创建，保存作用域链到函数的内部属性[[scope]]</p><pre><code>checkscope.[[scope]] = [  globalContext.VO];</code></pre><p>3.执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈</p><pre><code>ECStack = [    checkscopeContext,    globalContext];</code></pre><p>4.checkscope 函数执行上下文初始化：</p><p>复制函数 [[scope]] 属性创建作用域链，<br>用 arguments 创建活动对象，<br>初始化活动对象，即加入形参、函数声明、变量声明，<br>将活动对象压入 checkscope 作用域链顶端。<br>同时 f 函数被创建，保存作用域链到 f 函数的内部属性[[scope]]<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        arguments: &#123;</span><br><span class="line">            length: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        scope: undefined,</span><br><span class="line">        f: reference to function f()&#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    Scope: [AO, globalContext.VO],</span><br><span class="line">    this: undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>5.执行 f 函数，创建 f 函数执行上下文，f 函数执行上下文被压入执行上下文栈<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">    fContext,</span><br><span class="line">    checkscopeContext,</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p><p>6.f 函数执行上下文初始化, 以下跟第 4 步相同：</p><p>复制函数 [[scope]] 属性创建作用域链<br>用 arguments 创建活动对象<br>初始化活动对象，即加入形参、函数声明、变量声明<br>将活动对象压入 f 作用域链顶端<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fContext = &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        arguments: &#123;</span><br><span class="line">            length: 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    Scope: [AO, checkscopeContext.AO, globalContext.VO],</span><br><span class="line">    this: undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>7.f 函数执行，沿着作用域链查找 scope 值，返回 scope 值</p><p>8.f 函数执行完毕，f 函数上下文从执行上下文栈中弹出<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">    checkscopeContext,</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p><p>9.checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p><p>第二段代码就留给大家去尝试模拟它的执行过程。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var scope = &quot;global scope&quot;;</span><br><span class="line">function checkscope()&#123;</span><br><span class="line">    var scope = &quot;local scope&quot;;</span><br><span class="line">    function f()&#123;</span><br><span class="line">        return scope;</span><br><span class="line">    &#125;</span><br><span class="line">    return f;</span><br><span class="line">&#125;</span><br><span class="line">checkscope()();</span><br></pre></td></tr></table></figure></p><p>不过，在下一篇《JavaScript深入之闭包》中也会提及这段代码的执行过程。</p>]]></content>
      
      
      <categories>
          
          <category> javaScript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 执行上下文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>forEach实现原理</title>
      <link href="/2016/08/25/javaScript/foreach/"/>
      <url>/2016/08/25/javaScript/foreach/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">function forEach(object, block, context, fn) &#123;</span><br><span class="line">if(object == null) return;</span><br><span class="line">if(!fn) &#123;</span><br><span class="line">if(typeof object == &quot;function&quot; &amp;&amp; object.call) &#123;</span><br><span class="line">//遍历普通对象</span><br><span class="line">fn = Function;</span><br><span class="line">&#125; else if(typeof object.forEach == &quot;function&quot; &amp;&amp; object.forEach != arguments.callee) &#123;</span><br><span class="line">//如果目标已经实现了forEach方法，则使用它自己的forEach方法（如标准游览器的Array对象）</span><br><span class="line">object.forEach(block, context);</span><br><span class="line">return;</span><br><span class="line">&#125; else if(typeof object.length == &quot;number&quot;) &#123;</span><br><span class="line">// 如果是类数组对象或IE的数组对象</span><br><span class="line">_Array_forEach(object, block, context);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">_Function_forEach(fn || Object, object, block, context);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function _Array_forEach(array, block, context) &#123;</span><br><span class="line">if(array == null) return;</span><br><span class="line">var i = 0,</span><br><span class="line">length = array.length;</span><br><span class="line">if(typeof array == &quot;string&quot;) &#123;</span><br><span class="line">for(; i &lt; length; i++) &#123;</span><br><span class="line">block.call(context, array.charAt(i), i, array);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">for(; i &lt; length; i++) &#123;</span><br><span class="line">block.call(context, array[i], i, array);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">_Function_forEach = function(fn, object, block, context) &#123;</span><br><span class="line">// 这里的fn恒为Function</span><br><span class="line">for(var key in object) &#123;</span><br><span class="line">//只遍历本地属性</span><br><span class="line">if(object.hasOwnProperty(key)) &#123;</span><br><span class="line">//相当于 block(object[key], key)</span><br><span class="line">block.call(context, object[key], key, object);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javaScript原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> forEach </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaScript各种错误类型</title>
      <link href="/2016/08/25/javaScript/error/"/>
      <url>/2016/08/25/javaScript/error/</url>
      
        <content type="html"><![CDATA[<h4 id="1-SyntaxError（语法错误）"><a href="#1-SyntaxError（语法错误）" class="headerlink" title="1.SyntaxError（语法错误）"></a>1.SyntaxError（语法错误）</h4><p>解析代码时发生的语法错误<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eg:var 1a;</span><br><span class="line"></span><br><span class="line">　　Uncaught SyntaxError: Unexpected number</span><br></pre></td></tr></table></figure></p><h4 id="2-ReferenceError（引用错误）"><a href="#2-ReferenceError（引用错误）" class="headerlink" title="2.ReferenceError（引用错误）"></a>2.ReferenceError（引用错误）</h4><p>a.引用了一个不存在的变量<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eg: console.log(a);</span><br><span class="line"></span><br><span class="line">　　Uncaught ReferenceError: a is not defined</span><br></pre></td></tr></table></figure></p><p>b.将变量赋值给一个无法被赋值的对象<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eg:console.log()= 1;</span><br><span class="line"></span><br><span class="line">　　Uncaught ReferenceError: Invalid left-hand side in assignment</span><br></pre></td></tr></table></figure></p><h4 id="3-RangeError（范围错误）"><a href="#3-RangeError（范围错误）" class="headerlink" title="3.RangeError（范围错误）"></a>3.RangeError（范围错误）</h4><p>超出有效范围<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eg:var a= new Array(-1);</span><br><span class="line"></span><br><span class="line">　　Uncaught RangeError: Invalid array length</span><br></pre></td></tr></table></figure></p><h4 id="4-TypeError（类型错误）"><a href="#4-TypeError（类型错误）" class="headerlink" title="4.TypeError（类型错误）"></a>4.TypeError（类型错误）</h4><p>a.变量或参数不是预期类型，比如，对字符串、布尔值、数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eg: var a= new 123;</span><br><span class="line"></span><br><span class="line">　　Uncaught TypeError: 123 is not a function</span><br></pre></td></tr></table></figure></p><p>b.调用对象不存在的方法<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eg:var a;a.aa();</span><br><span class="line"></span><br><span class="line">　　Uncaught TypeError: Cannot read property &apos;aa&apos; of undefined</span><br></pre></td></tr></table></figure></p><h4 id="5-URLError（URL错误）"><a href="#5-URLError（URL错误）" class="headerlink" title="5.URLError（URL错误）"></a>5.URLError（URL错误）</h4><p>与url相关函数参数不正确，主要是encodeURI()、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape()这六个函数。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eg: decodeURI(&apos;%2&apos;)</span><br><span class="line"></span><br><span class="line">　　Uncaught URIError: URI malformed</span><br></pre></td></tr></table></figure></p><h5 id="6-EvalError（eval错误）"><a href="#6-EvalError（eval错误）" class="headerlink" title="6.EvalError（eval错误）"></a>6.EvalError（eval错误）</h5><p>eval函数没有被正确执行时，会抛出EvalError错误。该错误类型已经不再在ES5中出现了，只是为了保证与以前代码兼容，才继续保留。</p><p>以上这6种派生错误，连同原始的Error对象，都是构造函数。开发者可以使用它们，人为生成错误对象的实例。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new Error(&quot;出错了！&quot;);</span><br><span class="line">new RangeError(&quot;出错了，变量超出有效范围！&quot;);</span><br><span class="line">new TypeError(&quot;出错了，变量类型无效！&quot;);</span><br></pre></td></tr></table></figure></p><p>上面代码表示新建错误对象的实例，实质就是手动抛出错误。可以看到，错误对象的构造函数接受一个参数，代表错误提示信息（message）。</p>]]></content>
      
      
      <categories>
          
          <category> javaScript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 错误类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webSocket</title>
      <link href="/2016/08/25/javaScript/webSocket/"/>
      <url>/2016/08/25/javaScript/webSocket/</url>
      
        <content type="html"><![CDATA[<h4 id="目录结构如下"><a href="#目录结构如下" class="headerlink" title="目录结构如下"></a>目录结构如下</h4><img src="/2016/08/25/javaScript/webSocket/directory.png" title="RGB示意图"><!-- ![目录](./images/webSocket/directory.png) --><h5 id="WebSocketTestChat-java里的代码"><a href="#WebSocketTestChat-java里的代码" class="headerlink" title="WebSocketTestChat.java里的代码:"></a>WebSocketTestChat.java里的代码:</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">package com.moven.websockets;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpSession;</span><br><span class="line">import javax.websocket.OnClose;</span><br><span class="line">import javax.websocket.OnError;</span><br><span class="line">import javax.websocket.OnMessage;</span><br><span class="line">import javax.websocket.OnOpen;</span><br><span class="line">import javax.websocket.Session;</span><br><span class="line">import javax.websocket.server.PathParam;</span><br><span class="line">import javax.websocket.server.ServerEndpoint;</span><br><span class="line"></span><br><span class="line">@ServerEndpoint(&quot;/chat/&#123;username&#125;&quot;)</span><br><span class="line">public class WebSocketTestChat &#123;</span><br><span class="line">Set&lt;Session&gt; session_list = null;</span><br><span class="line"></span><br><span class="line">@OnMessage</span><br><span class="line">public void onMessage(String message, Session session) &#123;</span><br><span class="line">try&#123;</span><br><span class="line">session_list = session.getOpenSessions();</span><br><span class="line">HttpSession httpSession = null;</span><br><span class="line">String username = &quot;&quot;;</span><br><span class="line">if(session instanceof HttpSession)&#123;</span><br><span class="line">httpSession = (HttpSession)session;</span><br><span class="line">Object param = httpSession.getAttribute(&quot;username&quot;);</span><br><span class="line">if(null != param)&#123;</span><br><span class="line">username = param.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">username = session.getId();</span><br><span class="line">&#125;</span><br><span class="line">for (Session s : session_list) &#123;</span><br><span class="line">s.getBasicRemote().sendText(&quot;当前总人数[&quot; + session_list.size() + &quot;]---&quot; + username + &quot;说:&quot; + message);</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch(IOException e)&#123;</span><br><span class="line">System.out.println(&quot;Client error&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@OnError</span><br><span class="line">    public void onError(Throwable t) throws Throwable &#123;</span><br><span class="line">System.out.println(&quot;Client error = &quot;+t.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">@OnOpen</span><br><span class="line">public void onOpen(@PathParam(&quot;username&quot;) String username, Session session) &#123;</span><br><span class="line">HttpSession httpSession = null;</span><br><span class="line">if(session instanceof HttpSession)&#123;</span><br><span class="line">httpSession = (HttpSession)session;</span><br><span class="line">httpSession.setAttribute(&quot;username&quot;, username);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;Client connected&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@OnClose</span><br><span class="line">public void onClose() &#123;</span><br><span class="line">System.out.println(&quot;Connection closed&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="chat-html里边的代码"><a href="#chat-html里边的代码" class="headerlink" title="chat.html里边的代码"></a>chat.html里边的代码</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Testing websockets&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;textarea name=&quot;text&quot; id=&quot;text&quot; rows=&quot;3&quot; cols=&quot;20&quot;&gt;&lt;/textarea&gt;</span><br><span class="line">&lt;input type=&quot;submit&quot; value=&quot;send&quot; onclick=&quot;start()&quot; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;messages&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">var webSocket = new WebSocket(</span><br><span class="line">&apos;ws://local.moven.cn:8081/moven_im/chat/msw/lyh&apos;);</span><br><span class="line"></span><br><span class="line">webSocket.onerror = function(event) &#123;</span><br><span class="line">onError(event)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">webSocket.onopen = function(event) &#123;</span><br><span class="line">onOpen(event)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">webSocket.onmessage = function(event) &#123;</span><br><span class="line">onMessage(event)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function onMessage(event) &#123;</span><br><span class="line">document.getElementById(&apos;messages&apos;).innerHTML += &apos;&lt;br /&gt;&apos;</span><br><span class="line">+ event.data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function onOpen(event) &#123;</span><br><span class="line">document.getElementById(&apos;messages&apos;).innerHTML = &apos;Connection established&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function onError(event) &#123;</span><br><span class="line">alert(event.data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function start() &#123;</span><br><span class="line">var text = document.getElementById(&apos;text&apos;).value;</span><br><span class="line">if(text)&#123;</span><br><span class="line">webSocket.send(text);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">alert(&quot;Message can&apos;t be null&quot;);</span><br><span class="line">&#125;</span><br><span class="line">document.getElementById(&apos;text&apos;).value = &apos;&apos;;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h5 id="web-xml里边的代码"><a href="#web-xml里边的代码" class="headerlink" title="web.xml里边的代码"></a>web.xml里边的代码</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:web=&quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</span><br><span class="line">xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee</span><br><span class="line">http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span><br><span class="line">id=&quot;WebApp_ID&quot; version=&quot;3.0&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;display-name&gt;Simple web application&lt;/display-name&gt;</span><br><span class="line"></span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure><h5 id="pom-xml里边的代码"><a href="#pom-xml里边的代码" class="headerlink" title="pom.xml里边的代码"></a>pom.xml里边的代码</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">&lt;groupId&gt;com.moven&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;moven_im&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">&lt;properties&gt;</span><br><span class="line">&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;build&gt;</span><br><span class="line">&lt;plugins&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;source&gt;1.7&lt;/source&gt;</span><br><span class="line">&lt;target&gt;1.7&lt;/target&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;javax&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;javaee-api&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;7.0&lt;/version&gt;</span><br><span class="line">&lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> html5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> webSocket </tag>
            
            <tag> html5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Array.prototype.slice应用和原理探析</title>
      <link href="/2016/08/25/javaScript/slice/"/>
      <url>/2016/08/25/javaScript/slice/</url>
      
        <content type="html"><![CDATA[<h3 id="问题由来"><a href="#问题由来" class="headerlink" title="问题由来"></a>问题由来</h3><p>Array.prototype.slice常见于两种调用场景：</p><h5 id="一是对函数arguments对象的转换"><a href="#一是对函数arguments对象的转换" class="headerlink" title="一是对函数arguments对象的转换"></a>一是对函数arguments对象的转换</h5><p>Array.prototype.slice.call(arguments)</p><h5 id="二是类似jQuery原型对象的定义中"><a href="#二是类似jQuery原型对象的定义中" class="headerlink" title="二是类似jQuery原型对象的定义中"></a>二是类似jQuery原型对象的定义中</h5><p>toArray: function() {<br>return slice.call( this, 0 );<br>},</p><p>有必要探究一番其使用方式和内部原理。</p><h3 id="问题拆解"><a href="#问题拆解" class="headerlink" title="问题拆解"></a>问题拆解</h3><p>Array.prototype.slice作为Array.prototype对象的一个方法，对其调用在API中有详细说明，并不费解，对Array.prototype.slice的疑问可拆解为两个方面：一是该函数究竟返回什么对象？二是该函数可应用于什么对象？即非数组对象需要满足什么条件才能借用(复用)该函数？</p><h3 id="该函数究竟返回什么对象"><a href="#该函数究竟返回什么对象" class="headerlink" title="该函数究竟返回什么对象"></a>该函数究竟返回什么对象</h3><p>为了探究返回对象的类型信息，写一个简单的对象工具集合：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var objs = &#123;  </span><br><span class="line">    &quot;descType&quot;:function(o)&#123;  </span><br><span class="line">        console.info(o);  </span><br><span class="line">        console.info(&quot;typeof o:&quot; + (typeof o));  </span><br><span class="line">        console.info(&quot;o.constructor:&quot; + (o.constructor));  </span><br><span class="line">        console.info(&quot;o instanceof Object:&quot; + (o instanceof Object));  </span><br><span class="line">        console.info(&quot;o instanceof Array:&quot; + (o instanceof Array));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>然后测试几个简单的例子：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var v = [&apos;a&apos;,true,9].slice(0);  </span><br><span class="line">objs.descType(v);</span><br><span class="line">// typeof o:object</span><br><span class="line">// o.constructor:function Array() &#123; [native code] &#125;</span><br><span class="line">// o instanceof Object:true</span><br><span class="line">// o instanceof Array:true</span><br></pre></td></tr></table></figure></p><p>数组对象自身上调用slice方法当然不必再使用“var v = Array.prototype.slice.call([‘a’,true,9]);”这种方法，虽然是可以这样用的，结果表明返回的对象的确是Array类型的对象。</p><h3 id="该函数可应用于什么对象"><a href="#该函数可应用于什么对象" class="headerlink" title="该函数可应用于什么对象"></a>该函数可应用于什么对象</h3><p>1 既然该方法是作为Array.prototype的方法，那么数组对象本身当然可以调用该方法。</p><p>2 Arguments类型的对象可正确调用该函数。</p><p>同样用一个简单的例子测试下arguments对象借用该函数后的对象类型。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;  </span><br><span class="line">    objs.descType(arguments);  </span><br><span class="line">    var newArg = Array.prototype.slice.call(arguments, 0);  </span><br><span class="line">    objs.descType(newArg);  </span><br><span class="line">&#125;  </span><br><span class="line">f(&apos;aa&apos;,&apos;bb&apos;,&apos;cc&apos;);</span><br><span class="line"></span><br><span class="line">// [&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;]  </span><br><span class="line">// typeof o:object  </span><br><span class="line">/// o.constructor:function Object() &#123; [native code] &#125;  </span><br><span class="line">// o instanceof Object:true  </span><br><span class="line">// o instanceof Array:false  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// [&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;]  </span><br><span class="line">// typeof o:object  </span><br><span class="line">// o.constructor:function Array() &#123; [native code] &#125;  </span><br><span class="line">// o instanceof Object:true  </span><br><span class="line">// o instanceof Array:true</span><br></pre></td></tr></table></figure></p><p>可以看到arguments对象本身并不是Array类型的–o instanceof Array:false，进一步展开该对象细节，可以看到其属性列表如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;]  </span><br><span class="line">0:&quot;aa&quot;  </span><br><span class="line">1:&quot;bb&quot;  </span><br><span class="line">2:&quot;cc&quot;  </span><br><span class="line">callee:function f()  </span><br><span class="line">length:3</span><br></pre></td></tr></table></figure><p>有length属性，有’0’,’1’,’2’属性，有’callee’属性，是一个Arguments类型的一个对象实例。而经过Array.prototype.slice.call调用后返回的对象就是一个真真正正的Array对象：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;]  </span><br><span class="line">0:&quot;aa&quot;  </span><br><span class="line">1:&quot;bb&quot;  </span><br><span class="line">2:&quot;cc&quot;  </span><br><span class="line">length:3</span><br></pre></td></tr></table></figure><p>这说明arguments对象和转换后的array对象非常类似–不仅属性类似，连用法也类似，比如arguments对象也支持[]运算符调用其属性值(其实本质是对象元素访问的通用语法，只不过属性名刚好为转换为字符串的整数而已)。所以结论是在js语言中，对arguments对象调用Array.prototype.slice.call(arguments, 0)纯属“闲的蛋疼”的做法(除非设计的函数用法非常的动态，比如需要对参数做shift等之类的数组操作)。</p><p>那么除了arguments对象之外，其他类型的对象可以借用Array.prototype.slice函数么？继续简单的测试几个例子：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">objs.descType(Array.prototype.slice.call(true,0));  </span><br><span class="line">objs.descType(Array.prototype.slice.call(&apos;abc&apos;,0));  </span><br><span class="line">objs.descType(Array.prototype.slice.call(256,0));  </span><br><span class="line">objs.descType(Array.prototype.slice.call(&#123;&#125;,0));  </span><br><span class="line">objs.descType(Array.prototype.slice.call(undefined,0));  </span><br><span class="line">objs.descType(Array.prototype.slice.call(null,0));  </span><br><span class="line">objs.descType(Array.prototype.slice.call(NaN,0));</span><br></pre></td></tr></table></figure></p><p>对undefined和null调用slice抛出异常，这是预期的行为，对NaN/true/256/{}返回一个空数组对象，对字符串’abc’返回一个数组：[“a”, “b”, “c”]，现在的重点是对对象调用的探究，传入一个初始化为空的对象直接量返回的是一个空数组对象，而上面测试在arguments对象上调用slice返回一个正常的数组–两者有何区别？</p><p>一个很容易联想的点子是该调用对象应该具备length属性才可以被slice正确处理，测试一下：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objs.descType(Array.prototype.slice.call(&#123;&apos;length&apos;:5&#125;,0));</span><br></pre></td></tr></table></figure></p><p>结果果然是一个length值为5的数组对象，但其中5个元素值都为undefined。那么更进一步的想法应该是：调用对象除了有length属性之外，是不是也应该有索引属性名？即自动转换为字符类型的整数数字属性名？再试一下：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objs.descType(Array.prototype.slice.call(&#123;&apos;length&apos;:5,&apos;0&apos;:&apos;gebilaowang&apos;,&apos;1&apos;:&apos;ximenqin&apos;&#125;,0));</span><br></pre></td></tr></table></figure></p><p>ok，大功告成，结果果然是预期数组：[“gebilaowang”,”ximenqin”,undefined,undefined,undefined]。因此结论是：只有具备”可转换为数值型的length属性”并且同时具备”索引属性”的对象才可以正确被slice函数处理(返回或者说转换为预期数组)，这种类型的对象经过查阅果然有一种专属称谓–Array-like Object。</p><h3 id="3-Array-like对象可正确调用该函数。"><a href="#3-Array-like对象可正确调用该函数。" class="headerlink" title="3 Array-like对象可正确调用该函数。"></a>3 Array-like对象可正确调用该函数。</h3><p>现在来探究jQuery中对Array.prototype.slice方法的使用场景，jQuery对各种原型方法的应用当然是非常牛逼的甚至达到炉火纯青的境界，其实jQuery对象本身就是一个Array-like对象，因为其有length属性，也有索引属性，分析其初始化构造函数(1.6.1版本)即可明白(特别注意对this.length和this[index]属性的设置)：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">jQuery.prototype.init: function( selector, context, rootjQuery ) &#123;  </span><br><span class="line">            var match, elem, ret, doc;  </span><br><span class="line"></span><br><span class="line">            // Handle $(&quot;&quot;), $(null), or $(undefined)  </span><br><span class="line">            if ( !selector ) &#123;  </span><br><span class="line">                return this;  </span><br><span class="line">            &#125;  </span><br><span class="line"></span><br><span class="line">            // Handle $(DOMElement)  </span><br><span class="line">            if ( selector.nodeType ) &#123;  </span><br><span class="line">                this.context = this[0] = selector;  </span><br><span class="line">                this.length = 1;  </span><br><span class="line">                return this;  </span><br><span class="line">            &#125;  </span><br><span class="line"></span><br><span class="line">            // The body element only exists once, optimize finding it  </span><br><span class="line">            if ( selector === &quot;body&quot; &amp;&amp; !context &amp;&amp; document.body ) &#123;  </span><br><span class="line">                this.context = document;  </span><br><span class="line">                this[0] = document.body;  </span><br><span class="line">                this.selector = selector;  </span><br><span class="line">                this.length = 1;  </span><br><span class="line">                return this;  </span><br><span class="line">            &#125;  </span><br><span class="line"></span><br><span class="line">            // Handle HTML strings  </span><br><span class="line">            if ( typeof selector === &quot;string&quot; ) &#123;  </span><br><span class="line">              // Are we dealing with HTML string or an ID?  </span><br><span class="line">               if ( selector.charAt(0) === &quot;&lt;&quot; &amp;&amp; selector.charAt( selector.length - 1 ) === &quot;&gt;&quot; &amp;&amp; selector.length &gt;= 3 ) &#123;  </span><br><span class="line">                   // Assume that strings that start and end with &lt;&gt; are HTML and skip the regex check  </span><br><span class="line">                   match = [ null, selector, null ];  </span><br><span class="line"></span><br><span class="line">               &#125; else &#123;  </span><br><span class="line">                   match = quickExpr.exec( selector );  </span><br><span class="line">               &#125;  </span><br><span class="line"></span><br><span class="line">               // Verify a match, and that no context was specified for #id  </span><br><span class="line">               if ( match &amp;&amp; (match[1] || !context) ) &#123;  </span><br><span class="line"></span><br><span class="line">                   // HANDLE: $(html) -&gt; $(array)  </span><br><span class="line">                   if ( match[1] ) &#123;  </span><br><span class="line">                       context = context instanceof jQuery ? context[0] : context;  </span><br><span class="line">                       doc = (context ? context.ownerDocument || context : document);  </span><br><span class="line"></span><br><span class="line">                       // If a single string is passed in and it&apos;s a single tag  </span><br><span class="line">                       // just do a createElement and skip the rest  </span><br><span class="line">                       ret = rsingleTag.exec( selector );  </span><br><span class="line"></span><br><span class="line">                       if ( ret ) &#123;  </span><br><span class="line">                           if ( jQuery.isPlainObject( context ) ) &#123;  </span><br><span class="line">                               selector = [ document.createElement( ret[1] ) ];  </span><br><span class="line">                               jQuery.fn.attr.call( selector, context, true );  </span><br><span class="line"></span><br><span class="line">                           &#125; else &#123;  </span><br><span class="line">                               selector = [ doc.createElement( ret[1] ) ];  </span><br><span class="line">                           &#125;  </span><br><span class="line"></span><br><span class="line">                       &#125; else &#123;  </span><br><span class="line">                           ret = jQuery.buildFragment( [ match[1] ], [ doc ] );  </span><br><span class="line">                           selector = (ret.cacheable ? jQuery.clone(ret.fragment) : ret.fragment).childNodes;  </span><br><span class="line">                       &#125;  </span><br><span class="line"></span><br><span class="line">                       return jQuery.merge( this, selector );  </span><br><span class="line"></span><br><span class="line">                   // HANDLE: $(&quot;#id&quot;)  </span><br><span class="line">                   &#125; else &#123;  </span><br><span class="line">                        elem = document.getElementById( match[2] );  </span><br><span class="line"></span><br><span class="line">                        // Check parentNode to catch when Blackberry 4.6 returns  </span><br><span class="line">                        // nodes that are no longer in the document #6963  </span><br><span class="line">                        if ( elem &amp;&amp; elem.parentNode ) &#123;  </span><br><span class="line">                            // Handle the case where IE and Opera return items  </span><br><span class="line">                            // by name instead of ID  </span><br><span class="line">                            if ( elem.id !== match[2] ) &#123;  </span><br><span class="line">                                return rootjQuery.find( selector );  </span><br><span class="line">                            &#125;  </span><br><span class="line"></span><br><span class="line">                            // Otherwise, we inject the element directly into the jQuery object  </span><br><span class="line">                            this.length = 1;  </span><br><span class="line">                            this[0] = elem;  </span><br><span class="line">                        &#125;  </span><br><span class="line"></span><br><span class="line">                        this.context = document;  </span><br><span class="line">                        this.selector = selector;  </span><br><span class="line">                        return this;  </span><br><span class="line">                    &#125;  </span><br><span class="line"></span><br><span class="line">                // HANDLE: $(expr, $(...))  </span><br><span class="line">                &#125; else if ( !context || context.jquery ) &#123;  </span><br><span class="line">                    return (context || rootjQuery).find( selector );  </span><br><span class="line"></span><br><span class="line">                // HANDLE: $(expr, context)  </span><br><span class="line">                // (which is just equivalent to: $(context).find(expr)  </span><br><span class="line">                &#125; else &#123;  </span><br><span class="line">                    return this.constructor( context ).find( selector );  </span><br><span class="line">                &#125;  </span><br><span class="line"></span><br><span class="line">            // HANDLE: $(function)  </span><br><span class="line">            // Shortcut for document ready  </span><br><span class="line">            &#125; else if ( jQuery.isFunction( selector ) ) &#123;  </span><br><span class="line">               return rootjQuery.ready( selector );  </span><br><span class="line">           &#125;  </span><br><span class="line"></span><br><span class="line">           if (selector.selector !== undefined) &#123;  </span><br><span class="line">               this.selector = selector.selector;  </span><br><span class="line">               this.context = selector.context;  </span><br><span class="line">           &#125;  </span><br><span class="line"></span><br><span class="line">           return jQuery.makeArray( selector, this );  </span><br><span class="line">       &#125;,</span><br></pre></td></tr></table></figure></p><p>这是分析并理解jQuery背后原理的最基础最前提的一步。</p><h3 id="原理探析"><a href="#原理探析" class="headerlink" title="原理探析"></a>原理探析</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function slice(start, end) &#123;   </span><br><span class="line">    var startToUse = start || 0,   </span><br><span class="line">        endToUse = end || ToUint32(this.length),   </span><br><span class="line">        result = [];   </span><br><span class="line">    for(var i = startToUse; i &lt; endToUse; i++) &#123;   </span><br><span class="line">        result.push(this[i]);   </span><br><span class="line">    &#125;  </span><br><span class="line">    return result;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javaScript原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> Array.prototype.slice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this</title>
      <link href="/2016/08/25/javaScript/this/"/>
      <url>/2016/08/25/javaScript/this/</url>
      
        <content type="html"><![CDATA[<h3 id="this的常见绑定形式"><a href="#this的常见绑定形式" class="headerlink" title="this的常见绑定形式"></a>this的常见绑定形式</h3><p>1.默认绑定<br>2.隐式绑定<br>3.显示绑定<br>4.new绑定</p><blockquote><p>判断this 现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条规则。可以按照下面的顺序来进行判断:</p><ol><li>函数是否在new中调用(new绑定)?如果是的话this绑定的是新创建的对象。<br>  var bar = new foo()</li><li>函数是否通过call、apply(显式绑定)或者硬绑定调用?如果是的话，this绑定的是 指定的对象。<br>  var bar = foo.call(obj2)</li><li>函数是否在某个上下文对象中调用(隐式绑定)?如果是的话，this 绑定的是那个上 下文对象。<br>  var bar = obj1.foo()</li><li>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到 全局对象。<br>  var bar = foo()</li></ol></blockquote><p>关于call、apply、bind的区别：</p><p>|函数|参数|返回|</p><p>|:—–:|:—–:|:—–:|</p><p>|call|第一个参数是context,后边可传多个参数|立即调用|</p><p>|apply|第一个参数是context,后边是一个数组|立即调用|</p><p>|bind|第一个参数是context,后边可传多个参数|返回对应函数|</p><p>在弄清楚这些绑定之前来弄清楚几个概念调用栈和调用位置<br>下面我们来看看到底什么是调用栈和调用位置:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function baz() &#123;</span><br><span class="line">// 当前调用栈是:baz</span><br><span class="line">// 因此，当前调用位置是全局作用域</span><br><span class="line">         console.log( &quot;baz&quot; );</span><br><span class="line">bar(); // &lt;-- bar 的调用位置 &#125;</span><br><span class="line">function bar() &#123;</span><br><span class="line">// 当前调用栈是 baz -&gt; bar</span><br><span class="line">// 因此，当前调用位置在 baz 中</span><br><span class="line">         console.log( &quot;bar&quot; );</span><br><span class="line">foo(); // &lt;-- foo 的调用位置 &#125;</span><br><span class="line">function foo() &#123;</span><br><span class="line">// 当前调用栈是 baz -&gt; bar -&gt; foo // 因此，当前调用位置在 bar 中</span><br><span class="line">         console.log( &quot;foo&quot; );</span><br><span class="line">     &#125;</span><br><span class="line">baz(); // &lt;-- baz 的调用位置</span><br></pre></td></tr></table></figure><p>上面的代码让我们初步明白了调用栈，和调用位置</p><h3 id="默认绑定-指绑定全局变量"><a href="#默认绑定-指绑定全局变量" class="headerlink" title="默认绑定(指绑定全局变量)"></a>默认绑定(指绑定全局变量)</h3><p>思考下面的代码<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">   console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line">var a = 2;</span><br><span class="line">foo(); // 2</span><br></pre></td></tr></table></figure></p><p>上面函数的当前当前调用位置是全局作用域，所以this默认绑定的是window<br><em>如果使用严格模式(strict mode)，那么全局对象将无法使用默认绑定，因此 this 会绑定 到 undefined:</em><br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123; &quot;use strict&quot;;</span><br><span class="line">         console.log( this.a );</span><br><span class="line">     &#125;</span><br><span class="line">var a = 2;</span><br><span class="line">foo(); // TypeError: this is undefined</span><br></pre></td></tr></table></figure></p><h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3><p>在一些复杂的结构中我们经常会碰到隐式绑定<br>先来看下面的代码：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;</span><br><span class="line">  a: 2,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;;</span><br><span class="line">obj.foo(); // 2</span><br></pre></td></tr></table></figure></p><p>foo函数绑定在了obj下边的foo属性上边，所以他的当前调用位置在obj中所以this指向obj。</p><p><em>对象属性引用链中只有最顶层或者说最后一层会影响调用位置</em><br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">   console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line">var obj2 = &#123;</span><br><span class="line">  a: 42,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;;</span><br><span class="line">var obj1 = &#123;</span><br><span class="line">   a: 2,</span><br><span class="line">   obj2: obj2</span><br><span class="line">&#125;;</span><br><span class="line">obj1.obj2.foo(); // 42</span><br></pre></td></tr></table></figure></p><h3 id="隐式丢失"><a href="#隐式丢失" class="headerlink" title="隐式丢失"></a>隐式丢失</h3><p>看下面的例子：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;</span><br><span class="line">  a: 2,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;;</span><br><span class="line">var bar = obj.foo; // 函数别名!</span><br><span class="line">var a = &quot;oops, global&quot;; // a 是全局对象的属性 bar(); // &quot;oops, global&quot;</span><br></pre></td></tr></table></figure></p><p>是不是结果让人诧异<br>虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是 foo 函数本身，因此此时的 bar() 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。（这是你不知道的JavaScript上中的解释，但是我感觉没有说服力，后面会查明真象）</p><p><em>以形参传入其实就是隐式赋值</em><br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line">function doFoo(fn) &#123;</span><br><span class="line">  // fn 其实引用的是 foo</span><br><span class="line">  fn();</span><br><span class="line">  // &lt;-- 调用位置!</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;</span><br><span class="line">  a: 2,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;;</span><br><span class="line">var a = &quot;oops, global&quot;; // a 是全局对象的属性</span><br><span class="line">doFoo( obj.foo ); // &quot;oops, global&quot;</span><br></pre></td></tr></table></figure></p><p>如果把函数传入语言内置的函数而不是传入你自己声明的函数，也会隐式赋值</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123; a: 2,</span><br><span class="line">foo: foo &#125;;</span><br><span class="line">var a = &quot;oops, global&quot;; // a 是全局对象的属性</span><br><span class="line">setTimeout( obj.foo, 100 ); // &quot;oops, global&quot;</span><br></pre></td></tr></table></figure><p>通过上面的代码可以看出来不做显示绑定还是比较危险的而且隐式绑定还是很危险的</p><h3 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h3><ol><li>硬绑定（常用的是call，apply，bind）三种方式的使用</li></ol><p><strong>call</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;</span><br><span class="line">  a:2</span><br><span class="line">&#125;;</span><br><span class="line">var bar = function() &#123;</span><br><span class="line">  foo.call( obj );</span><br><span class="line">&#125;;</span><br><span class="line"> bar(); // 2</span><br><span class="line"> setTimeout( bar, 100 ); // 2</span><br><span class="line">// 硬绑定的 bar 不可能再修改它的</span><br><span class="line">this bar.call( window ); // 2</span><br></pre></td></tr></table></figure><p><strong>apply</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function foo(something) &#123;</span><br><span class="line">  console.log( this.a, something );</span><br><span class="line">  return this.a + something;</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;</span><br><span class="line">  a:2</span><br><span class="line">&#125;;</span><br><span class="line">var bar = function() &#123;</span><br><span class="line">  return foo.apply( obj, arguments );</span><br><span class="line">&#125;;</span><br><span class="line">var b = bar( 3 ); // 2 3</span><br><span class="line">console.log( b ); // 5</span><br></pre></td></tr></table></figure><p>另一种使用方法是创建一个 i 可以重复使用的辅助函数:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function foo(something) &#123;</span><br><span class="line">  console.log( this.a, something );</span><br><span class="line">  return this.a + something;</span><br><span class="line">&#125;</span><br><span class="line">// 简单的辅助绑定函数</span><br><span class="line">function bind(fn, obj) &#123;</span><br><span class="line">  return function() &#123;</span><br><span class="line">    return fn.apply( obj, arguments );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;</span><br><span class="line">  a:2</span><br><span class="line">&#125;;</span><br><span class="line">var bar = bind( foo, obj );</span><br><span class="line">var b = bar( 3 ); // 2 3</span><br><span class="line">console.log( b ); // 5</span><br></pre></td></tr></table></figure></p><p><strong>bind</strong></p><p>在ES5中内置了bind方法</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo(something) &#123;</span><br><span class="line">   console.log( this.a, something );</span><br><span class="line">   return this.a + something;</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;</span><br><span class="line">  a:2</span><br><span class="line">&#125;;</span><br><span class="line">var bar = foo.bind( obj );</span><br><span class="line">var b = bar( 3 ); // 2 3</span><br><span class="line">console.log( b ); // 5</span><br></pre></td></tr></table></figure><p>这里说明一下bind返回的是方法名要想运行样加();比如foo.bind( obj )();这才是运行状态；<br>(bind(..) 会返回一个硬编码的新函数，它会把参数设置为 this 的上下文并调用原始函数)你不知道的JavaScript中的解释</p><ol start="2"><li>API调用的“上下文”</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function foo(el) &#123;</span><br><span class="line">  console.log( el, this.id );</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;</span><br><span class="line">  id: &quot;awesome&quot;</span><br><span class="line">&#125;;</span><br><span class="line">// 调用 foo(..) 时把 this 绑定到 obj</span><br><span class="line">[1, 2, 3].forEach( foo, obj );</span><br><span class="line">// 1 awesome 2 awesome 3 awesome</span><br></pre></td></tr></table></figure><p>有没有一丝懵逼，看解释<br>第三方库的许多函数，以及 JavaScript 语言和宿主环境中许多新的内置函数，都提供了一 个可选的参数，通常被称为“上下文”(context)，其作用和 bind(..) 一样，确保你的回调 函数使用指定的 this。这些函数实际上就是通过 call(..) 或者 apply(..) 实现了显式绑定，这样你可以少些一些 代码。</p><p>###new绑定</p><p><strong>在 JavaScript 中，构造函数只是一些 使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上， 它们甚至都不能说是一种特殊的函数类型，它们只是被 new 操作符调用的普通函数而已。</strong><br>使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。</p><ol><li>创建(或者说构造)一个全新的对象。</li><li>这个新对象会被执行[[原型]]连接。</li><li>这个新对象会绑定到函数调用的this。</li><li>如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。<br>思考下面的代码:<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo(a) &#123;</span><br><span class="line">  this.a = a;</span><br><span class="line">&#125;</span><br><span class="line">var bar = new foo(2);</span><br><span class="line">console.log( bar.a ); // 2</span><br></pre></td></tr></table></figure></li></ol><p>使用 new 来调用 foo(..) 时，我们会构造一个新对象并把它绑定到 foo(..) 调用中的 this 上。new 是最后一种可以影响函数调用时 this 绑定行为的方法，我们称之为 new 绑定。</p><p>###优先级<br>1.先比较一下隐式绑定和显示绑定</p><p>看下面代码</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line">var obj1 = &#123;</span><br><span class="line">  a: 2,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;;</span><br><span class="line">var obj2 = &#123;</span><br><span class="line">  a: 3,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;;</span><br><span class="line">obj1.foo(); // 2</span><br><span class="line">obj2.foo(); // 3</span><br><span class="line"></span><br><span class="line">obj1.foo.call( obj2 ); // 3</span><br><span class="line">obj2.foo.call( obj1 ); // 2</span><br></pre></td></tr></table></figure><p>可以明显的看到显示绑定比隐式绑定的优先级高</p><p>2.现在比较一下new 绑定和隐式绑定<br>看如下代码<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function foo(something) &#123;</span><br><span class="line">  this.a = something;</span><br><span class="line">&#125;</span><br><span class="line">var obj1 = &#123;</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;;</span><br><span class="line">var obj2 = &#123;&#125;;</span><br><span class="line">obj1.foo( 2 );</span><br><span class="line">console.log( obj1.a ); // 2</span><br><span class="line">obj1.foo.call( obj2, 3 );</span><br><span class="line">console.log( obj2.a ); // 3</span><br><span class="line">var bar = new obj1.foo( 4 );</span><br><span class="line">console.log( obj1.a ); // 2</span><br><span class="line">console.log( bar.a ); // 4</span><br></pre></td></tr></table></figure></p><p>可以看到 new 绑定比隐式绑定优先级高<br>3.new 绑定和显式绑定<br>在看代码之前先回忆一下硬绑定是如何工作的。Function.prototype.bind(..) 会创建一个 新的包装函数，这个函数会忽略它当前的 this 绑定(无论绑定的对象是什么)，并把我们 提供的对象绑定到 this 上。<br>看下面的代码<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function foo(something) &#123; this.a = something;</span><br><span class="line">&#125;</span><br><span class="line">var obj1 = &#123;&#125;;</span><br><span class="line">var bar = foo.bind( obj1 );</span><br><span class="line">bar( 2 );</span><br><span class="line">console.log( obj1.a ); // 2</span><br><span class="line">var baz = new bar(3);</span><br><span class="line">console.log( obj1.a ); // 2</span><br><span class="line">console.log( baz.a ); // 3</span><br></pre></td></tr></table></figure></p><p>出乎意料! bar 被硬绑定到 obj1 上，但是 new<br>修改为 3。相反，new 修改了硬绑定(到 obj1 的)调用 bar(..) 中的 this。因为使用了 new 绑定，我们得到了一个名字为 baz 的新对象，并且 baz.a 的值是 3。<br>ES5 中内置的 Function.prototype.bind(..) 更加复杂。下面是 MDN 提供的一种<br>bind(..) 实现<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">if (!Function.prototype.bind) &#123;</span><br><span class="line">  Function.prototype.bind = function(oThis) &#123;</span><br><span class="line">      if (typeof this !== &quot;function&quot;) &#123;</span><br><span class="line">        // 与 ECMAScript 5 最接近的</span><br><span class="line">        // 内部 IsCallable 函数</span><br><span class="line">          throw new TypeError(&quot;Function.prototype.bind - what is trying &quot; +&quot;to be bound is not callable&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      var aArgs = Array.prototype.slice.call( arguments, 1 ),</span><br><span class="line">          fToBind = this,</span><br><span class="line">          fNOP = function()&#123;&#125;,</span><br><span class="line">          fBound = function()&#123;</span><br><span class="line">            return fToBind.apply(</span><br><span class="line">              (</span><br><span class="line">                this instanceof fNOP &amp;&amp;</span><br><span class="line">                oThis ? this : oThis</span><br><span class="line">              ),</span><br><span class="line">             aArgs.concat(</span><br><span class="line">               Array.prototype.slice.call( arguments )</span><br><span class="line">             );</span><br><span class="line">          &#125;;</span><br><span class="line">      fNOP.prototype = this.prototype;</span><br><span class="line">      fBound.prototype = new fNOP();</span><br><span class="line">      return fBound;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>这种 bind(..) 是一种 polyfill 代码(polyfill 就是我们常说的刮墙用的腻 子，polyfill 代码主要用于旧浏览器的兼容，比如说在旧的浏览器中并没 有内置 bind 函数，因此可以使用 polyfill 代码在旧浏览器中实现新的功 能)，对于 new 使用的硬绑定函数来说，这段 polyfill 代码和 ES5 内置的 bind(..) 函数并不完全相同(后面会介绍为什么要在 new 中使用硬绑定函 数)。由于 polyfill 并不是内置函数，所以无法创建一个不包含 .prototype 的函数，因此会具有一些副作用。如果你要在 new 中使用硬绑定函数并且依 赖 polyfill 代码的话，一定要非常小心。</p></blockquote><p>###绑定例外</p><p>####1.把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind<br>看下面代码<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line">var a = 2;</span><br><span class="line">foo.call( null ); // 2</span><br></pre></td></tr></table></figure></p><p>应用场景<br>使用 apply(..) 来“展开”一个数组<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function foo(a,b) &#123;</span><br><span class="line">  console.log( &quot;a:&quot; + a + &quot;, b:&quot; + b );</span><br><span class="line">&#125;</span><br><span class="line">// 把数组“展开”成参数</span><br><span class="line">foo.apply( null, [2, 3] ); // a:2, b:3</span><br><span class="line">// 使用 bind(..) 进行柯里化</span><br><span class="line">var bar = foo.bind( null, 2 );</span><br><span class="line">bar( 3 ); // a:2, b:3</span><br></pre></td></tr></table></figure></p><p>####2.间接引用<br>另一个需要注意的是，你有可能(有意或者无意地)创建一个函数的“间接引用”，在这 种情况下，调用这个函数会应用默认绑定规则。</p><p>间接引用最容易在赋值时发生:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line">var a = 2;</span><br><span class="line">var o = &#123;</span><br><span class="line">          a: 3,</span><br><span class="line">          foo: foo</span><br><span class="line">        &#125;;</span><br><span class="line">var p = &#123; a: 4 &#125;;</span><br><span class="line">o.foo(); // 3</span><br><span class="line">(p.foo = o.foo)(); // 2</span><br></pre></td></tr></table></figure></p><p>赋值表达式 p.foo = o.foo 的返回值是目标函数的引用，因此调用位置是 foo() 而不是 p.foo() 或者 o.foo()。根据我们之前说过的，这里会应用默认绑定。<br>注意:对于默认绑定来说，决定 this 绑定对象的并不是调用位置是否处于严格模式，而是 函数体是否处于严格模式。如果函数体处于严格模式，this 会被绑定到 undefined，否则 this 会被绑定到全局对象。</p><p>####3.软绑定<br>之前我们已经看到过，硬绑定这种方式可以把 this 强制绑定到指定的对象(除了使用 new 时)，防止函数调用应用默认绑定规则。问题在于，硬绑定会大大降低函数的灵活性，使 用硬绑定之后就无法使用隐式绑定或者显式绑定来修改 this。<br>如果可以给默认绑定指定一个全局对象和 undefined 以外的值，那就可以实现和硬绑定相 同的效果，同时保留隐式绑定或者显式绑定修改 this 的能力。<br>可以通过一种被称为软绑定的方法来实现我们想要的效果:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if (!Function.prototype.softBind) &#123;</span><br><span class="line">  Function.prototype.softBind = function(obj) &#123;</span><br><span class="line">      var fn = this;</span><br><span class="line">      // 捕获所有 curried 参数</span><br><span class="line">      var curried = [].slice.call( arguments, 1 );</span><br><span class="line">      var bound = function() &#123;</span><br><span class="line">          return fn.apply(</span><br><span class="line">          (!this || this === (window || global)) ? obj : this;</span><br><span class="line">          curried.concat.apply( curried, arguments );</span><br><span class="line">      &#125;;</span><br><span class="line">      bound.prototype = Object.create( fn.prototype );</span><br><span class="line">      return bound;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">除了软绑定之外，softBind(..) 的其他原理和 ES5 内置的 bind(..) 类似。它会对指定的函 数进行封装，首先检查调用时的 this，如果 this 绑定到全局对象或者 undefined，那就把 指定的默认对象 obj 绑定到 this，否则不会修改 this。此外，这段代码还支持可选的柯里化</span><br></pre></td></tr></table></figure></p><p>下面我们看看 softBind 是否实现了软绑定功能:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(&quot;name: &quot; + this.name);</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123; name: &quot;obj&quot; &#125;,</span><br><span class="line">    obj2 = &#123; name: &quot;obj2&quot; &#125;,</span><br><span class="line">    obj3 = &#123; name: &quot;obj3&quot; &#125;;</span><br><span class="line">var fooOBJ = foo.softBind( obj );</span><br><span class="line">    fooOBJ(); // name: obj</span><br><span class="line">    obj2.foo = foo.softBind(obj);</span><br><span class="line">    obj2.foo(); // name: obj2 &lt;---- 看!!!</span><br><span class="line">    fooOBJ.call( obj3 ); // name: obj3 &lt;---- 看!</span><br><span class="line">    setTimeout( obj2.foo, 10 );</span><br><span class="line">    // name: obj &lt;---- 应用了软绑定</span><br></pre></td></tr></table></figure></p><p>可以看到，软绑定版本的 foo() 可以手动将 this 绑定到 obj2 或者 obj3 上，但如果应用默<br>认绑定，则会将 this 绑定到 obj。</p><p>###this词法<br><strong>（箭头函数没有执行上下为this指向父级）箭头函数不使用 this 的四种标准规则，而是根据外层(函数或者全局)作用域来决定 this</strong><br>看下面的代码<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">// 返回一个箭头函数</span><br><span class="line">  return (a) =&gt; &#123;</span><br><span class="line">  //this 继承自 foo()</span><br><span class="line">    console.log( this.a );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var obj1 = &#123;</span><br><span class="line">  a:2</span><br><span class="line">&#125;;</span><br><span class="line">var obj2 = &#123;</span><br><span class="line">  a:3</span><br><span class="line">&#125;;</span><br><span class="line">var bar = foo.call( obj1 );</span><br><span class="line">bar.call( obj2 ); // 2, 不是 3 !</span><br></pre></td></tr></table></figure></p><p>箭头函数最常用于回调函数中，例如事件处理器或者定时器:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    // 这里的 this 在此法上继承自 foo()</span><br><span class="line">    console.log( this.a );</span><br><span class="line">  &#125;,100);</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;</span><br><span class="line">      a:2</span><br><span class="line">     &#125;;</span><br><span class="line">foo.call( obj ); // 2</span><br></pre></td></tr></table></figure></p><p>上面代码不用箭头函数的写法<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">var self = this; // lexical capture of this</span><br><span class="line">  setTimeout( function()&#123;</span><br><span class="line">     console.log( self.a );</span><br><span class="line">  &#125;, 100 );</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;</span><br><span class="line">  a: 2</span><br><span class="line">&#125;;</span><br><span class="line">foo.call( obj ); // 2</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> javaScript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> this </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaScript的call,apply,bind</title>
      <link href="/2016/08/25/javaScript/call/"/>
      <url>/2016/08/25/javaScript/call/</url>
      
        <content type="html"><![CDATA[<p>1、方法定义<br>call方法:<br>语法：call([thisObj[,arg1[, arg2[,   [,.argN]]]]])<br>定义：调用一个对象的一个方法，以另一个对象替换当前对象。<br>说明：<br>call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。<br>如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。</p><p>apply方法：<br>语法：apply([thisObj[,argArray]])<br>定义：应用某一对象的一个方法，用另一个对象替换当前对象。<br>说明：<br>如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。<br>如果没有提供 argArray 和 thisObj 任何一个参数，那么 Global 对象将被用作 thisObj， 并且无法被传递任何参数</p><p>bind方法：<br>语法：bind([thisObj[,arg1[,arg2[,[,.argN]]]]])<br>bind()方法会创建一个新的函数，称为绑定函数,fun方法在this环境下调用</p><p>该方法可传入两个参数，第一个参数作为this，第二个及以后的参数则作为函数的参数调用</p>]]></content>
      
      
      <categories>
          
          <category> javaScript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> call </tag>
            
            <tag> apply </tag>
            
            <tag> bind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端事件——Touch事件</title>
      <link href="/2016/08/25/javaScript/touch/"/>
      <url>/2016/08/25/javaScript/touch/</url>
      
        <content type="html"><![CDATA[<h2 id="Touch事件"><a href="#Touch事件" class="headerlink" title="Touch事件"></a>Touch事件</h2><h4 id="触摸事件包含4个接口"><a href="#触摸事件包含4个接口" class="headerlink" title="触摸事件包含4个接口"></a>触摸事件包含4个接口</h4><p><strong>TouchEvent</strong><br>代表当触摸行为在平面上变化的时候发生的事件.</p><p><strong>Touch</strong><br>代表用户与触摸平面间的一个接触点.</p><p><strong>TouchList</strong><br>代表一系列的Touch; 一般在用户多个手指同时接触触控平面时使用这个接口.</p><p><strong>DocumentTouch</strong><br>DocumentTouch 接口提供了一个便利的方法来创建 Touch 和 TouchList 对象, 可是它将被移除。 但这个方法将会继续在Document 接口中存在.</p><h3 id="TouchEvent"><a href="#TouchEvent" class="headerlink" title="TouchEvent"></a>TouchEvent</h3><p>TouchEvent 是一类描述手指在触摸平面（触摸屏、触摸板等）的状态变化的事件。这类事件用于描述一个或多个触点，使开发者可以检测触点的移动，触点的增加和减少，等等。</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>TouchEvent()<br>创建一个TouchEvent对象。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var event = new TouchEvent(typeArg, touchEventInit);</span><br></pre></td></tr></table></figure></p><p>typeArg</p><p>用字符串来代表事件的名称。</p><p>touchEventInit</p><p>是一个TouchEventInit 字典，它拥有以下属性：</p><ul><li><p>“touches”,可选的,默认为[],    TouchList类型（包含了一系列Touch对象的数组），当前位于屏幕上的所有手指的列表。</p></li><li><p>“targetTouches”,与touches类似，但是增加了个过滤条件，要与第一个手指点的地方（同一个节点内）相同。</p></li><li><p>“changedTouches”,可选的,默认为[],在<strong>touchstart</strong>中：列出在此次事件中新增加的触点。如果同时放下一根或两根手指，那么将与touches相同，但如果先放一根，在放第二根，那就会不同。在<strong>touchmove</strong>中：列出和上一次事件相比较，发生了变化的触点。在<strong>touchend</strong>中：列出离开触摸平面的触点（这些触点对应已经不接触触摸平面的手指）。</p></li><li><p>“ctrlKey”, 可选的,默认为false,布尔类型,表明按下了ctrl键。</p></li><li><p>“shiftKey”,可选的,默认为false,布尔类型,表明按下了shift键。</p></li><li><p>“altKey”,可选的,默认为false,布尔类型,表明按下了alt键。</p></li><li><p>“metaKey”,可选的,默认为false,布尔型,表明按下了meta键。</p></li></ul><h4 id="属性列表"><a href="#属性列表" class="headerlink" title="属性列表"></a>属性列表</h4><p><strong>TouchEvnt.altKey 只读</strong><br>布尔值，指明触摸事件触发时，键盘 alt 键是否被按下。</p><p><strong>TouchEvent.changedTouches 只读</strong><br>一个 TouchList 对象，包含了代表所有从上一次触摸事件到此次事件过程中，状态发生了改变的触点的 Touch 对象。</p><p><strong> TouchEvent.ctrlKey 只读</strong><br>布尔值，指明触摸事件触发时，键盘 ctrl 键是否被按下。</p><p><strong> TouchEvent.metaKey 只读</strong><br>布尔值，指明触摸事件触发时，键盘 meta 键 （Wikipedia - meta Key）是否被按下。</p><p><strong> TouchEvent.shiftKey 只读</strong><br>布尔值，指明触摸事件触发时，键盘 shift 键是否被按下。</p><p><strong> TouchEvent.targetTouches 只读</strong><br>一个 TouchList 对象，是包含了如下触点的 Touch 对象：触摸起始于当前事件的目标 element 上，并且仍然没有离开触摸平面的触点。</p><p><strong> TouchEvent.touches 只读</strong><br>一 个 TouchList 对象，包含了所有当前接触触摸平面的触点的 Touch 对象，无论它们的起始于哪个 element 上，也无论它们状态是否发生了变化。</p><h4 id="触摸事件的类型-（基本事件）"><a href="#触摸事件的类型-（基本事件）" class="headerlink" title="触摸事件的类型 （基本事件）"></a>触摸事件的类型 （基本事件）</h4><p>为了区别触摸相关的状态改变，存在多种类型的触摸事</p><blockquote><p>注意: 在很多情况下，触摸事件和鼠标事件会同时被触发（目的是让没有对触摸设备优化的代码仍然可以在触摸设备上正常工作）。如果你使用了触摸事件，可以调用 event.preventDefault() 来阻止鼠标事件被触发。</p></blockquote><p><strong>touchstart</strong>：当手指放在屏幕上触发  </p><p>当用户在触摸平面上放置了一个触点时触发。事件的目标 element 将是触点位置上的那个目标 element</p><p><strong>touchmove</strong>：当手指在屏幕上滑动时，连续地触发</p><p>当用户在触摸平面上移动触点时触发。事件的目标 element 和这个 touchmove 事件对应的 touchstart 事件的目标 element 相同，哪怕当 touchmove 事件触发时，触点已经移出了该 element 。</p><p>当触点的半径、旋转角度以及压力大小发生变化时，也将触发此事件。</p><blockquote><p>注意: 不同浏览器上 touchmove 事件的触发频率并不相同。这个触发频率还和硬件设备的性能有关。因此决不能让程序的运作依赖于某个特定的触发频率</p></blockquote><p><strong>touchend</strong>：当手指从屏幕上离开时触发</p><p>当一个触点被用户从触摸平面上移除（当用户将一个手指离开触摸平面）时触发。当触点移出触摸平面的边界时也将触发。例如用户将手指划出屏幕边缘。</p><p>事件的目标 element 和这个 touchend 事件对应的 touchstart 事件的目标 element 相同，哪怕 touchend 事件触发时，触点已经移出了该 element 。</p><p>已经被从触摸平面上移除的触点，可以在 changedTouches 属性定义的 TouchList 中找到。</p><p><strong>touchcancel</strong>：当系统停止跟踪时触发;该事件暂时使用不到  </p><p>当触点由于某些原因被中断时触发。有几种可能的原因如下（具体的原因根据不同的设备和浏览器有所不同）：</p><ul><li>由于某个事件取消了触摸：例如触摸过程被一个模态的弹出框打断。</li><li>触点离开了文档窗口，而进入了浏览器的界面元素、插件或者其他外部内容区域。</li><li>当用户产生的触点个数超过了设备支持的个数，从而导致 TouchList 中最早的 Touch 对象被取消。</li></ul><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">var EventUtil = &#123;</span><br><span class="line">    addHandler: function(element,type,handler) &#123;</span><br><span class="line">        if(element.addEventListener) &#123;</span><br><span class="line">            element.addEventListener(type,handler,false);</span><br><span class="line">        &#125;else if(element.attachEvent) &#123;</span><br><span class="line">            element.attachEvent(&quot;on&quot;+type,handler);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            element[&quot;on&quot; +type] = handler;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    removeHandler: function(element,type,handler)&#123;</span><br><span class="line">        if(element.removeEventListener) &#123;</span><br><span class="line">            element.removeEventListener(type,handler,false);</span><br><span class="line">        &#125;else if(element.detachEvent) &#123;</span><br><span class="line">            element.detachEvent(&quot;on&quot;+type,handler);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            element[&quot;on&quot; +type] = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var touch = document.getElementById(&quot;touch&quot;);</span><br><span class="line"></span><br><span class="line">//当手指接触屏幕时触发;</span><br><span class="line">EventUtil.addHandler(touch,&quot;touchstart&quot;,function(event)&#123;</span><br><span class="line">    console.log(event);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">// 连续滑动触发</span><br><span class="line">EventUtil.addHandler(window,&quot;touchmove&quot;,function(event)&#123;</span><br><span class="line">    alert(&apos;move&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">//当手指从屏幕上离开时触发;</span><br><span class="line">EventUtil.addHandler(window,&quot;touchend&quot;,function(event)&#123;</span><br><span class="line">    alert(&apos;end&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Touch"><a href="#Touch" class="headerlink" title="Touch"></a>Touch</h3><p>Touch对象表示在触控设备上的触摸点。通常是指手指或者触控笔在触屏设备或者触摸板上的操作。</p><p>对象属性 Touch.radiusX, Touch.radiusY, 和 Touch.rotationAngle 表示用户触摸操作所作用的区域，即触摸区域。这些属性对于处理类似于手指触摸之类的不精确操作很有帮助。这些属性可以表示出一个尽可能匹配触控区域的椭圆形（例如用户的指尖触控）。</p><blockquote><p>注意: 以下很多属性的值需要依赖硬件设备去获取，例如，如果设备本身不支持侦测压感，那么 force 属性的值将始终是0，对于 radiusX 和 radiusY 来说同样可能有这种情况，如果设备认为触点只是一个点而不是一个面, 它们始终为1。</p></blockquote><h4 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h4><p>Touch()<br>创建一个Touch对象。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var touch = new Touch(touchInit);</span><br></pre></td></tr></table></figure><p>touchInit</p><p>是一个TouchInit 字典，它拥有以下属性：</p><ul><li><p>“identifier”, 必须，是一个长整型，表示一个触摸点的数字标记。</p></li><li><p>“target”, 必须, 是 EventTarget类型，表示在触摸点开始接触接触面时的节点。</p></li><li><p>“clientX”, 可选，默认为0，为双精度浮点数类型,表示触摸在浏览器视口的横轴坐标，不包括滚动条的偏移距离。</p></li><li><p>“clientY”, 可选，默认为0，为双精度浮点数类型,表示触摸在浏览器视口的横轴坐标，不包括滚动条的偏移距离。</p></li><li><p>“screenX”, 可选，默认为0，为双精度浮点数类型,表示以用户屏幕为基准的，触摸点横坐标。</p></li><li><p>“screenY”, 可选，默认为0，为双精度浮点数类型,表示以用户屏幕为基准的，触摸点纵坐标。</p></li><li><p>“pageX”,可选，默认为0，为双精度浮点数类型,表示触摸在用户屏幕的横轴坐标，包括滚动条的偏移距离。</p></li><li><p>“pageY”, 可选，默认为0，为双精度浮点数类型,表示触摸在用户屏幕的纵轴坐标，包括滚动条的偏移距离。</p></li><li><p>“radiusX”, 可选，默认为0，为浮点数类型。表示接触面（比如手指，触控笔）接触形成的椭圆，在rotationAngle角度下横轴上形成的椭圆半径。和screenX使用的CSS像素保持同一个缩放大小。这个值不能为负。</p></li><li><p>“radiusY”, 可选，默认为0，为浮点数类型。表示接触面（比如手指，触控笔）接触形成的椭圆，在rotationAngle角度下纵轴上形成的椭圆半径。和screenY使用的CSS像素保持同一个缩放大小。这个值不能为负。</p></li><li><p>“force”,可选，默认为0，为浮点数类型。表示触摸体对触摸面的压力值。范围为从0到1：0表示压力为零，1表示设备能承受的最大压力敏感值。对压力的敏感值变动范围根据不同环境变动比较大。</p></li><li><p>“rotationAngle”, 可选，默认为0，为浮点数类型。表示由 radiusX 和 radiusY决定的椭圆在顺时针方向相对其中心偏转的角度。这个值介于0到90度之间。如果由 radiusX 和 radiusY决定的椭圆是一个标准圆形，则rotationAngle没有任何效用。用户设备可能用0表示这种标准圆形的情况，或者用其他符合要求范围的值来表示（比如，用户设备可能用上一次的触摸事件rotationAngle值，来避免突然变动）。</p></li></ul><p>​</p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>以下属性描述了用户的触摸行为</p><p><strong>Touch.identifier</strong><br>此 Touch 对象的唯一标识符. 一次触摸动作(我们值的是手指的触摸)在平面上移动的整个过程中, 该标识符不变. 可以根据它来判断跟踪的是否是同一次触摸过程. <strong>只读属性.</strong></p><p><strong>Touch.screenX</strong><br>触点相对于屏幕左边沿的的X坐标. <strong>只读属性.</strong></p><p><strong>Touch.screenY</strong><br>触点相对于屏幕上边沿的的Y坐标. <strong>只读属性.</strong></p><p><strong>Touch.clientX</strong><br>触点相对于可见视区(visual viewport)左边沿的的X坐标. 不包括任何滚动偏移. <strong>只读属性.</strong></p><p><strong>Touch.clientY</strong><br>触点相对于可见视区(visual viewport)上边沿的的Y坐标. 不包括任何滚动偏移. <strong>只读属性.</strong></p><p><strong>Touch.pageX</strong><br>触点相对于HTML文档左边沿的的X坐标. 当存在水平滚动的偏移时, 这个值包含了水平滚动的偏移. <strong>只读属性.</strong></p><p><strong>Touch.pageY</strong><br>触点相对于HTML文档上边沿的的Y坐标. 当存在水平滚动的偏移时, 这个值包含了垂直滚动的偏移. <strong>只读属性.</strong></p><p><strong>Touch.radiusX</strong><br>能够包围用户和触摸平面的接触面的最小椭圆的水平轴(X轴)半径. 这个值的单位和 screenX 相同. <strong>只读属性.</strong></p><p><strong>Touch.radiusY</strong><br>能够包围用户和触摸平面的接触面的最小椭圆的垂直轴(Y轴)半径. 这个值的单位和 screenY 相同. <strong>只读属性.</strong></p><p><strong>Touch.rotationAngle</strong><br>它是这样一个角度值：由radiusX 和 radiusY 描述的正方向的椭圆，需要通过顺时针旋转这个角度值，才能最精确地覆盖住用户和触摸平面的接触面. <strong>只读属性.</strong></p><p><strong>Touch.force</strong><br>手指挤压触摸平面的压力大小, 从0.0(没有压力)到1.0(最大压力)的浮点数. <strong>只读属性.</strong></p><p><strong>Touch.target</strong><br>当这个触点最开始被跟踪时(在 touchstart 事件中), 触点位于的HTML元素. 哪怕在触点移动过程中, 触点的位置已经离开了这个元素的有效交互区域, 或者这个元素已经被从文档中移除. 需要注意的是, 如果这个元素在触摸过程中被移除, 这个事件仍然会指向它, 但是不会再冒泡这个事件到 window 或 document 对象. 因此, 如果有元素在触摸过程中可能被移除, 最佳实践是将触摸事件的监听器绑定到这个元素本身, 防止元素被移除后, 无法再从它的上一级元素上侦测到从该元素冒泡的事件. <strong>只读属性.</strong></p><h4 id="接触面"><a href="#接触面" class="headerlink" title="接触面"></a>接触面</h4><p>Touch.radiusX, Touch.radiusY, 和 Touch.rotationAngle 描述了用户和触摸平面的接触面. 这在面向非精确触摸设备(由手指直接操作的触摸屏)开发时非常有用. 这些值描述了一个尽可能接近实际接触面(例如用户的指尖)的椭圆.</p><h3 id="TouchList"><a href="#TouchList" class="headerlink" title="TouchList"></a>TouchList</h3><p>一个 TouchList 代表一个触摸平面上所有触点的列表; 举例来讲, 如果一个用户用三根手指接触屏幕(或者触控板), 与之相关的TouchList 对于每根手指都会生成一个 Touch 对象, 共计三个.</p><h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><p><strong>TouchList.length</strong><br>返回TouchList中 Touch 对象的数量. <strong>只读属性.</strong></p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p><strong>TouchList.identifiedTouch()</strong><br>列表中标示符与指定值匹配的第一个Touch 对象会被返回.</p><p><strong>TouchList.item()</strong><br>返回列表中以指定值作为索引的 Touch 对象. 你也可以使用数组的语法来引用TouchList(touchList[x]).</p><h3 id="DocumentTouch-已废弃"><a href="#DocumentTouch-已废弃" class="headerlink" title="DocumentTouch (已废弃)"></a>DocumentTouch (已废弃)</h3><p>DocumentTouch 接口提供了一个便利的方法来创建 Touch 和 TouchList 对象, 可是它将被移除。 但这个方法将会继续在Document 接口中存在.</p><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><p><strong>DocumentTouch.createTouch()</strong><br>创建一个新的 Touch 对象.</p><p><strong>DocumentTouch.createTouchList()</strong><br>创建一个新的 TouchList 对象.</p><h4 id="手势事件"><a href="#手势事件" class="headerlink" title="手势事件"></a>手势事件</h4><ul><li>gesturestart：当一个手指已经按在屏幕上，而另一个手指又触摸在屏幕时触发。     </li><li>gesturechange：当触摸屏幕的任何一个手指的位置发生变化时触发。   </li><li>gestureend：当任何一个手指从屏幕上面移开时触发。</li></ul><blockquote><p>【注意】只有两个手指都触摸到事件的接收容器时才触发这些手势事件。</p></blockquote><h4 id="触摸事件与手势事件之间的关系"><a href="#触摸事件与手势事件之间的关系" class="headerlink" title="触摸事件与手势事件之间的关系"></a>触摸事件与手势事件之间的关系</h4><p>1、当一个手指放在屏幕上时，会触发touchstart事件，如果另一个手指又放在了屏幕上，则会触发gesturestart事件，随后触发基于该手指的touchstart事件。</p><p>2、如果一个或两个手指在屏幕上滑动，将会触发gesturechange事件，但只要有一个手指移开，则会触发gestureend事件，紧接着又会触发toucheend事件。     </p><h4 id="手势的专有属性"><a href="#手势的专有属性" class="headerlink" title="手势的专有属性"></a>手势的专有属性</h4><ul><li>rotation：表示手指变化引起的旋转角度，负值表示逆时针，正值表示顺时针，从零开始。  </li><li>scale：表示两个手指之间的距离情况，向内收缩会缩短距离，这个值从1开始，并随距离拉大而增长。    </li></ul><p><strong>示例</strong><br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function handleGestureEvent(event) &#123;</span><br><span class="line">    var output = document.getElementById(&quot;output&quot;);</span><br><span class="line">    switch(event.type) &#123;</span><br><span class="line">        case &quot;gesturestart&quot;:</span><br><span class="line">            output.innerHTML = &quot;Gesture started (rotation=&quot; + event.ratation +&quot;,scale=&quot; + event.scale + &quot;)&quot;;</span><br><span class="line">            break;</span><br><span class="line">        case &quot;gestureend&quot;:</span><br><span class="line">            output.innerHTML += &quot;&lt;br&gt;Gesture ended (rotation+&quot; + event.rotation + &quot;,scale=&quot; + event.scale + &quot;)&quot;;</span><br><span class="line">            break;</span><br><span class="line">        case &quot;gesturechange&quot;:</span><br><span class="line">            output.innerHTML += &quot;&lt;br&gt;Gesture changed (rotation+=&quot; + event.rotation + &quot;,scale+&quot; + event.scale + &quot;)&quot;;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">document.addEventListener(&quot;gesturestart&quot;, handleGestureEvent, false);</span><br><span class="line">document.addEventListener(&quot;gestureend&quot;, handleGestureEvent, false);</span><br><span class="line">document.addEventListener(&quot;gesturechange&quot;, handleGestureEvent, false);</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p><strong>触摸事件</strong></p><ul><li>touchstart<br>当手指放在屏幕上触发。     </li><li>touchmove<br>当手指在屏幕上滑动时，连续地触发。    </li><li>touchend<br>当手指从屏幕上离开时触发。    </li><li>touchcancel<br>当系统停止跟踪时触发，系统什么时候取消，文档没有明确的说明。    </li></ul></li><li><p><strong>除了常用的DOM属性，触摸事件还包含下列三个用于跟踪触摸的属性</strong></p><ul><li><p>touches：表示当前跟踪的触摸操作的touch对象的数组。<br>当一个手指在触屏上时，event.touches.length=1,<br>当两个手指在触屏上时，event.touches.length=2，以此类推。</p></li><li><p>targetTouches：特定于事件目标的touch对象数组。<br>因为touch事件是会冒泡的，所以利用这个属性指出目标对象。</p></li><li><p>changedTouches：表示自上次触摸以来发生了什么改变的touch对象的数组。    </p></li><li><p>每个touch对象都包含下列几个属性：<br>clientX：触摸目标在视口中的x坐标。<br>clientY：触摸目标在视口中的y坐标。<br>identifier：标识触摸的唯一ID。<br>pageX：触摸目标在页面中的x坐标。<br>pageY：触摸目标在页面中的y坐标。<br>screenX：触摸目标在屏幕中的x坐标。<br>screenY：触摸目标在屏幕中的y坐标。<br>target：触摸的DOM节点目标。     </p></li></ul></li></ul><p>参考链接 ：<br>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Touch_events" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Touch_events</a><br>    <a href="https://segmentfault.com/a/1190000005609334" target="_blank" rel="noopener">https://segmentfault.com/a/1190000005609334</a><br>    <a href="http://www.jianshu.com/p/832f36531df9" target="_blank" rel="noopener">http://www.jianshu.com/p/832f36531df9</a><br>    <a href="http://web.jobbole.com/85132/" target="_blank" rel="noopener">http://web.jobbole.com/85132/</a></p>]]></content>
      
      
      <categories>
          
          <category> javaScript应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> touch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sublime快捷键总结</title>
      <link href="/2016/08/25/IDE/sublime/sublimeKey/"/>
      <url>/2016/08/25/IDE/sublime/sublimeKey/</url>
      
        <content type="html"><![CDATA[<h1 id="sublime-快捷键"><a href="#sublime-快捷键" class="headerlink" title="sublime 快捷键"></a>sublime 快捷键</h1><h6 id="大致比较全的快捷键网址：http-jinguoxing-github-io-sublime-mac-2015-07-02-sublime-mac-keys-有一些我认为用不到，在此我将常用的几个快捷键单独整理一下："><a href="#大致比较全的快捷键网址：http-jinguoxing-github-io-sublime-mac-2015-07-02-sublime-mac-keys-有一些我认为用不到，在此我将常用的几个快捷键单独整理一下：" class="headerlink" title="大致比较全的快捷键网址：http://jinguoxing.github.io/sublime/mac/2015/07/02/sublime-mac-keys/有一些我认为用不到，在此我将常用的几个快捷键单独整理一下："></a>大致比较全的快捷键网址：<a href="http://jinguoxing.github.io/sublime/mac/2015/07/02/sublime-mac-keys/有一些我认为用不到，在此我将常用的几个快捷键单独整理一下：" target="_blank" rel="noopener">http://jinguoxing.github.io/sublime/mac/2015/07/02/sublime-mac-keys/有一些我认为用不到，在此我将常用的几个快捷键单独整理一下：</a></h6><p><strong>1.)⌘（command）+d</strong></p><p>  选词（反复按快捷键，即可继续向下同时选中下一个相同的文本进行同时编辑）</p><p><strong>2.)⌘（command）+P</strong></p><p>  搜索项目中的文件   </p><ol><li>输入当前项目中的文件名，快速搜索文件，</li><li>输入@和关键字，查找文件中函数名，</li><li>输入：和数字，跳转到文件中该行代码，</li><li>输入#和关键字，查找变量名。</li><li>(⌘（command）+t)与 ⌘（command）+P 作用一样</li></ol><p><strong>3.) ⌘（command）+ W</strong></p><p>  关闭当前打开文件</p><p><strong>4.)  ⌘（command）+X</strong></p><p>  剪切</p><p><strong>5.)  ⌘（command）+L</strong></p><p>  选择行，重复可依次增加选择下一行<br>  效果和 Shift+↓ 效果一样</p><p><strong>6.) ⌘（command）+O</strong></p><p>  打开文件</p><p><strong>7.)⌘（command) +F</strong></p><p>  查找内容</p><p><strong>8.)⌘（command) +Shift+F</strong></p><p>  查找并替换</p><p><strong>9.)⌘（command) +N</strong></p><p>  新建窗口</p><p><strong>10.)⌘（command) +数字</strong></p><p>  窗口切换</p><p><strong>11.)⌘（command) +K+B</strong></p><p>  开关侧栏</p><p><strong>12.)⌘（command) + /</strong></p><p>  注释当前行 (单行注释)</p><p><strong>13.)alt+ ⌘（command)+/</strong></p><p>  当前位置插入注释(多行注释)</p><p><strong>14.)按 ⌘（command)键 </strong></p><p>  依次点击或选取，可需要编辑的多个位置</p><p><strong>15.)⌘（command）+M</strong></p><p>  最小化窗口</p><p><strong>16.)</strong></p><pre><code>1. ⌘（command) + option +2  分成两屏  2. ⌘（command) + option +1  1屏3. ⌘（command) + option +5  等分四屏  </code></pre><p><strong>17.)⌘（command) + delelte</strong></p><p>  删除光标前所有字符  </p><p><strong>18.)cmd + [或 cmd + ]</strong></p><p>  智能行缩进</p><p><strong>19.) CMD+CTRL+↓或CMD+CTRL+↑</strong></p><p>  上下移动当前行。(换位置)</p><p><strong>20.) Ctrl+Shift+K</strong></p><p>  删除整行</p><p><strong>21.)command+ k + u</strong></p><p>  转换大写(将这个词的所有字母转换)</p><p><strong>22.)command+ k + l</strong></p><p>  转换小写。</p><p><strong>23.)command+Shift+L </strong></p><p>  先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。</p><p><strong>24.)command+Enter </strong></p><p>  在下一行插入新行。举个例子：即使光标不在行尾，也能快速向下插入一行。</p><p><strong>25.)command+Shift+Enter</strong></p><p>  在上一行插入新行。举个例子：即使光标不在行首，也能快速向上插入一行.</p><p><strong>26.)command+K+0  </strong></p><p>  展开所有折叠代码。</p><p><strong>27.)</strong></p><ol><li>command+← 向左单位性地移动光标，快速移动光标。</li><li>command+→ 向右单位性地移动光标，快速移动光标。</li></ol><p><strong>28.)</strong></p><ol><li>shift+↑ 向上选中多行。</li><li>shift+↓ 向下选中多行。</li><li>Shift+← 向左选中文本。 (一个字符一个字符的增加选中，按住 shift键不放，一直点方向键)</li><li>Shift+→ 向右选中文本。</li></ol><p><strong>29.)</strong></p><ol><li>command+Shift+← 向左单位性地选中文本。 (单位性的我尝试后就是按一行选中，很方便)</li><li>command+Shift+→ 向右单位性地选中文本。</li></ol><p><strong>30.)选中多行：</strong></p><p>  光标开始处按住shift键不放，到要结束处放下光标</p><p><strong>31.)command+J</strong></p><p>  合并选中的多行代码为一行。举个例子：将多行格式的CSS属性合并为一行。</p><p><strong>32.)command+Shift+D</strong></p><p>  复制光标所在整行，插入到下一行。</p><p><strong>33.)</strong></p><ol><li>Tab 向右缩进。</li><li>Shift+Tab 向左缩进。</li></ol><p><strong>34.)command+K+K </strong></p><p>   从光标处开始删除代码至行尾。</p><p><strong>35.)</strong></p><ol><li>command+Z 撤销。</li><li>command+Y 恢复撤销。</li></ol><p><strong>36.)Esc</strong></p><p>   退出光标多行选择，退出搜索框，命令框等。</p><p><strong>37.)ctrl+`</strong></p><p>   打开控制台</p><p><strong>38.)command + o</strong></p><p>   弹出当前文件所在的文件夹位置</p><p><strong>39.)Ctrl＋Cmd＋G</strong></p><p>   选中所有同类名称，并可编辑</p><p><strong>40.)Cmd+D</strong></p><p>   只是单纯选中同类名称，不可编辑</p>]]></content>
      
      
      <categories>
          
          <category> IDE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDE </tag>
            
            <tag> 辅助工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js变量提升</title>
      <link href="/2016/08/25/javaScript/ascension/"/>
      <url>/2016/08/25/javaScript/ascension/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在JavaScript中存在提升的情况，这种提升有两种提升分别是变量提升与函数提升，而且是函数会首先被提升，然后才是变量。</p></blockquote><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>看下面的例子：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log( a ); //undefined。</span><br><span class="line">var a = 2;</span><br></pre></td></tr></table></figure><p>上面代码可以写成下面的形式</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a;</span><br><span class="line">console.log( a ); //undefined</span><br><span class="line">a=2;</span><br></pre></td></tr></table></figure><p>再看下面的例子：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a=2;</span><br><span class="line">console.log(a); //2</span><br></pre></td></tr></table></figure><p>上面的代码可以写成下面的形式：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a;</span><br><span class="line">a=2;</span><br><span class="line">console.log(a) //2</span><br></pre></td></tr></table></figure><h3 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h3><p>看下面的例子：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line">function foo() &#123;</span><br><span class="line">  console.log( a ); // undefined var a = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子可以转化成下面的形式</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log( a ); // undefined var a = 2;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>再看下面的例子：</p><h4 id="函数声明会被提升，但是函数表达式却不会被提升"><a href="#函数声明会被提升，但是函数表达式却不会被提升" class="headerlink" title="函数声明会被提升，但是函数表达式却不会被提升"></a>函数声明会被提升，但是函数表达式却不会被提升</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo(); // TypeError</span><br><span class="line">bar(); // ReferenceError</span><br><span class="line">var foo = function bar() &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的代码可以转化下面的代码<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var foo;</span><br><span class="line">foo(); // TypeError</span><br><span class="line">bar(); // ReferenceError</span><br><span class="line">foo = function() &#123;</span><br><span class="line">  var bar = foo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或者是转化成下面的代码<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var foo;</span><br><span class="line">foo(); // TypeError</span><br><span class="line">bar(); // ReferenceError</span><br><span class="line">foo = function() &#123;</span><br><span class="line">  var bar = ...self...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再看下面的例子<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">foo(); // 3</span><br><span class="line">function foo() &#123;</span><br><span class="line">  console.log( 1 );</span><br><span class="line">&#125;</span><br><span class="line">var foo = function() &#123;</span><br><span class="line">  console.log( 2 );</span><br><span class="line">&#125;;</span><br><span class="line">function foo() &#123;</span><br><span class="line">  console.log( 3 );</span><br><span class="line">&#125;</span><br><span class="line">foo(); //2</span><br></pre></td></tr></table></figure></p><p>上面的代码可以转化下面的代码<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var foo;</span><br><span class="line">function foo() &#123;</span><br><span class="line">  console.log( 1 );</span><br><span class="line">&#125;</span><br><span class="line">function foo() &#123;</span><br><span class="line">  console.log( 3 );</span><br><span class="line">&#125;</span><br><span class="line">foo(); // 3</span><br><span class="line">var foo = function() &#123;</span><br><span class="line">  console.log( 2 );</span><br><span class="line">&#125;;</span><br><span class="line">foo(); //2</span><br></pre></td></tr></table></figure></p><h5 id="非常有意思的现象"><a href="#非常有意思的现象" class="headerlink" title="非常有意思的现象"></a>非常有意思的现象</h5>]]></content>
      
      
      <categories>
          
          <category> javaScript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 变量提升 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaScript的arguments, caller, callee</title>
      <link href="/2016/08/25/javaScript/arguments/"/>
      <url>/2016/08/25/javaScript/arguments/</url>
      
        <content type="html"><![CDATA[<h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h3><p>arguments:  在函数调用时， 会自动在该函数内部生成一个名为 arguments的隐藏对象。 该对象类似于数组， 但又不是数组。可以使用[]操作符获取函数调用时传递的实参。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function testArg()  </span><br><span class="line">&#123;  </span><br><span class="line">    alert(&quot;real parameter count: &quot;+arguments.length);  </span><br><span class="line">    for(var i = 0; i &lt; arguments.length; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        alert(arguments[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要注意的是 argument 保存的实参的信息<br>arguments 不是一个数组,验证代码<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(function () &#123;  </span><br><span class="line">  alert(arguments instanceof Array); // false  </span><br><span class="line">  alert(typeof(arguments)); // object  </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><p>只有函数被调用时，arguments对象才会创建，未调用时其值为null：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(new Function().arguments);//return null</span><br></pre></td></tr></table></figure></p><p>arguments 的完整语法如下：<br>[function.]arguments[n]<br>参数function ：选项。当前正在执行的 Function 对象的名字。 n ：选项。要传递给 Function 对象的从0开始的参数值索引。</p><h3 id="caller"><a href="#caller" class="headerlink" title="caller"></a>caller</h3><p>在一个函数调用另一个函数时，被调用函数会自动生成一个caller属性，指向调用它的函数对象。如果该函数当前未被调用，或并非被其他函数调用，则caller为null。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function testCaller() &#123;  </span><br><span class="line">    var caller = testCaller.caller;  </span><br><span class="line">    console.log(caller);  </span><br><span class="line">&#125;  </span><br><span class="line">testCaller();  //null</span><br><span class="line">function aCaller() &#123;  </span><br><span class="line">    testCaller();  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">aCaller();  //function aCaller() &#123;testCaller();&#125;</span><br></pre></td></tr></table></figure></p><h3 id="callee"><a href="#callee" class="headerlink" title="callee"></a>callee</h3><p>当函数被调用时，它的arguments.callee对象就会指向自身，也就是一个对自己的引用。<br>由于arguments在函数被调用时才有效，因此arguments.callee在函数未调用时是不存在的（即null.callee），且解引用它会产生异常。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function aCallee(arg) &#123;  </span><br><span class="line">  console.log(arguments.callee);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">function aCaller(arg1, arg2) &#123;</span><br><span class="line">  aCallee();</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">aCaller();</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> javaScript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> arguments </tag>
            
            <tag> caller </tag>
            
            <tag> callee </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>柯里化函数</title>
      <link href="/2016/08/25/javaScript/Currying/"/>
      <url>/2016/08/25/javaScript/Currying/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在计算机科学中，柯里化（英语：Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。这个技术由 Christopher Strachey 以逻辑学家哈斯凯尔·加里命名的，尽管它是 Moses Schönfinkel 和 Gottlob Frege 发明的。</p></blockquote><h5 id="这是来自维基百科的名词解释。顾名思义，柯里化其实本身是固定一个可以预期的参数，并返回一个特定的函数，处理批特定的需求。这增加了函数的适用性，但同时也降低了函数的适用范围。"><a href="#这是来自维基百科的名词解释。顾名思义，柯里化其实本身是固定一个可以预期的参数，并返回一个特定的函数，处理批特定的需求。这增加了函数的适用性，但同时也降低了函数的适用范围。" class="headerlink" title="这是来自维基百科的名词解释。顾名思义，柯里化其实本身是固定一个可以预期的参数，并返回一个特定的函数，处理批特定的需求。这增加了函数的适用性，但同时也降低了函数的适用范围。"></a>这是来自维基百科的名词解释。顾名思义，柯里化其实本身是固定一个可以预期的参数，并返回一个特定的函数，处理批特定的需求。这增加了函数的适用性，但同时也降低了函数的适用范围。</h5><p>看一下通用实现：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function currying(fn) &#123;</span><br><span class="line">    var slice = Array.prototype.slice,</span><br><span class="line">    __args = slice.call(arguments, 1);</span><br><span class="line">    return function () &#123;</span><br><span class="line">        var __inargs = slice.call(arguments);</span><br><span class="line">        return fn.apply(null, __args.concat(__inargs));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="柯里化的实用性体现在很多方面："><a href="#柯里化的实用性体现在很多方面：" class="headerlink" title="柯里化的实用性体现在很多方面："></a>柯里化的实用性体现在很多方面：</h3><h5 id="1-提高适用性。"><a href="#1-提高适用性。" class="headerlink" title="1 提高适用性。"></a>1 提高适用性。</h5><blockquote><p>【通用函数】解决了兼容性问题，但同时也会再来，使用的不便利性，不同的应用场景往，要传递很多参数，以达到解决特定问题的目的。有时候应用中，同一种规则可能会反复使用，这就可能会造成代码的重复性。</p></blockquote><p>看下面一个例子：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function square(i) &#123;</span><br><span class="line">    return i * i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function dubble(i) &#123;</span><br><span class="line">    return i *= 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function map(handeler, list) &#123;</span><br><span class="line">    return list.map(handeler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 数组的每一项平方</span><br><span class="line">map(square, [1, 2, 3, 4, 5]);</span><br><span class="line">map(square, [6, 7, 8, 9, 10]);</span><br><span class="line">map(square, [10, 20, 30, 40, 50]);</span><br><span class="line">// ......</span><br><span class="line"></span><br><span class="line">// 数组的每一项加倍</span><br><span class="line">map(dubble, [1, 2, 3, 4, 5]);</span><br><span class="line">map(dubble, [6, 7, 8, 9, 10]);</span><br><span class="line">map(dubble, [10, 20, 30, 40, 50]);</span><br></pre></td></tr></table></figure><p>例子中，创建了一个map通用函数，用于适应不同的应用场景。显然，通用性不用怀疑。同时，例子中重复传入了相同的处理函数：square和dubble。</p><p>应用中这种可能会更多。当然，通用性的增强必然带来适用性的减弱。但是，我们依然可以在中间找到一种平衡。</p><p>看下面，我们利用柯里化改造一下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function square(i) &#123;</span><br><span class="line">    return i * i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function dubble(i) &#123;</span><br><span class="line">    return i *= 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function map(handeler, list) &#123;</span><br><span class="line">    return list.map(handeler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var mapSQ = currying(map, square);</span><br><span class="line">mapSQ([1, 2, 3, 4, 5]);</span><br><span class="line">mapSQ([6, 7, 8, 9, 10]);</span><br><span class="line">mapSQ([10, 20, 30, 40, 50]);</span><br><span class="line">// ......</span><br><span class="line"></span><br><span class="line">var mapDB = currying(map, dubble);</span><br><span class="line">mapDB([1, 2, 3, 4, 5]);</span><br><span class="line">mapDB([6, 7, 8, 9, 10]);</span><br><span class="line">mapDB([10, 20, 30, 40, 50]);</span><br><span class="line">// ......</span><br></pre></td></tr></table></figure><p>我们缩小了函数的适用范围，但同时提高函数的适性。当然，也有扩展函数适用范围的方法–反柯里化，留到下一篇再讨论。</p><p>由此，可知柯里化不仅仅是提高了代码的合理性，更重的它突出一种思想—降低适用范围，提高适用性。</p><p>下面再看一个例子，一个应用范围更广泛更熟悉的例子：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function Ajax() &#123;</span><br><span class="line">    this.xhr = new XMLHttpRequest();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Ajax.prototype.open = function(type, url, data, callback) &#123;</span><br><span class="line">    this.onload = function() &#123;</span><br><span class="line">        callback(this.xhr.responseText, this.xhr.status, this.xhr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.xhr.open(type, url, data.async);</span><br><span class="line">    this.xhr.send(data.paras);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&apos;get post&apos;.split(&apos; &apos;).forEach(function(mt) &#123;</span><br><span class="line">    Ajax.prototype[mt] = currying(Ajax.prototype.open, mt);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var xhr = new Ajax();</span><br><span class="line">xhr.get(&apos;/articles/list.php&apos;, &#123;&#125;,</span><br><span class="line">function(datas) &#123;</span><br><span class="line">    // done(datas)    </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var xhr1 = new Ajax();</span><br><span class="line">xhr1.post(&apos;/articles/add.php&apos;, &#123;&#125;,</span><br><span class="line">function(datas) &#123;</span><br><span class="line">    // done(datas)    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h5 id="2-延迟执行。"><a href="#2-延迟执行。" class="headerlink" title="2 延迟执行。"></a>2 延迟执行。</h5><p> 柯里化的另一个应用场景是延迟执行。不断的柯里化，累积传入的参数，最后执行。</p><p>看下面：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var add = function() &#123;</span><br><span class="line">    var _this = this,</span><br><span class="line">    _args = arguments</span><br><span class="line">    return function() &#123;</span><br><span class="line">        if (!arguments.length) &#123;</span><br><span class="line">            var sum = 0;</span><br><span class="line">            for (var i = 0,</span><br><span class="line">            c; c = _args[i++];) sum += c</span><br><span class="line">            return sum</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Array.prototype.push.apply(_args, arguments) return arguments.callee</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">add(1)(2)(3)(4)();//10</span><br></pre></td></tr></table></figure></p><p>通用的写法：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var curry = function(fn) &#123;</span><br><span class="line">    var _args = []</span><br><span class="line">    return function cb() &#123;</span><br><span class="line">        if (arguments.length == 0) &#123;</span><br><span class="line">            return fn.apply(this, _args)</span><br><span class="line">        &#125;</span><br><span class="line">        Array.prototype.push.apply(_args, arguments);</span><br><span class="line">        return cb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面累加的例子，可以实验一下怎么写？</p><h5 id="3-固定易变因素。"><a href="#3-固定易变因素。" class="headerlink" title="3 固定易变因素。"></a>3 固定易变因素。</h5><p>柯里化特性决定了它这应用场景。提前把易变因素，传参固定下来，生成一个更明确的应用函数。最典型的代表应用，是bind函数用以固定this这个易变对象。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind = function(context) &#123;</span><br><span class="line">    var _this = this,</span><br><span class="line">    _args = Array.prototype.slice.call(arguments, 1);</span><br><span class="line">    return function() &#123;</span><br><span class="line">        return _this.apply(context, _args.concat(Array.prototype.slice.call(arguments)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javaScript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 柯里化函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git命令总结</title>
      <link href="/2016/08/25/git/git/"/>
      <url>/2016/08/25/git/git/</url>
      
        <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h3 id="查看、添加、提交、删除、找回，重置修改文件"><a href="#查看、添加、提交、删除、找回，重置修改文件" class="headerlink" title="查看、添加、提交、删除、找回，重置修改文件"></a>查看、添加、提交、删除、找回，重置修改文件</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">git help &lt;command&gt; # 显示command的help</span><br><span class="line"></span><br><span class="line">git show # 显示某次提交的内容 git show $id</span><br><span class="line"></span><br><span class="line">#git checkout-- &lt;file&gt; # 抛弃工作区修改</span><br><span class="line"></span><br><span class="line">#git checkout. # 抛弃工作区修改</span><br><span class="line"></span><br><span class="line">git add &lt;file&gt; # 将工作文件修改提交到本地暂存区</span><br><span class="line"></span><br><span class="line">git add . # 将所有修改过的工作文件提交暂存区</span><br><span class="line"></span><br><span class="line">git rm &lt;file&gt; # 从版本库中删除文件</span><br><span class="line"></span><br><span class="line">git rm &lt;file&gt; --cached # 从版本库中删除文件，但不删除文件</span><br><span class="line"></span><br><span class="line">git reset &lt;file&gt; # 从暂存区恢复到工作文件</span><br><span class="line"></span><br><span class="line">git reset -- . # 从暂存区恢复到工作文件</span><br><span class="line"></span><br><span class="line">git reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改</span><br><span class="line"></span><br><span class="line">git commit &lt;file&gt; git commit . git commit -a # 将git add, git rm和git commit等操作都合并在一起做　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　git commit -am &quot;some comments&quot;</span><br><span class="line"></span><br><span class="line">git commit --amend # 修改最后一次提交记录</span><br><span class="line"></span><br><span class="line">git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建次提交对象</span><br><span class="line"></span><br><span class="line">git revert HEAD # 恢复最后一次提交的状态</span><br></pre></td></tr></table></figure><h3 id="查看文件diff"><a href="#查看文件diff" class="headerlink" title="查看文件diff"></a>查看文件diff</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git diff &lt;file&gt; # 比较当前文件和暂存区文件差异 git diff</span><br><span class="line"></span><br><span class="line">git diff &lt;id1&gt;&lt;id1&gt;&lt;id2&gt; # 比较两次提交之间的差异</span><br><span class="line"></span><br><span class="line">git diff &lt;branch1&gt;..&lt;branch2&gt; # 在两个分支之间比较</span><br><span class="line"></span><br><span class="line">git diff --staged # 比较暂存区和版本库差异</span><br><span class="line"></span><br><span class="line">git diff --cached # 比较暂存区和版本库差异</span><br><span class="line"></span><br><span class="line">git diff --stat # 仅仅比较统计信息</span><br></pre></td></tr></table></figure><h3 id="查看提交记录"><a href="#查看提交记录" class="headerlink" title="查看提交记录"></a>查看提交记录</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git log git log &lt;file&gt; # 查看该文件每次提交记录</span><br><span class="line"></span><br><span class="line">git log -p &lt;file&gt; # 查看每次详细修改内容的diff</span><br><span class="line"></span><br><span class="line">git log -p -2 # 查看最近两次详细修改内容的diff</span><br><span class="line"></span><br><span class="line">git log --stat #查看提交统计信息</span><br><span class="line"></span><br><span class="line">tig</span><br><span class="line"></span><br><span class="line">Mac上可以使用tig代替diff和log，brew install tig</span><br></pre></td></tr></table></figure><h3 id="Git-本地分支管理"><a href="#Git-本地分支管理" class="headerlink" title="Git 本地分支管理"></a>Git 本地分支管理</h3><p>查看、切换、创建和删除分支<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">git branch -r # 查看远程分支</span><br><span class="line"></span><br><span class="line">git branch &lt;new_branch&gt; # 创建新的分支</span><br><span class="line"></span><br><span class="line">git branch -v # 查看各个分支最后提交信息</span><br><span class="line"></span><br><span class="line">git branch --merged # 查看已经被合并到当前分支的分支</span><br><span class="line"></span><br><span class="line">git branch --no-merged # 查看尚未被合并到当前分支的分支</span><br><span class="line"></span><br><span class="line">git checkout&lt;branch&gt; # 切换到某个分支</span><br><span class="line"></span><br><span class="line">git checkout-b &lt;new_branch&gt; # </span><br><span class="line"></span><br><span class="line">git checkout-b &lt;new_branch&gt; &lt;branch&gt; # 基于branch创建新的new_branch</span><br><span class="line"></span><br><span class="line">git checkout$id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除</span><br><span class="line"></span><br><span class="line">git checkout$id -b &lt;new_branch&gt; # 把某次历史提交记录checkout出来，创建成一个分支</span><br><span class="line"></span><br><span class="line">git branch -d &lt;branch&gt; # 删除某个分支</span><br><span class="line"></span><br><span class="line">git branch -D &lt;branch&gt; # 强制删除某个分支 (未被合并的分支被删除的时候需要强制)</span><br></pre></td></tr></table></figure></p><h3 id="分支合并和rebase"><a href="#分支合并和rebase" class="headerlink" title="分支合并和rebase"></a>分支合并和rebase</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;branch&gt; # 将branch分支合并到当前分支</span><br><span class="line"></span><br><span class="line">git merge origin/master --no-ff # 不要Fast-Foward合并，这样可以生成merge提交</span><br><span class="line"></span><br><span class="line">git rebase master &lt;branch&gt; # 将master rebase到branch，相当于： git checkout&lt;branch&gt; &amp;&amp; git rebase master &amp;&amp; git checkoutmaster &amp;&amp; git merge &lt;branch&gt;</span><br><span class="line"></span><br><span class="line"> Git补丁管理(方便在多台机器上开发同步时用)</span><br><span class="line"></span><br><span class="line"># git diff &gt; ../sync.patch # 生成补丁</span><br><span class="line"></span><br><span class="line"># git apply ../sync.patch # 打补丁</span><br><span class="line"></span><br><span class="line"># git apply --check ../sync.patch #测试补丁能否成功</span><br></pre></td></tr></table></figure><h3 id="Git暂存管理"><a href="#Git暂存管理" class="headerlink" title="Git暂存管理"></a>Git暂存管理</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git stash # 暂存</span><br><span class="line"></span><br><span class="line">git stash list # 列所有stash</span><br><span class="line"></span><br><span class="line">git stash apply # 恢复暂存创建新的分支，并且切换过去的内容</span><br><span class="line"></span><br><span class="line">git stash drop # 删除暂存区</span><br></pre></td></tr></table></figure><h3 id="Git远程分支管理"><a href="#Git远程分支管理" class="headerlink" title="Git远程分支管理"></a>Git远程分支管理</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">git pull # 抓取远程仓库所有分支更新并合并到本地</span><br><span class="line"></span><br><span class="line">error：git pull --no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并</span><br><span class="line"></span><br><span class="line">git fetch origin # 抓取远程仓库更新</span><br><span class="line"></span><br><span class="line">git merge origin/master # 将远程主分支合并到本地当前分支</span><br><span class="line"></span><br><span class="line"># git checkout--track origin/branch # 跟踪某个远程分支创建相应的本地分支</span><br><span class="line"></span><br><span class="line">git checkout-b &lt;local_branch&gt; origin/&lt;remote_branch&gt; # 基于远程分支创建本地分支，功能同上</span><br><span class="line"></span><br><span class="line">git push # push所有分支</span><br><span class="line"></span><br><span class="line">git push origin master # 将本地主分支推到远程主分支</span><br><span class="line"></span><br><span class="line">git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)</span><br><span class="line"></span><br><span class="line">git push origin &lt;local_branch&gt; # 创建远程分支， origin是远程仓库名</span><br><span class="line"></span><br><span class="line">git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; # 创建远程分支</span><br><span class="line"></span><br><span class="line">git push origin :&lt;remote_branch&gt; #先删除本地分支(git branch -d &lt;branch&gt;)，然后再push删除远程分支</span><br></pre></td></tr></table></figure><h3 id="Git远程仓库管理"><a href="#Git远程仓库管理" class="headerlink" title="Git远程仓库管理"></a>Git远程仓库管理</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GitHub</span><br><span class="line"></span><br><span class="line">git remote -v # 查看远程服务器地址和仓库名称</span><br><span class="line"></span><br><span class="line">git remote show origin # 查看远程服务器仓库状态</span><br><span class="line"></span><br><span class="line">git remote add origin git@ github:robbin/robbin_site.git # 添加远程仓库地址</span><br><span class="line"></span><br><span class="line">git remote set-url origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址) git remote rm &lt;repository&gt; # 删除远程仓库</span><br></pre></td></tr></table></figure><h3 id="创建远程仓库"><a href="#创建远程仓库" class="headerlink" title="创建远程仓库"></a>创建远程仓库</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git clone --bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库</span><br><span class="line"></span><br><span class="line">scp -r my_project.git git@ git.csdn.net:~ # 将纯仓库上传到服务器上</span><br><span class="line"></span><br><span class="line">mkdir robbin_site.git &amp;&amp; cd robbin_site.git &amp;&amp; git --bare init # 在服务器创建纯仓库</span><br><span class="line"></span><br><span class="line">git remote add origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址</span><br><span class="line"></span><br><span class="line">git push -u origin master # 客户端首次提交</span><br><span class="line"></span><br><span class="line">git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且track</span><br><span class="line"></span><br><span class="line">git remote set-head origin master # 设置远程仓库的HEAD指向master分支</span><br></pre></td></tr></table></figure><h3 id="也可以命令设置跟踪远程库和本地库"><a href="#也可以命令设置跟踪远程库和本地库" class="headerlink" title="也可以命令设置跟踪远程库和本地库"></a>也可以命令设置跟踪远程库和本地库</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream master origin/master</span><br><span class="line"></span><br><span class="line">git branch --set-upstream develop origin/develop</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 辅助工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 辅助工具 </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim命令总结</title>
      <link href="/2016/08/25/IDE/vim/"/>
      <url>/2016/08/25/IDE/vim/</url>
      
        <content type="html"><![CDATA[<h4 id="vim-的基本概念"><a href="#vim-的基本概念" class="headerlink" title="vim 的基本概念"></a>vim 的基本概念</h4><p>vim大致分可为这么几种状态，分别是命令模式、插入模式、视图模式、和底行模式，各模式的功能区分如下：</p><h4 id="1-命令行模式"><a href="#1-命令行模式" class="headerlink" title="1) 命令行模式"></a>1) 命令行模式</h4><p>控制屏幕光标的移动，字符、字或行的删除，移动复制某区段</p><h4 id="2-插入模式"><a href="#2-插入模式" class="headerlink" title="2) 插入模式"></a>2) 插入模式</h4><p>按 i 进入插入模式,对文件的内容进行编辑操作，按 ESC 键可回到命令行模式</p><h4 id="3-视图模式"><a href="#3-视图模式" class="headerlink" title="3) 视图模式"></a>3) 视图模式</h4><p>按 v 或者 V 进入视图模式，对文字区段进行选择,然后进行相应的操作（比如复制一段文字，删除一段文字等等）</p><h4 id="4-底行模式"><a href="#4-底行模式" class="headerlink" title="4) 底行模式"></a>4) 底行模式</h4><p>按 : 或者 / 进入底行模式,其实底行模式也是命令模式的一种等</p><p>常使用底行模式对文件文件保存或退出vim，也可以设置编辑环境，如寻找字符串、列出行号……等</p><h4 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h4><h4 id="1-命令行模式-1"><a href="#1-命令行模式-1" class="headerlink" title="1) 命令行模式"></a>1) 命令行模式</h4><p>h 向左移动光标</p><p>j 向下移动光标</p><p>k 向上移动光标</p><p>l 向右移动光标</p><p>0 移到文件的开头</p><p>G 移动到文件的最后</p><p>$ 移动到光标所在行的“行尾”</p><p>^ 移动到光标所在行的“行首”</p><p>w 光标跳到下个字的开头</p><p>e 光标跳到下个字的字尾</p><p>b 光标回到上个字的开头</p><p>nl 光标移到该行的第n的位置，其中n是数字 如：5l 将光标移动到当前行的第5个字符处</p><p>x 每按一次，删除光标所在位置的“后面”一个字符</p><p>nx 删除光标所在位置的“后面”n个字符,n是数字,比如 5x</p><p>X 删除光标所在位置的“前面”一个字符</p><p>nX 删除光标所在位置的“前面”n个字符,n是数字,比如 5X</p><p>dd 删除光标所在行</p><p>ndd 从光标所在行开始删除n行</p><p>yw 将光标所在之处到字尾的字符复制到缓冲区中</p><p>nyw 复制n个字到缓冲区</p><p>yy 复制光标所在行到缓冲区</p><p>nyy 例如，6yy表示拷贝从光标所在的该行“往下数”6行文字</p><p>p 将缓冲区内的字符贴到光标所在位置注意：所有与“y”有关的复制命令都必须与“p”配合才能完成复制与粘贴功能</p><p>r 替换光标所在处的字符</p><p>R 替换光标所到之处的字符，直到按下「ESC」键为止</p><p>u 如果您误执行一个命令，可以马上按下「u」，回到上一个操作按多次“u”可以执行多次回复</p><p>cw 更改光标所在处的字到字尾处</p><p>cnw 例如，c3w表示更改3个字,其中n是数字</p><p>nG(或者ngg)例如，15G表示移动光标至文件的第15行的行首,其中n是数字</p><p>ctrl+g 列出光标所在行的行号</p><p>ci”清除引号内容</p><p>ci&gt; 清除尖括号内容</p><p>cit 清除标签内的内容</p><p>zc 折叠</p><p>zC 对所在范围内所有嵌套的折叠点进行折叠</p><p>zo 展开折叠</p><p>zO 对所在范围内所有嵌套的折叠点展开</p><p>[z 到当前打开的折叠的开始处</p><p>]z 到当前打开的折叠的末尾处</p><p>zj 向下移动,到达下一个折叠的开始处,关闭的折叠也被计入</p><p>zk 向上移动到前一折叠的结束处,关闭的折叠也被计入</p><p>xp 交换两个字符的位置</p><p>ddp 上下两行调换</p><h4 id="移动屏幕"><a href="#移动屏幕" class="headerlink" title="移动屏幕"></a>移动屏幕</h4><p>ctrl+g 列出光标所在行的行</p><p>ctrl+b 屏幕往“后”移动一页</p><p>ctrl+f 屏幕往“前”移动一页</p><p>ctrl+u 屏幕往“后”移动半页</p><p>ctrl+d 屏幕往“前”移动半页</p><p>shift +3 选中并查找该词组</p><h4 id="跳转位置"><a href="#跳转位置" class="headerlink" title="跳转位置"></a>跳转位置</h4><p>ctrl+o 回到更老的跳转位置</p><p>ctrl+i 向前跳转位置(两个命令前面可以加数字来表示倍数)</p><h4 id="改变大小写"><a href="#改变大小写" class="headerlink" title="改变大小写"></a>改变大小写</h4><p>~ 将光标下的字母改变大小写</p><p>3~ 将光标位置开始的3个字母改变其大小写</p><p>g~~ 改变当前行字母的大小写</p><p>U 将可视模式下选择的字母全改成大写字母</p><p>u 将可视模式下选择的字母全改成小写</p><p>gUU 将当前行的字母改成大写</p><p>3gUU 将从光标开始到下面3行字母改成大写</p><p>guu 将当前行的字母全改成小写</p><p>gUw 将光标下的单词改成大写。</p><p>guw 将光标下的单词改成小写。</p><h4 id="2-插入模式-1"><a href="#2-插入模式-1" class="headerlink" title="2) 插入模式"></a>2) 插入模式</h4><p>i 在光标的前面插入字符</p><p>I 在当前行的第一个字符前插入字符</p><p>o 在当前行的下一行插入新的一行,并在新的一行的第一个字符处插入字符</p><p>O 在当前行的上一行插入新的一行,并在新的一行的第一个字符处插入字符</p><p>a 在光标的后面插入字符</p><p>A 在当前行的最后面插入字符</p><p>按[Esc]回到命令模式</p><h4 id="3-视图模式-1"><a href="#3-视图模式-1" class="headerlink" title="3) 视图模式"></a>3) 视图模式</h4><p>vi” 选择引号内容</p><p>vi&gt; 选择尖括号内容</p><p>vit 选择标签内的内容</p><p>va” 选择包括引号在内的内容</p><p>va&gt; 选择包括尖括号在内的内容</p><p>vat 选择整个标签</p><p>4) 底行模式</p><p>:w filename 将文件以指定的文件名filename保存</p><p>:wq 存盘并退出vim</p><p>:q! 不存盘强制退出vim</p><p>:set nu 显示行号</p><p>:15 回车，跳到文件第15行</p><p>/关键字, 先按「/」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往后寻找到您要的关键字为止</p><p>?关键字, 先按「?」键，再输入您想寻找的字符，如果第一次找的关键字ä¡</p><p>:-n,+n d ‘-‘表示当前行的上n行，’+’表示当前行的下n行,比如命令’:-2,+2 d’的意思，就是说删除但前行的上2行到当前行的下2行</p><p>:n pu 将剪切板中的内容粘贴到n行</p><p>:e filename 在当前编辑的窗口中打开指定的“filename”的文件进行编辑操作</p><p>:p 文件操作，前一个文件</p><p>:n 文件操作，下一个文件</p><p>:last 文件操作，最后一个文件</p><p>:!cmd 执行shell命令</p><p>:sh 进入shell</p><p>:exit 退出shell</p><h4 id="按-Esc-回到命令模式"><a href="#按-Esc-回到命令模式" class="headerlink" title="按[Esc]回到命令模式"></a>按[Esc]回到命令模式</h4>]]></content>
      
      
      <categories>
          
          <category> 辅助工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 辅助工具 </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sublime插件总结</title>
      <link href="/2016/08/25/IDE/sublime/sublimePlug/"/>
      <url>/2016/08/25/IDE/sublime/sublimePlug/</url>
      
        <content type="html"><![CDATA[<h1 id="sublime-插件"><a href="#sublime-插件" class="headerlink" title="sublime 插件"></a>sublime 插件</h1><h3 id="下载："><a href="#下载：" class="headerlink" title="下载："></a>下载：</h3><p>   <a href="https://www.sublimetext.com/3" target="_blank" rel="noopener">https://www.sublimetext.com/3</a>  //下载网址，可以选择版本 sublime Text3    以dmp结尾的</p><h3 id="删除插件："><a href="#删除插件：" class="headerlink" title="删除插件："></a>删除插件：</h3><ol><li>command+shift+P,输入package</li><li>查找remove package</li><li>输入你要删除的package</li><li>回车，OK</li></ol><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件:"></a>安装插件:</h3><pre><code>1. 安装 Package Control   http://www.jianshu.com/p/5baa47642375 (利用Package Control来安装其他插件)2. 上面的 Package Control 安装完以后, 就可以通过快捷键 command + shift + p 并输入 install package, 来选择需要安装的插件.3. 插件有时默认的快捷键会和其他的软件的快捷键冲突，所以可以自己设置插件的快捷键 点击菜单 Preferences -&gt; KeyBindings - User, 加入如下内容 [{ &quot;keys&quot;: [&quot;ctrl+1&quot;], &quot;command&quot;: &quot;alignment&quot; }] 将快捷键修改成自己要改的。</code></pre><h3 id="Sublime-Text常用插件总结"><a href="#Sublime-Text常用插件总结" class="headerlink" title="Sublime Text常用插件总结:"></a>Sublime Text常用插件总结:</h3><pre><code>我认为插件比较官方了解可以参考此链接：https://packagecontrol.io/packages/Babel后面换上不同的插件名称即可，不过可能只是大致介绍一些基础重要的。</code></pre><p><strong>1.) Emmet</strong></p><pre><code>Emmet使用仿CSS选择器的语法来生成代码，大大提高了HTML/CSS代码编写的速度。 具体使用链接：http://www.iteye.com/news/27580  (桌面有两个我写的文件,不过对js和less没有作用)</code></pre><p><strong>2.)Alignment</strong></p><p> 这插件用于对齐代码赋值语句，如<br>  <figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;sublimt&quot;</span><br><span class="line">var version = &quot;2.0.1&quot;</span><br><span class="line">var title = &quot;sublime text</span><br></pre></td></tr></table></figure></p><p> 按下快捷键后, 会变成:<br>  <figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var name    = &quot;sublimt&quot;</span><br><span class="line">var version = &quot;2.0.1&quot;</span><br><span class="line">var title   = &quot;sublime text”</span><br></pre></td></tr></table></figure></p><p><strong>3.)Trimmer</strong></p><p>   你知道当你编写代码时，由于错误或别的某些原因，会产生一些不必要的空格。需要注意的是多余的空格有时也会造成错误。这个插件会自动删除这些不必要的空格，也可以删除空行，可以达到压缩css和js的效果。</p><p><strong>4.)autoprefixer</strong></p><p>  自动在代码前面添加兼容性前缀</p><p>  例子：<br>  <figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">使用前：</span><br><span class="line">.wsl&#123;</span><br><span class="line">    display:flex;</span><br><span class="line">    -webkit-border-radius:20px;</span><br><span class="line">     border-radius:20px;</span><br><span class="line">  &#125;</span><br><span class="line">使用后：</span><br><span class="line">.wsl&#123;</span><br><span class="line">   display:-webkit-box;</span><br><span class="line">   display:-ms-flexbox;</span><br><span class="line">   display:flex;</span><br><span class="line">   border-radius:20px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注释：效果明显，多于的 CSS/less 会自动删掉，border-radius 早就已经不需要前缀了，只有 Firefox 3.6，Chrome 4，Safari 4 和 Android 2.1 需要前缀；</p><p>快捷键设置方式还是如上第三步所示：</p><p>  <img src="images/11.jpg" width="350px" height="100px"></p><p><strong>5.)Less</strong></p><pre><code>功能：LESS高亮插件简介：用LESS的同学都知道，sublime没有支持less的语法高亮，所以这个插件可以帮上我们使用：打开.less文件或者设置为less格式//在没安装这个插件之前less文件中的代码是白色的，看着很不舒服，安装了这个插件则会让代码加上颜色</code></pre><p><strong>6.)Babel</strong></p><pre><code>这个插件支持ES6， React.js, jsx代码高亮，对 JavaScript, jQuery 也有很好的扩展。按照上述步骤安装后，在view-&gt;Syntax(语法)-&gt;这个时候安装了babel就会有一项选择Babel-&gt;Babel(javascript)这一项，代码就会变高亮。 （默认是Syntax下面的javascript）。</code></pre><p><strong>7.)BracketHighlighter</strong></p><ol><li><p>BracketHighlighter插件能为Sublime Text提供括号，引号这类高亮功能，但安装此插件后，默认没有高亮，只有下划线表示，不是很醒目，跟进一步的修改可以</p><p><a href="http://www.wdclab.com/2015/09/10/mac%E7%89%88sublime-text-3%E4%B8%ADbrackethighlighter%E6%8F%92%E4%BB%B6%E9%AB%98%E4%BA%AE%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95/" target="_blank" rel="noopener">http://www.wdclab.com/2015/09/10/mac%E7%89%88sublime-text-3%E4%B8%ADbrackethighlighter%E6%8F%92%E4%BB%B6%E9%AB%98%E4%BA%AE%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95/</a>   (mac)</p><p><a href="http://www.cnblogs.com/willingtolove/p/4657320.html" target="_blank" rel="noopener">http://www.cnblogs.com/willingtolove/p/4657320.html</a>       (windows)</p></li><li><p>可以参考此链接 ,很有用,执行完第二步是白色高亮</p><p><img src="images/12.jpg" width="300px" height="100px"></p></li><li><p>若想彩色高亮则根据步骤继续进行第三步。</p><p><img src="images/13.jpg" width="300px" height="50px">,</p><p><img src="images/14.jpg" width="300px" height="100x"></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> Bracket Quote 表示引号     </span><br><span class="line"> Bracket Tag   表示标签</span><br><span class="line"> Bracket Angle 表示角 （这个可以自己试试）</span><br><span class="line"> Bracket Square 表示方括号</span><br><span class="line"> Bracket Round  表示小括号</span><br><span class="line"> Bracket Curly  表示大括号</span><br><span class="line">不过实现彩色的效果还需要安装SublimeLinter</span><br></pre></td></tr></table></figure></li></ol><h4 id="主题相关插件8-9"><a href="#主题相关插件8-9" class="headerlink" title="{主题相关插件8-9}"></a>{主题相关插件8-9}</h4><p><strong>8.)Theme-Soda</strong></p><p> Soda主题是sublime上一款很著名的清爽型主题，分两种：</p><p> <code>light:</code></p><p> <img src="images/15.jpg" width="300px" height="50px"></p><p>  <code>dark:</code></p><p> <img src="images/16.jpg" width="300px" height="50px"></p><p> <code>两者之间的切换通过在 （菜单 Preferences -&gt; Settings - User）中加入 &quot;theme&quot;: &quot;Soda Light.sublime-theme&quot; 或 &quot;theme&quot;: &quot;Soda Dark.sublime-theme”</code></p><p> <img src="images/17.jpg" width="300px" height="100px"></p><p> <code>如果想要原来默认的则去掉这句话不写即可，默认：</code></p><p> <img src="images/18.jpg" width="300px" height="50px"></p><p>保存之后发现怎么代码区域还是黑色的背景，菜单栏颜色已经切换了，别急，这里还少了一步，就是配置一下color scheme,就用下面的插件介绍</p><p><strong>9.)ColorSublime</strong><br> <figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主题可以参考此链接： http://www.jianshu.com/p/13fedee165f1</span><br><span class="line">主要以ColorSublime为插件安装</span><br><span class="line">安装了ColorSublime后，在控制面板里输入安装ColorSublime:install theme</span><br><span class="line">就可以如链接所示，选择你相中的主体安装</span><br></pre></td></tr></table></figure></p><h4 id="文件模版10"><a href="#文件模版10" class="headerlink" title="{文件模版10}"></a>{文件模版10}</h4><p><strong>10.)SublimeTmpl</strong></p><p><a href="http://www.fantxi.com/blog/archives/sublime-template-engine-sublimetmpl/" target="_blank" rel="noopener">http://www.fantxi.com/blog/archives/sublime-template-engine-sublimetmpl/</a><br>只看使用，安装就行，Sublime Text 新建文件的模版插件</p><h4 id="JS代码格式化11"><a href="#JS代码格式化11" class="headerlink" title="{JS代码格式化11}"></a>{JS代码格式化11}</h4><p><strong>11.)JsFormat</strong></p><p>  这是一款将JS格式化的插件，安装后即可在JS文件中通过鼠标右键-&gt;JsFormat或键盘快捷键Ctrl+Alt+F对JS进行格式化</p><h4 id="右键菜单功能增强插件12"><a href="#右键菜单功能增强插件12" class="headerlink" title="{右键菜单功能增强插件12}"></a>{右键菜单功能增强插件12}</h4><p><strong>12.)SideBarEnhancements</strong></p><p>  这是一款很实用的右键菜单增强功能，安装之前左侧菜单栏右键只有几个功能，安装之后增加了很多实用功能。<br>  可以参考这个链接，有个简单的说明：<a href="https://nicesu.gitbooks.io/sublime-text-guide/content/plug-in/sidebarenhancements.html" target="_blank" rel="noopener">https://nicesu.gitbooks.io/sublime-text-guide/content/plug-in/sidebarenhancements.html</a></p><h4 id="只针对-css的文件代码排序13"><a href="#只针对-css的文件代码排序13" class="headerlink" title="{只针对.css的文件代码排序13}"></a>{只针对.css的文件代码排序13}</h4><p><strong>13.)CSScomb</strong><br> <code>格式化前：</code></p><p> <img src="images/19.jpg" width="250px" height="130px">,</p><p> <code>格式化后：快捷键 ctrl+shift+c</code></p><p> <img src="images/20.jpg" width="250px" height="200px">,</p><p> 但是会产生一些空行，可以解决:<br> 在sublime中下载<code>CSS Format</code>插件，然后执行 edit-&gt;css format-&gt;expanded 即可此   时空行将会消除。</p><p> <img src="images/21.jpg" width="250px" height="200px">,</p><p><code>我认为可以先用css最后可以改成less文件可以参考这个链接：https://segmentfault.com/a/1190000004577644</code></p><h4 id="文件中打开命令行窗口14"><a href="#文件中打开命令行窗口14" class="headerlink" title="{文件中打开命令行窗口14}"></a>{文件中打开命令行窗口14}</h4><p><strong>14.)Terminal</strong><br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在编程过程中我们需要经常使用到命令行窗口，此快捷键可以在sublime Text3中打开cmd窗口，默认打开的是终端，如果想要打开iTerm,可以在setting-&gt;user中设置：</span><br><span class="line">快捷键（mac）:cmd+shift+t</span><br><span class="line">可以参考链接：https://packagecontrol.io/packages/Terminal</span><br></pre></td></tr></table></figure></p><h3 id="查看html、css兼容的15"><a href="#查看html、css兼容的15" class="headerlink" title="{查看html、css兼容的15}"></a>{查看html、css兼容的15}</h3><p><strong>15.)Can I Use</strong></p><p>不过只是针对html和css，选中一个词或标签按快捷键：ctrl+alt+f就会跳到<a href="http://caniuse.com/，可以看到兼容到哪些浏览器" target="_blank" rel="noopener">http://caniuse.com/，可以看到兼容到哪些浏览器</a></p><h3 id="代码校验16"><a href="#代码校验16" class="headerlink" title="{代码校验16}"></a>{代码校验16}</h3><p><strong>16.)SublimeLinter</strong></p><p>  SublimeLinter是一个代码校验插件，它可以帮你找出错误或编写不规范的代码<br>  会在页面上产生一些点，点击点会有提示在下方<br>  可以按照这个安装：  </p><p>  <a href="http://www.cnblogs.com/xiaofeixiang/p/4853625.html" target="_blank" rel="noopener">http://www.cnblogs.com/xiaofeixiang/p/4853625.html</a></p><p>  可以通过这个研究：</p><p>  <a href="https://nicesu.gitbooks.io/sublime-text-guide/content/plug-in/sublimelinter.html" target="_blank" rel="noopener">https://nicesu.gitbooks.io/sublime-text-guide/content/plug-in/sublimelinter.html</a></p><p>  <strong>(但是不知道怎么把下面提示区域放大？)</strong></p><p>####{在文件中调用Git命令17}<br><strong>17.)Git</strong></p><p>   可以参考此链接：<a href="https://packagecontrol.io/packages/Git" target="_blank" rel="noopener">https://packagecontrol.io/packages/Git</a><br>   安装完git后可以在mac中用命令打开：cmd+shift+p，输入git就会出现很多git命令。</p><p> <strong>(但是git status可以用，其他的怎么用？)</strong></p>]]></content>
      
      
      <categories>
          
          <category> IDE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDE </tag>
            
            <tag> 辅助工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>atom快捷键总结</title>
      <link href="/2016/08/25/IDE/atom/"/>
      <url>/2016/08/25/IDE/atom/</url>
      
        <content type="html"><![CDATA[<h3 id="atom"><a href="#atom" class="headerlink" title="atom"></a>atom</h3><h3 id="一、快捷键部分"><a href="#一、快捷键部分" class="headerlink" title="一、快捷键部分"></a>一、快捷键部分</h3><h4 id="A-光标及选取部分"><a href="#A-光标及选取部分" class="headerlink" title="A:光标及选取部分"></a>A:光标及选取部分</h4><h5 id="行部分："><a href="#行部分：" class="headerlink" title="行部分："></a>行部分：</h5><p> cmd+up          光标移动至文件开始处<br> cmd+down        光标移动至文件结束处<br> cmd+click       多行同时输入<br> cmd+l           选取此行<br> ctrl+shift+n    选取下一行<br> ctrl+shift+p    选取下一行<br> cmd+shift+left  选取至此行开始处<br> cmd+shift+right 选取至此行结束处<br> cmd+shift+up    选取至文件开始<br> cmd+shift+down  选取至文件结尾   </p><h5 id="单词-字符-部分："><a href="#单词-字符-部分：" class="headerlink" title="单词(字符)部分："></a>单词(字符)部分：</h5><p> cmd+shift+w     选中此单词<br> alt+shift+left  选取至此单词开始处<br> alt+shift+right 选取至此单词结束处<br> cmd+d           选取文件中和当前单词相同的下一处并增加光标<br> ctrl+cmd+g      选取文档中所有和当前光标单词相同的位置并增加光标   </p><h5 id="括号部分："><a href="#括号部分：" class="headerlink" title="括号部分："></a>括号部分：</h5><p> ctrl-m 相应括号之间，html tag之间等跳转<br> ctrl-cmd-m 括号(tag)之间文本选取   </p><h4 id="B-编辑操作"><a href="#B-编辑操作" class="headerlink" title="B:编辑操作"></a>B:编辑操作</h4><h5 id="行部分：-1"><a href="#行部分：-1" class="headerlink" title="行部分："></a>行部分：</h5><p>cmd-J 将下一行与当前行合并<br>ctrl-cmd-up, ctrl-cmd-down 使当前行向上或者向下移动<br>cmd-shift-D 复制当前行到下一行<br>ctrl-K 剪切到当前行结束<br>ctrl-shift-K 删除当前行<br>cmd-backspace 删除到当前行开始<br>cmd-fn-backspace 删除到当前行结束   </p><h5 id="字符-单词-部分："><a href="#字符-单词-部分：" class="headerlink" title="字符(单词)部分："></a>字符(单词)部分：</h5><p> ctrl-T 使光标前后字符交换<br> alt-backspace 或 alt-H 删除到当前单词开始<br> alt-delete 或 alt-D 删除到当前单词结束<br> cmd-K+cmd-U 使当前字符大写<br> cmd-K+cmd-L 使当前字符小写   </p><h4 id="C-功能部分"><a href="#C-功能部分" class="headerlink" title="C:功能部分"></a>C:功能部分</h4><p> cmd+,      打开setting<br> control+tab 切换标签页<br> control+数字 切换标签页<br> 忽略文件显示更改：<br> setting=&gt;open config Folder=&gt;config.cson=&gt;最后那个h开头的改为false   </p><h3 id="二、atom实用插件"><a href="#二、atom实用插件" class="headerlink" title="二、atom实用插件"></a>二、atom实用插件</h3><h4 id="1-Emmet"><a href="#1-Emmet" class="headerlink" title="1 Emmet"></a>1 Emmet</h4><p> 用法：Ctrl+Alt+Enter   </p><h4 id="2-Atom-Beautify"><a href="#2-Atom-Beautify" class="headerlink" title="2 Atom Beautify"></a>2 Atom Beautify</h4><p>  代码优化   </p><h4 id="3-Minimap"><a href="#3-Minimap" class="headerlink" title="3 Minimap"></a>3 Minimap</h4><p>  sublime右上角代码缩略图   </p><h4 id="4-file-icons"><a href="#4-file-icons" class="headerlink" title="4 file-icons"></a>4 file-icons</h4><p>  文件图标   </p><h4 id="5-atom-ternjs"><a href="#5-atom-ternjs" class="headerlink" title="5 atom-ternjs"></a>5 atom-ternjs</h4><p>  js代码提示   </p><h4 id="6-atom-react-autocomplete"><a href="#6-atom-react-autocomplete" class="headerlink" title="6 atom-react-autocomplete"></a>6 atom-react-autocomplete</h4><p>  jsx代码提示   </p>]]></content>
      
      
      <categories>
          
          <category> IDE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDE </tag>
            
            <tag> 辅助工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vsCode  编辑器</title>
      <link href="/2016/08/25/IDE/vscode/"/>
      <url>/2016/08/25/IDE/vscode/</url>
      
        <content type="html"><![CDATA[<h2 id="vsCode-编辑器"><a href="#vsCode-编辑器" class="headerlink" title="vsCode  编辑器"></a>vsCode  编辑器</h2><p><a href="https://jeasonstudio.gitbooks.io/vscode-cn-doc/content/md/%E5%AE%9A%E5%88%B6%E5%8C%96/%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E4%BB%A3%E7%A0%81%E6%AE%B5.html" target="_blank" rel="noopener">相关文档</a></p>]]></content>
      
      
      <categories>
          
          <category> IDE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDE </tag>
            
            <tag> 辅助工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flex布局</title>
      <link href="/2016/08/25/CSS/flex/"/>
      <url>/2016/08/25/CSS/flex/</url>
      
        <content type="html"><![CDATA[<p>注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。</p><p>[flex学习地址]（<a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/）" target="_blank" rel="noopener">https://css-tricks.com/snippets/css/a-guide-to-flexbox/）</a></p><h3 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h3><img src="/2016/08/25/CSS/flex/flexBox.png" title="flexbox"><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Flex容器（flex container）：采用Flex布局的元素。</span><br><span class="line">水平的主轴（main axis）和垂直的交叉轴（cross axis）。</span><br><span class="line">主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；</span><br><span class="line">交叉轴的开始位置叫做cross start，结束位置叫做cross end</span><br></pre></td></tr></table></figure><h3 id="二、容器的属性"><a href="#二、容器的属性" class="headerlink" title="二、容器的属性"></a>二、容器的属性</h3><p>有六个属性设置在容器上</p><ul><li>flex-direction</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ul><h5 id="flex-direction属性"><a href="#flex-direction属性" class="headerlink" title="flex-direction属性"></a>flex-direction属性</h5><p>决定主轴的方向（即子元素的排列方向）<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  flex-direction: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2016/08/25/CSS/flex/direction.png" title="direction"><p>他有四个值</p><ul><li>row(默认值)：主轴为水平方向，起点在左边</li><li>row-reverse:主轴为水平方向，起点为右边</li><li>column：主轴为垂直方向，起点在上方</li><li>column-reverse：主轴为垂直方向，起点在下方</li></ul><h5 id="flex-wrap属性"><a href="#flex-wrap属性" class="headerlink" title="flex-wrap属性"></a>flex-wrap属性</h5><p>定义如果一条轴放不下，该如何换行<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  flex-wrap: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>他有三个可取值</p><ol><li>nowrap(默认)：不换行<br><img src="images/flex/nowrap.png" width="700px"></li><li>wrap:换行，第一行在上方<br><img src="images/flex/wrap.jpg" width="700px"></li><li>wrap-reverse:换行，第一行在下方<br><img src="images/flex/wrap-reverse.jpg" width="700px"></li></ol><h5 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h5><p>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h5><p>定义了子元素在主轴上的对齐方向<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  justify-content: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>他有5个值</p><ul><li>flex-start(默认值)：左对齐</li><li>flex-end:右对齐</li><li>center：居中</li><li>space-between：两端对齐，项目之间的间隔都相等</li><li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li></ul><img src="/2016/08/25/CSS/flex/justify-content.png" title="justify-content"><h5 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h5><p>align-items属性定义项目在交叉轴上如何对齐<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  align-items: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>flex-start：交叉轴的起点对齐</li><li>flex-end:交叉轴的终点对齐</li><li>center：交叉轴的中点对齐</li><li>baseline：项目的第一行文字的基线对齐</li><li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度</li></ul><h5 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h5><p>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  align-content: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>flex-start：交叉轴的起点对齐</li><li>flex-end:交叉轴的终点对齐</li><li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li><li>center：与交叉轴的中点对齐。</li><li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li><li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li></ul><img src="/2016/08/25/CSS/flex/align-content.png" title="align-content"><h3 id="三、项目的属性"><a href="#三、项目的属性" class="headerlink" title="三、项目的属性"></a>三、项目的属性</h3><p>以下6个属性设置在项目上</p><ul><li>order</li><li>flex-grow</li><li>flex-shrink</li><li>flex-basis</li><li>flex</li><li>align-self</li></ul><h6 id="order"><a href="#order" class="headerlink" title="order"></a>order</h6><p>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  order: &lt;integer&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2016/08/25/CSS/flex/order.png" title="order"><h5 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h5><p>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。<br>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。<br><img src="images/flex/flex-grow.png" width="500px"></p><h5 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h5><p>定义项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex-shrink: &lt;number&gt;; /* default 1 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="images/flex/flex-shrink.jpg" width="500px"><br>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小</p><h5 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h5><p>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex-basis: &lt;length&gt; | auto; /* default auto */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间</p><h5 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h5><p>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。<br>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值.</p><h5 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h5><p>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  align-self: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2016/08/25/CSS/flex/align-self.png" title="align-self"><h3 id="四、flex兼容性"><a href="#四、flex兼容性" class="headerlink" title="四、flex兼容性"></a>四、flex兼容性</h3><p>flex更新版本</p><ul><li>display:box是2009年的语法版本，使用时需要加上浏览器的前缀，不过现在已经过时了。</li><li>display:flex是2012年最新修正的语法版本，浏览器支持较好，也将成为以后标准的语法。</li><li>中间2011年也提出了一个奇葩的语法版本display:flexbox，非官方的，当时主要是为IE浏览器使用。</li></ul><h4 id="PC端："><a href="#PC端：" class="headerlink" title="PC端："></a>PC端：</h4><p>display:box 浏览器支持</p><table><thead><tr><th>IE</th><th style="text-align:center">Firefox</th><th style="text-align:center">Chrome</th><th style="text-align:center">Safari</th><th>Opera</th></tr></thead><tbody><tr><td>不支持</td><td style="text-align:center">2.0-40.0（-moz-）</td><td style="text-align:center">4.0-45.0(-webkit-)</td><td style="text-align:center">6.0-8.0(-webkit-)</td><td>15.0-29.0(-webkit-)</td></tr></tbody></table><p>display:flex浏览器支持</p><table><thead><tr><th>IE</th><th style="text-align:center">Firefox</th><th style="text-align:center">Chrome</th><th style="text-align:center">Safari</th><th>Opera</th></tr></thead><tbody><tr><td>11.0+</td><td style="text-align:center">22.0+</td><td style="text-align:center">21.0+(-webkit-) 29.0+</td><td style="text-align:center">6.1+(-webkit-) 9.0+</td><td>15.0+(-webkit-) 17.0+</td></tr></tbody></table><h4 id="移动端："><a href="#移动端：" class="headerlink" title="移动端："></a>移动端：</h4><h5 id="display-flex"><a href="#display-flex" class="headerlink" title="display:flex"></a>display:flex</h5><ul><li>iOS的原生safari浏览器是支持的；UC浏览器支持的很好；微信浏览器不支持</li><li>安卓的原生浏览器不支持，能够正常显示模块，文档流依次排列；UC浏览器不支持，显示为空白；微信浏览器不支持</li></ul><h5 id="display-box"><a href="#display-box" class="headerlink" title="display:box"></a>display:box</h5><ul><li>ios的原生safari浏览器是支持的；UC浏览器支持的很好</li><li>安卓的原生浏览器支持；UC浏览器支持</li></ul><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">其实要使多浏览器兼容flexbox容器样式，可以使用如下CSS样式进行定义：</span><br><span class="line">.box &#123;</span><br><span class="line">    display: -webkit-box; /* Chrome 4+, Safari 3.1, iOS Safari 3.2+ */</span><br><span class="line">    display: -moz-box; /* Firefox 17- */</span><br><span class="line">    display: -webkit-flex; /* Chrome 21+, Safari 6.1+, iOS Safari 7+, Opera 15/16 */</span><br><span class="line">    display: -moz-flex; /* Firefox 18+ */</span><br><span class="line">    display: -ms-flexbox; /* IE 10 */</span><br><span class="line">    display: flex; /* Chrome 29+, Firefox 22+, IE 11+, Opera 12.1/17/18, Android 4.4+ */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> css3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css3 </tag>
            
            <tag> flex </tag>
            
            <tag> 布局 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
